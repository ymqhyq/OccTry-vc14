<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: opencascade::handle&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopencascade.html">opencascade</a></li><li class="navelem"><a class="el" href="classopencascade_1_1handle.html">handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">opencascade::handle&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive smart pointer for use with <a class="el" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. ">Standard_Transient</a> class and its descendants.  
 <a href="classopencascade_1_1handle.html#details">More...</a></p>

<p><code>#include &lt;Standard_Transient.hxx&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a203befbdce71112e7c1799ffdb9c7ade"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a203befbdce71112e7c1799ffdb9c7ade">element_type</a></td></tr>
<tr class="memdesc:a203befbdce71112e7c1799ffdb9c7ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compliant typedef of contained type.  <a href="#a203befbdce71112e7c1799ffdb9c7ade">More...</a><br /></td></tr>
<tr class="separator:a203befbdce71112e7c1799ffdb9c7ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e1b9cfa6f8af03cdad0e2069bab8946"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a1e1b9cfa6f8af03cdad0e2069bab8946">handle</a> ()</td></tr>
<tr class="memdesc:a1e1b9cfa6f8af03cdad0e2069bab8946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#a1e1b9cfa6f8af03cdad0e2069bab8946">More...</a><br /></td></tr>
<tr class="separator:a1e1b9cfa6f8af03cdad0e2069bab8946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162edab023eb68868d2cba9e82dee23c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a162edab023eb68868d2cba9e82dee23c">handle</a> (const T *thePtr)</td></tr>
<tr class="memdesc:a162edab023eb68868d2cba9e82dee23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from pointer to new object.  <a href="#a162edab023eb68868d2cba9e82dee23c">More...</a><br /></td></tr>
<tr class="separator:a162edab023eb68868d2cba9e82dee23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84f11556ecb55183df5755b692fdbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#acc84f11556ecb55183df5755b692fdbf">handle</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;theHandle)</td></tr>
<tr class="memdesc:acc84f11556ecb55183df5755b692fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#acc84f11556ecb55183df5755b692fdbf">More...</a><br /></td></tr>
<tr class="separator:acc84f11556ecb55183df5755b692fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5175cb900e2076b843dd2c684a53514"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#ab5175cb900e2076b843dd2c684a53514">handle</a> (<a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;&amp;theHandle)</td></tr>
<tr class="memdesc:ab5175cb900e2076b843dd2c684a53514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab5175cb900e2076b843dd2c684a53514">More...</a><br /></td></tr>
<tr class="separator:ab5175cb900e2076b843dd2c684a53514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cbb5d50d77b33e56244a4213b8b60a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a39cbb5d50d77b33e56244a4213b8b60a">~handle</a> ()</td></tr>
<tr class="memdesc:a39cbb5d50d77b33e56244a4213b8b60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a39cbb5d50d77b33e56244a4213b8b60a">More...</a><br /></td></tr>
<tr class="separator:a39cbb5d50d77b33e56244a4213b8b60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038bf0dff775f02961db6c6c60c5817b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a038bf0dff775f02961db6c6c60c5817b">Nullify</a> ()</td></tr>
<tr class="memdesc:a038bf0dff775f02961db6c6c60c5817b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify the handle.  <a href="#a038bf0dff775f02961db6c6c60c5817b">More...</a><br /></td></tr>
<tr class="separator:a038bf0dff775f02961db6c6c60c5817b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f47b982be11db9a4f023562b1068f81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a9f47b982be11db9a4f023562b1068f81">IsNull</a> () const</td></tr>
<tr class="memdesc:a9f47b982be11db9a4f023562b1068f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for being null.  <a href="#a9f47b982be11db9a4f023562b1068f81">More...</a><br /></td></tr>
<tr class="separator:a9f47b982be11db9a4f023562b1068f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a65c26e6e049ba1538c0c58ac59b070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a6a65c26e6e049ba1538c0c58ac59b070">reset</a> (T *thePtr)</td></tr>
<tr class="memdesc:a6a65c26e6e049ba1538c0c58ac59b070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset by new pointer.  <a href="#a6a65c26e6e049ba1538c0c58ac59b070">More...</a><br /></td></tr>
<tr class="separator:a6a65c26e6e049ba1538c0c58ac59b070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c307fd8dfb8901c329f7bde210b60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#ae5c307fd8dfb8901c329f7bde210b60e">operator=</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;theHandle)</td></tr>
<tr class="memdesc:ae5c307fd8dfb8901c329f7bde210b60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae5c307fd8dfb8901c329f7bde210b60e">More...</a><br /></td></tr>
<tr class="separator:ae5c307fd8dfb8901c329f7bde210b60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c08d6959078fb2a597cdb850e942588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a4c08d6959078fb2a597cdb850e942588">operator=</a> (const T *thePtr)</td></tr>
<tr class="memdesc:a4c08d6959078fb2a597cdb850e942588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to pointer.  <a href="#a4c08d6959078fb2a597cdb850e942588">More...</a><br /></td></tr>
<tr class="separator:a4c08d6959078fb2a597cdb850e942588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59fab5b37b9ea212ec7df02d0d5198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a7b59fab5b37b9ea212ec7df02d0d5198">operator=</a> (<a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;&amp;theHandle)</td></tr>
<tr class="memdesc:a7b59fab5b37b9ea212ec7df02d0d5198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move operator.  <a href="#a7b59fab5b37b9ea212ec7df02d0d5198">More...</a><br /></td></tr>
<tr class="separator:a7b59fab5b37b9ea212ec7df02d0d5198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e505aca4b1e2568e563c752c91e52"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a7a2e505aca4b1e2568e563c752c91e52">get</a> () const</td></tr>
<tr class="memdesc:a7a2e505aca4b1e2568e563c752c91e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like cast to pointer to referred object (note non-const).  <a href="#a7a2e505aca4b1e2568e563c752c91e52">More...</a><br /></td></tr>
<tr class="separator:a7a2e505aca4b1e2568e563c752c91e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396719389a098e39a075ee2592495b00"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a396719389a098e39a075ee2592495b00">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a396719389a098e39a075ee2592495b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator (note non-const)  <a href="#a396719389a098e39a075ee2592495b00">More...</a><br /></td></tr>
<tr class="separator:a396719389a098e39a075ee2592495b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b388ca2d98bc1d2ab2a9287f40abb4"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a16b388ca2d98bc1d2ab2a9287f40abb4">operator*</a> () const</td></tr>
<tr class="memdesc:a16b388ca2d98bc1d2ab2a9287f40abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferencing operator (note non-const)  <a href="#a16b388ca2d98bc1d2ab2a9287f40abb4">More...</a><br /></td></tr>
<tr class="separator:a16b388ca2d98bc1d2ab2a9287f40abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bb04e6362253bb3788eb270bf57920"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a91bb04e6362253bb3788eb270bf57920"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a91bb04e6362253bb3788eb270bf57920">operator==</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;theHandle) const</td></tr>
<tr class="memdesc:a91bb04e6362253bb3788eb270bf57920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for equality.  <a href="#a91bb04e6362253bb3788eb270bf57920">More...</a><br /></td></tr>
<tr class="separator:a91bb04e6362253bb3788eb270bf57920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdc060b33a893077f1b035706e53b26"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a7cdc060b33a893077f1b035706e53b26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a7cdc060b33a893077f1b035706e53b26">operator==</a> (const T2 *thePtr) const</td></tr>
<tr class="memdesc:a7cdc060b33a893077f1b035706e53b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for equality.  <a href="#a7cdc060b33a893077f1b035706e53b26">More...</a><br /></td></tr>
<tr class="separator:a7cdc060b33a893077f1b035706e53b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71896a61e07c99f7179ea0734c4d8273"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a71896a61e07c99f7179ea0734c4d8273"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a71896a61e07c99f7179ea0734c4d8273">operator!=</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;theHandle) const</td></tr>
<tr class="memdesc:a71896a61e07c99f7179ea0734c4d8273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for inequality.  <a href="#a71896a61e07c99f7179ea0734c4d8273">More...</a><br /></td></tr>
<tr class="separator:a71896a61e07c99f7179ea0734c4d8273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377a39eed6a518626c576432d1dc4cb"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a0377a39eed6a518626c576432d1dc4cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a0377a39eed6a518626c576432d1dc4cb">operator!=</a> (const T2 *thePtr) const</td></tr>
<tr class="memdesc:a0377a39eed6a518626c576432d1dc4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for inequality.  <a href="#a0377a39eed6a518626c576432d1dc4cb">More...</a><br /></td></tr>
<tr class="separator:a0377a39eed6a518626c576432d1dc4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fcc22059b5e78e027ceb7fcbf3568f"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a55fcc22059b5e78e027ceb7fcbf3568f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a55fcc22059b5e78e027ceb7fcbf3568f">operator&lt;</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;theHandle) const</td></tr>
<tr class="memdesc:a55fcc22059b5e78e027ceb7fcbf3568f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare operator for possible use in std::map&lt;&gt; etc.  <a href="#a55fcc22059b5e78e027ceb7fcbf3568f">More...</a><br /></td></tr>
<tr class="separator:a55fcc22059b5e78e027ceb7fcbf3568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efe1606841845889ada9a903295a400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a0efe1606841845889ada9a903295a400">operator Standard_Transient *handle::*</a> () const</td></tr>
<tr class="memdesc:a0efe1606841845889ada9a903295a400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to bool-compatible type for use in conditional expressions.  <a href="#a0efe1606841845889ada9a903295a400">More...</a><br /></td></tr>
<tr class="separator:a0efe1606841845889ada9a903295a400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcfc44678ff1327c5d816d7d0c5bb3e"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:afbcfc44678ff1327c5d816d7d0c5bb3e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#afbcfc44678ff1327c5d816d7d0c5bb3e">operator const handle&lt; T2 &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:afbcfc44678ff1327c5d816d7d0c5bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast to const reference to base type. NB: this implementation will cause ambiguity errors on calls to overloaded functions accepting handles to different types, since compatibility is checked in the cast code rather than ensured by SFINAE (possible with C++11)  <a href="#afbcfc44678ff1327c5d816d7d0c5bb3e">More...</a><br /></td></tr>
<tr class="separator:afbcfc44678ff1327c5d816d7d0c5bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93439815d0ae587b88665fdb5abb8939"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a93439815d0ae587b88665fdb5abb8939"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a93439815d0ae587b88665fdb5abb8939">operator handle&lt; T2 &gt; &amp;</a> ()</td></tr>
<tr class="memdesc:a93439815d0ae587b88665fdb5abb8939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast to non-const reference to base type. NB: this cast can be dangerous, but required for legacy code; see #26377.  <a href="#a93439815d0ae587b88665fdb5abb8939">More...</a><br /></td></tr>
<tr class="separator:a93439815d0ae587b88665fdb5abb8939"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac49ceb02c7d589c3027cb8a5882c9b09"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ac49ceb02c7d589c3027cb8a5882c9b09"><td class="memTemplItemLeft" align="right" valign="top">static opencascade::std::enable_if&lt; <a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt; T2, T &gt;::value, <a class="el" href="classopencascade_1_1handle.html">handle</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#ac49ceb02c7d589c3027cb8a5882c9b09">DownCast</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;theObject)</td></tr>
<tr class="memdesc:ac49ceb02c7d589c3027cb8a5882c9b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down casting operator from handle to base type.  <a href="#ac49ceb02c7d589c3027cb8a5882c9b09">More...</a><br /></td></tr>
<tr class="separator:ac49ceb02c7d589c3027cb8a5882c9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a7c4856884e81d3700d1a07f234bec"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ad6a7c4856884e81d3700d1a07f234bec"><td class="memTemplItemLeft" align="right" valign="top">static opencascade::std::enable_if&lt; <a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt; T2, T &gt;::value, <a class="el" href="classopencascade_1_1handle.html">handle</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#ad6a7c4856884e81d3700d1a07f234bec">DownCast</a> (const T2 *thePtr)</td></tr>
<tr class="memdesc:ad6a7c4856884e81d3700d1a07f234bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down casting operator from pointer to base type.  <a href="#ad6a7c4856884e81d3700d1a07f234bec">More...</a><br /></td></tr>
<tr class="separator:ad6a7c4856884e81d3700d1a07f234bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85169bdb4b26e733512e6dd1d57348ae"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a85169bdb4b26e733512e6dd1d57348ae"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classopencascade_1_1handle.html">handle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a85169bdb4b26e733512e6dd1d57348ae">DownCast</a> (const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;theObject, typename opencascade::std::enable_if&lt;!<a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt; T2, T &gt;::value, void *&gt;::type=0)</td></tr>
<tr class="memdesc:a85169bdb4b26e733512e6dd1d57348ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">For compatibility, define down casting operator from non-base type, as deprecated.  <a href="#a85169bdb4b26e733512e6dd1d57348ae">More...</a><br /></td></tr>
<tr class="separator:a85169bdb4b26e733512e6dd1d57348ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a759322299d85174e142c50e6bcd1d"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a80a759322299d85174e142c50e6bcd1d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classopencascade_1_1handle.html">handle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a80a759322299d85174e142c50e6bcd1d">DownCast</a> (const T2 *thePtr, typename opencascade::std::enable_if&lt;!<a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt; T2, T &gt;::value, void *&gt;::type=0)</td></tr>
<tr class="memdesc:a80a759322299d85174e142c50e6bcd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For compatibility, define down casting operator from non-base type, as deprecated.  <a href="#a80a759322299d85174e142c50e6bcd1d">More...</a><br /></td></tr>
<tr class="separator:a80a759322299d85174e142c50e6bcd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1ce2fae814ab9e14e900c87e69d14d27"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a1ce2fae814ab9e14e900c87e69d14d27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a1ce2fae814ab9e14e900c87e69d14d27">operator==</a> (const T2 *left, const <a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;right)</td></tr>
<tr class="memdesc:a1ce2fae814ab9e14e900c87e69d14d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for equality.  <a href="#a1ce2fae814ab9e14e900c87e69d14d27">More...</a><br /></td></tr>
<tr class="separator:a1ce2fae814ab9e14e900c87e69d14d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788eb394fa7891ed0d955757397e2002"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a788eb394fa7891ed0d955757397e2002"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopencascade_1_1handle.html#a788eb394fa7891ed0d955757397e2002">operator!=</a> (const T2 *left, const <a class="el" href="classopencascade_1_1handle.html">handle</a> &amp;right)</td></tr>
<tr class="memdesc:a788eb394fa7891ed0d955757397e2002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for inequality.  <a href="#a788eb394fa7891ed0d955757397e2002">More...</a><br /></td></tr>
<tr class="separator:a788eb394fa7891ed0d955757397e2002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class opencascade::handle&lt; T &gt;</h3>

<p>Intrusive smart pointer for use with <a class="el" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. ">Standard_Transient</a> class and its descendants. </p>
<p>This class is similar to boost::intrusive_ptr&lt;&gt;. The reference counter is part of the base class (<a class="el" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. ">Standard_Transient</a>), thus creation of a handle does not require allocation of additional memory for the counter. All handles to the same object share the common counter; object is deleted when the last handle pointing on it is destroyed. It is safe to create a new handle from plain C pointer to the object already pointed by another handle. The same object can be referenced by handles of different types (as soon as they are compatible with the object type).</p>
<p>Handle has type cast operator to const reference to handle to the base types, which allows it to be passed by reference in functions accepting reference to handle to base class, without copying.</p>
<p>By default, the type cast operator is provided also for non-const reference. These casts (potentially unsafe) can be disabled by defining macro OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor and assignment operators are defined allowing to initialize handle of base type from handle to derived type.</p>
<p>Weak pointers are not supported. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a203befbdce71112e7c1799ffdb9c7ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203befbdce71112e7c1799ffdb9c7ade">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::<a class="el" href="classopencascade_1_1handle.html#a203befbdce71112e7c1799ffdb9c7ade">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-compliant typedef of contained type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e1b9cfa6f8af03cdad0e2069bab8946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1b9cfa6f8af03cdad0e2069bab8946">&#9670;&nbsp;</a></span>handle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::<a class="el" href="classopencascade_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>

</div>
</div>
<a id="a162edab023eb68868d2cba9e82dee23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162edab023eb68868d2cba9e82dee23c">&#9670;&nbsp;</a></span>handle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::<a class="el" href="classopencascade_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>thePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from pointer to new object. </p>

</div>
</div>
<a id="acc84f11556ecb55183df5755b692fdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc84f11556ecb55183df5755b692fdbf">&#9670;&nbsp;</a></span>handle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::<a class="el" href="classopencascade_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ab5175cb900e2076b843dd2c684a53514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5175cb900e2076b843dd2c684a53514">&#9670;&nbsp;</a></span>handle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::<a class="el" href="classopencascade_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="a39cbb5d50d77b33e56244a4213b8b60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cbb5d50d77b33e56244a4213b8b60a">&#9670;&nbsp;</a></span>~handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::~<a class="el" href="classopencascade_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac49ceb02c7d589c3027cb8a5882c9b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49ceb02c7d589c3027cb8a5882c9b09">&#9670;&nbsp;</a></span>DownCast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static opencascade::std::enable_if&lt;<a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt;T2, T&gt;::value, <a class="el" href="classopencascade_1_1handle.html">handle</a>&gt;::type <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::DownCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down casting operator from handle to base type. </p>

</div>
</div>
<a id="ad6a7c4856884e81d3700d1a07f234bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a7c4856884e81d3700d1a07f234bec">&#9670;&nbsp;</a></span>DownCast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static opencascade::std::enable_if&lt;<a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt;T2, T&gt;::value, <a class="el" href="classopencascade_1_1handle.html">handle</a>&gt;::type <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::DownCast </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>thePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down casting operator from pointer to base type. </p>

</div>
</div>
<a id="a85169bdb4b26e733512e6dd1d57348ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85169bdb4b26e733512e6dd1d57348ae">&#9670;&nbsp;</a></span>DownCast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classopencascade_1_1handle.html">handle</a> <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::DownCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename opencascade::std::enable_if&lt;!<a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt; T2, T &gt;::value, void *&gt;::type&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For compatibility, define down casting operator from non-base type, as deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>("down-casting from object of the same or unrelated type is meaningless") </dd></dl>

</div>
</div>
<a id="a80a759322299d85174e142c50e6bcd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a759322299d85174e142c50e6bcd1d">&#9670;&nbsp;</a></span>DownCast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classopencascade_1_1handle.html">handle</a> <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::DownCast </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>thePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename opencascade::std::enable_if&lt;!<a class="el" href="structopencascade_1_1is__base__but__not__same.html">is_base_but_not_same</a>&lt; T2, T &gt;::value, void *&gt;::type&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For compatibility, define down casting operator from non-base type, as deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>("down-casting from object of the same or unrelated type is meaningless") </dd></dl>

</div>
</div>
<a id="a7a2e505aca4b1e2568e563c752c91e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2e505aca4b1e2568e563c752c91e52">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like cast to pointer to referred object (note non-const). </p>
<dl class="section see"><dt>See also</dt><dd>std::shared_ptr::get() </dd></dl>

</div>
</div>
<a id="a9f47b982be11db9a4f023562b1068f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f47b982be11db9a4f023562b1068f81">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for being null. </p>

</div>
</div>
<a id="a038bf0dff775f02961db6c6c60c5817b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038bf0dff775f02961db6c6c60c5817b">&#9670;&nbsp;</a></span>Nullify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::Nullify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify the handle. </p>

</div>
</div>
<a id="afbcfc44678ff1327c5d816d7d0c5bb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcfc44678ff1327c5d816d7d0c5bb3e">&#9670;&nbsp;</a></span>operator const handle< T2 > &()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upcast to const reference to base type. NB: this implementation will cause ambiguity errors on calls to overloaded functions accepting handles to different types, since compatibility is checked in the cast code rather than ensured by SFINAE (possible with C++11) </p>

</div>
</div>
<a id="a93439815d0ae587b88665fdb5abb8939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93439815d0ae587b88665fdb5abb8939">&#9670;&nbsp;</a></span>operator handle< T2 > &()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upcast to non-const reference to base type. NB: this cast can be dangerous, but required for legacy code; see #26377. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000088">Deprecated:</a></b></dt><dd>("Passing non-const reference to handle of base type in function is unsafe; use variable of exact type") </dd></dl>

</div>
</div>
<a id="a0efe1606841845889ada9a903295a400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efe1606841845889ada9a903295a400">&#9670;&nbsp;</a></span>operator Standard_Transient *handle::*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator <a class="el" href="class_standard___transient.html">Standard_Transient</a> *handle::* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion to bool-compatible type for use in conditional expressions. </p>

</div>
</div>
<a id="a71896a61e07c99f7179ea0734c4d8273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71896a61e07c99f7179ea0734c4d8273">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for inequality. </p>

</div>
</div>
<a id="a0377a39eed6a518626c576432d1dc4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0377a39eed6a518626c576432d1dc4cb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>thePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for inequality. </p>

</div>
</div>
<a id="a16b388ca2d98bc1d2ab2a9287f40abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b388ca2d98bc1d2ab2a9287f40abb4">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferencing operator (note non-const) </p>

</div>
</div>
<a id="a396719389a098e39a075ee2592495b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396719389a098e39a075ee2592495b00">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member access operator (note non-const) </p>

</div>
</div>
<a id="a55fcc22059b5e78e027ceb7fcbf3568f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fcc22059b5e78e027ceb7fcbf3568f">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare operator for possible use in std::map&lt;&gt; etc. </p>

</div>
</div>
<a id="ae5c307fd8dfb8901c329f7bde210b60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c307fd8dfb8901c329f7bde210b60e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">handle</a>&amp; <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a id="a4c08d6959078fb2a597cdb850e942588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c08d6959078fb2a597cdb850e942588">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">handle</a>&amp; <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>thePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to pointer. </p>

</div>
</div>
<a id="a7b59fab5b37b9ea212ec7df02d0d5198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b59fab5b37b9ea212ec7df02d0d5198">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopencascade_1_1handle.html">handle</a>&amp; <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move operator. </p>

</div>
</div>
<a id="a91bb04e6362253bb3788eb270bf57920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bb04e6362253bb3788eb270bf57920">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theHandle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for equality. </p>

</div>
</div>
<a id="a7cdc060b33a893077f1b035706e53b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdc060b33a893077f1b035706e53b26">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>thePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for equality. </p>

</div>
</div>
<a id="a6a65c26e6e049ba1538c0c58ac59b070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a65c26e6e049ba1538c0c58ac59b070">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>thePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset by new pointer. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a788eb394fa7891ed0d955757397e2002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788eb394fa7891ed0d955757397e2002">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for inequality. </p>

</div>
</div>
<a id="a1ce2fae814ab9e14e900c87e69d14d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce2fae814ab9e14e900c87e69d14d27">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopencascade_1_1handle.html">handle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for equality. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_standard___handle_8hxx.html">Standard_Handle.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
