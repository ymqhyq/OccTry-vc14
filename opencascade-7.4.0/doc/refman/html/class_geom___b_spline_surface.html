<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Geom_BSplineSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Open CASCADE Technology</a></li><li class="navelem"><a class="el" href="module_modelingdata.html">Module ModelingData</a></li><li class="navelem"><a class="el" href="toolkit_tkg3d.html">Toolkit TKG3d</a></li>    <li class="navelem"><a class="el" href="package_geom.html">Package Geom </a>      </li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Geom_BSplineSurface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes a BSpline surface. In each parametric direction, a BSpline surface can be:  
 <a href="class_geom___b_spline_surface.html#details">More...</a></p>

<p><code>#include &lt;Geom_BSplineSurface.hxx&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Geom_BSplineSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_geom___b_spline_surface__inherit__graph.png" border="0" usemap="#_geom___b_spline_surface_inherit__map" alt="Inheritance graph"/></div>
<map name="_geom___b_spline_surface_inherit__map" id="_geom___b_spline_surface_inherit__map">
<area shape="rect" id="node2" href="class_geom___bounded_surface.html" title="The root class for bounded surfaces in 3D space. A bounded surface is defined by a rectangle in its 2..." alt="" coords="5,229,164,256"/>
<area shape="rect" id="node3" href="class_geom___surface.html" title="Describes the common behavior of surfaces in 3D space. The Geom package provides many implementations..." alt="" coords="31,155,139,181"/>
<area shape="rect" id="node4" href="class_geom___geometry.html" title="The abstract class Geometry for 3D space is the root class of all geometric objects from the Geom pac..." alt="" coords="24,80,145,107"/>
<area shape="rect" id="node5" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. " alt="" coords="17,5,152,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cceaf7bab6ce3a234166ebbd9671f6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2cceaf7bab6ce3a234166ebbd9671f6e">Geom_BSplineSurface</a> (const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#acca9beddb794fad2a9183473dfcb6b55">Poles</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a797314c1a4f7bdccdedb8a90e494f68e">UKnots</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#abc42618b81f3c6a64d14782b8d813044">VKnots</a>, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;UMults, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;VMults, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#af450e43303facf90afbeb7adafc1da50">UDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#a14183eb2a06b72c428047199bbb0d30b">VDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> UPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> VPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>)</td></tr>
<tr class="memdesc:a2cceaf7bab6ce3a234166ebbd9671f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-rational b-spline surface (weights default value is 1.). The following conditions must be verified. 0 &lt; UDegree &lt;= MaxDegree. UKnots.Length() == UMults.Length() &gt;= 2 UKnots(i) &lt; UKnots(i+1) (Knots are increasing) 1 &lt;= UMults(i) &lt;= UDegree On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). On a uperiodic surface the first and the last umultiplicities must be the same. on non-uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 &gt;= 2 on uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) except the first or last The previous conditions for U holds also for V, with the RowLength of the poles.  <a href="#a2cceaf7bab6ce3a234166ebbd9671f6e">More...</a><br /></td></tr>
<tr class="separator:a2cceaf7bab6ce3a234166ebbd9671f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccceccdf053e7164b6a6ac38251b709"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4ccceccdf053e7164b6a6ac38251b709">Geom_BSplineSurface</a> (const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#acca9beddb794fad2a9183473dfcb6b55">Poles</a>, const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#ab3432cbee6dc104640b28a3db917f868">Weights</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a797314c1a4f7bdccdedb8a90e494f68e">UKnots</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#abc42618b81f3c6a64d14782b8d813044">VKnots</a>, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;UMults, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;VMults, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#af450e43303facf90afbeb7adafc1da50">UDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#a14183eb2a06b72c428047199bbb0d30b">VDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> UPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> VPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>)</td></tr>
<tr class="memdesc:a4ccceccdf053e7164b6a6ac38251b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-rational b-spline surface (weights default value is 1.).  <a href="#a4ccceccdf053e7164b6a6ac38251b709">More...</a><br /></td></tr>
<tr class="separator:a4ccceccdf053e7164b6a6ac38251b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa7cb8c9a667e9afa729fa388b0f6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aafa7cb8c9a667e9afa729fa388b0f6c6">ExchangeUV</a> ()</td></tr>
<tr class="memdesc:aafa7cb8c9a667e9afa729fa388b0f6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the u and v parametric directions on this BSpline surface. As a consequence:  <a href="#aafa7cb8c9a667e9afa729fa388b0f6c6">More...</a><br /></td></tr>
<tr class="separator:aafa7cb8c9a667e9afa729fa388b0f6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b39ea036cefa180705348855e68e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa0b39ea036cefa180705348855e68e78">SetUPeriodic</a> ()</td></tr>
<tr class="memdesc:aa0b39ea036cefa180705348855e68e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface U periodic. Modifies this surface to be periodic in the U parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction.  <a href="#aa0b39ea036cefa180705348855e68e78">More...</a><br /></td></tr>
<tr class="separator:aa0b39ea036cefa180705348855e68e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1376ba80d7503a1519c35ee8fadfa2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1376ba80d7503a1519c35ee8fadfa2c2">SetVPeriodic</a> ()</td></tr>
<tr class="memdesc:a1376ba80d7503a1519c35ee8fadfa2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface V periodic. Modifies this surface to be periodic in the V parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstVKnotIndex and LastVKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction.  <a href="#a1376ba80d7503a1519c35ee8fadfa2c2">More...</a><br /></td></tr>
<tr class="separator:a1376ba80d7503a1519c35ee8fadfa2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4358e949b42ba536d9f5011df35037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4c4358e949b42ba536d9f5011df35037">PeriodicNormalization</a> (<a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V) const</td></tr>
<tr class="memdesc:a4c4358e949b42ba536d9f5011df35037"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the parameter normalized within the period if the surface is periodic : otherwise does not do anything  <a href="#a4c4358e949b42ba536d9f5011df35037">More...</a><br /></td></tr>
<tr class="separator:a4c4358e949b42ba536d9f5011df35037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb456214cd15f2d60c1937fcd67bb967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#adb456214cd15f2d60c1937fcd67bb967">SetUOrigin</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index)</td></tr>
<tr class="memdesc:adb456214cd15f2d60c1937fcd67bb967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction.  <a href="#adb456214cd15f2d60c1937fcd67bb967">More...</a><br /></td></tr>
<tr class="separator:adb456214cd15f2d60c1937fcd67bb967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ff76aa0fb4ea90203db02da110fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ade5ff76aa0fb4ea90203db02da110fc2">SetVOrigin</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index)</td></tr>
<tr class="memdesc:ade5ff76aa0fb4ea90203db02da110fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction.  <a href="#ade5ff76aa0fb4ea90203db02da110fc2">More...</a><br /></td></tr>
<tr class="separator:ade5ff76aa0fb4ea90203db02da110fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ee06d28faf0e7992b4745ff6afbb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac90ee06d28faf0e7992b4745ff6afbb0">SetUNotPeriodic</a> ()</td></tr>
<tr class="memdesc:ac90ee06d28faf0e7992b4745ff6afbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface U not periodic. Changes this BSpline surface into a non-periodic surface along U direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified.  <a href="#ac90ee06d28faf0e7992b4745ff6afbb0">More...</a><br /></td></tr>
<tr class="separator:ac90ee06d28faf0e7992b4745ff6afbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af335087f0d79b4fbaf141b50f6e46f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#af335087f0d79b4fbaf141b50f6e46f2b">SetVNotPeriodic</a> ()</td></tr>
<tr class="memdesc:af335087f0d79b4fbaf141b50f6e46f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface V not periodic. Changes this BSpline surface into a non-periodic surface along V direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified.  <a href="#af335087f0d79b4fbaf141b50f6e46f2b">More...</a><br /></td></tr>
<tr class="separator:af335087f0d79b4fbaf141b50f6e46f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0fcef877230439568db763810a1a28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aee0fcef877230439568db763810a1a28">UReverse</a> () override</td></tr>
<tr class="memdesc:aee0fcef877230439568db763810a1a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the orientation of this BSpline surface in the U parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified.  <a href="#aee0fcef877230439568db763810a1a28">More...</a><br /></td></tr>
<tr class="separator:aee0fcef877230439568db763810a1a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba4946263dde87c57e9aa6329625767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aeba4946263dde87c57e9aa6329625767">VReverse</a> () override</td></tr>
<tr class="memdesc:aeba4946263dde87c57e9aa6329625767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the orientation of this BSpline surface in the V parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified.  <a href="#aeba4946263dde87c57e9aa6329625767">More...</a><br /></td></tr>
<tr class="separator:aeba4946263dde87c57e9aa6329625767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27422832e7a67f53e85ecba1ae4fe36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac27422832e7a67f53e85ecba1ae4fe36">UReversedParameter</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U) const override</td></tr>
<tr class="memdesc:ac27422832e7a67f53e85ecba1ae4fe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the u parameter on the modified surface, produced by reversing its U parametric direction, for the point of u parameter U, on this BSpline surface. For a BSpline surface, these functions return respectively:  <a href="#ac27422832e7a67f53e85ecba1ae4fe36">More...</a><br /></td></tr>
<tr class="separator:ac27422832e7a67f53e85ecba1ae4fe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abf1cd08b7428661d747f54461c47e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a5abf1cd08b7428661d747f54461c47e5">VReversedParameter</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V) const override</td></tr>
<tr class="memdesc:a5abf1cd08b7428661d747f54461c47e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the v parameter on the modified surface, produced by reversing its V parametric direction, for the point of v parameter V on this BSpline surface. For a BSpline surface, these functions return respectively:  <a href="#a5abf1cd08b7428661d747f54461c47e5">More...</a><br /></td></tr>
<tr class="separator:a5abf1cd08b7428661d747f54461c47e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1518b83991ee2eea82617ffcb61b6125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1518b83991ee2eea82617ffcb61b6125">IncreaseDegree</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#af450e43303facf90afbeb7adafc1da50">UDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#a14183eb2a06b72c428047199bbb0d30b">VDegree</a>)</td></tr>
<tr class="memdesc:a1518b83991ee2eea82617ffcb61b6125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the degrees of this BSpline surface to UDegree and VDegree in the u and v parametric directions respectively. As a result, the tables of poles, weights and multiplicities are modified. The tables of knots is not changed. Note: Nothing is done if the given degree is less than or equal to the current degree in the corresponding parametric direction. Exceptions Standard_ConstructionError if UDegree or VDegree is greater than <a class="el" href="class_geom___b_spline_surface.html#ac1496de7ea0d7268ee94ba738c61dd0e" title="Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v dir...">Geom_BSplineSurface::MaxDegree()</a>.  <a href="#a1518b83991ee2eea82617ffcb61b6125">More...</a><br /></td></tr>
<tr class="separator:a1518b83991ee2eea82617ffcb61b6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eabcf868d4a08c60eeac5913b96095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a99eabcf868d4a08c60eeac5913b96095">InsertUKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Knots, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mults, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance=0.0, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:a99eabcf868d4a08c60eeac5913b96095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts into the knots table for the U parametric direction of this BSpline surface:  <a href="#a99eabcf868d4a08c60eeac5913b96095">More...</a><br /></td></tr>
<tr class="separator:a99eabcf868d4a08c60eeac5913b96095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cec108eb6a0e03fc0548be17fd0692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab0cec108eb6a0e03fc0548be17fd0692">InsertVKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Knots, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mults, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance=0.0, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:ab0cec108eb6a0e03fc0548be17fd0692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts into the knots table for the V parametric direction of this BSpline surface:  <a href="#ab0cec108eb6a0e03fc0548be17fd0692">More...</a><br /></td></tr>
<tr class="separator:ab0cec108eb6a0e03fc0548be17fd0692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392ae7d2d902abef64aa61e4a04d0b63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a392ae7d2d902abef64aa61e4a04d0b63">RemoveUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Tolerance)</td></tr>
<tr class="memdesc:a392ae7d2d902abef64aa61e4a04d0b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces to M the multiplicity of the knot of index Index in the U parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface.  <a href="#a392ae7d2d902abef64aa61e4a04d0b63">More...</a><br /></td></tr>
<tr class="separator:a392ae7d2d902abef64aa61e4a04d0b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2001d928b071ceb0b5847ea56e74c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abba2001d928b071ceb0b5847ea56e74c">RemoveVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Tolerance)</td></tr>
<tr class="memdesc:abba2001d928b071ceb0b5847ea56e74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces to M the multiplicity of the knot of index Index in the V parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface.  <a href="#abba2001d928b071ceb0b5847ea56e74c">More...</a><br /></td></tr>
<tr class="separator:abba2001d928b071ceb0b5847ea56e74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f7df653df09054582143a163655682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a89f7df653df09054582143a163655682">IncreaseUMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a89f7df653df09054582143a163655682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the multiplicity of the knot of range UIndex in the UKnots sequence. M is the new multiplicity. M must be greater than the previous multiplicity and lower or equal to the degree of the surface in the U parametric direction. Raised if M is not in the range [1, UDegree].  <a href="#a89f7df653df09054582143a163655682">More...</a><br /></td></tr>
<tr class="separator:a89f7df653df09054582143a163655682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1bace85d54741492dfbeb8620d87b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2e1bace85d54741492dfbeb8620d87b3">IncreaseUMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a2e1bace85d54741492dfbeb8620d87b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the U direction. This method can be used to make a B_spline surface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non uniform.  <a href="#a2e1bace85d54741492dfbeb8620d87b3">More...</a><br /></td></tr>
<tr class="separator:a2e1bace85d54741492dfbeb8620d87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53653996a730f05b0d43429646555f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a53653996a730f05b0d43429646555f71">IncrementUMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Step)</td></tr>
<tr class="memdesc:a53653996a730f05b0d43429646555f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the multiplicity of the consecutives uknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the UDegree of the B_spline.  <a href="#a53653996a730f05b0d43429646555f71">More...</a><br /></td></tr>
<tr class="separator:a53653996a730f05b0d43429646555f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0038875c69a1f5d9cea7a1658b50960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac0038875c69a1f5d9cea7a1658b50960">IncreaseVMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:ac0038875c69a1f5d9cea7a1658b50960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the multiplicity of a knot in the V direction. M is the new multiplicity.  <a href="#ac0038875c69a1f5d9cea7a1658b50960">More...</a><br /></td></tr>
<tr class="separator:ac0038875c69a1f5d9cea7a1658b50960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265fe70c543a2126a9a6a8e9e0f599c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a265fe70c543a2126a9a6a8e9e0f599c4">IncreaseVMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a265fe70c543a2126a9a6a8e9e0f599c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the V direction. This method can be used to make a BSplineSurface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non-uniform.  <a href="#a265fe70c543a2126a9a6a8e9e0f599c4">More...</a><br /></td></tr>
<tr class="separator:a265fe70c543a2126a9a6a8e9e0f599c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90604191893bb2dc3bca30b3447aa8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a90604191893bb2dc3bca30b3447aa8bb">IncrementVMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Step)</td></tr>
<tr class="memdesc:a90604191893bb2dc3bca30b3447aa8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the multiplicity of the consecutives vknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the VDegree of the B_spline.  <a href="#a90604191893bb2dc3bca30b3447aa8bb">More...</a><br /></td></tr>
<tr class="separator:a90604191893bb2dc3bca30b3447aa8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b07416d5e8d9a87f447e41cb477fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abd4b07416d5e8d9a87f447e41cb477fb">InsertUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:abd4b07416d5e8d9a87f447e41cb477fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a knot value in the sequence of UKnots. If U is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M else it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp.  <a href="#abd4b07416d5e8d9a87f447e41cb477fb">More...</a><br /></td></tr>
<tr class="separator:abd4b07416d5e8d9a87f447e41cb477fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1695d16dec722f5ee1cef55b980e95a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1695d16dec722f5ee1cef55b980e95a1">InsertVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:a1695d16dec722f5ee1cef55b980e95a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a knot value in the sequence of VKnots. If V is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M otherwise it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp.  <a href="#a1695d16dec722f5ee1cef55b980e95a1">More...</a><br /></td></tr>
<tr class="separator:a1695d16dec722f5ee1cef55b980e95a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d182b275cba4fd24058caea4f9c6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a25d182b275cba4fd24058caea4f9c6f9">Segment</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theUTolerance=<a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>(), const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theVTolerance=<a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>())</td></tr>
<tr class="memdesc:a25d182b275cba4fd24058caea4f9c6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same.  <a href="#a25d182b275cba4fd24058caea4f9c6f9">More...</a><br /></td></tr>
<tr class="separator:a25d182b275cba4fd24058caea4f9c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b60068f4332301ac697ebaf85663aae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0b60068f4332301ac697ebaf85663aae">CheckAndSegment</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theUTolerance=<a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>(), const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theVTolerance=<a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>())</td></tr>
<tr class="memdesc:a0b60068f4332301ac697ebaf85663aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction.  <a href="#a0b60068f4332301ac697ebaf85663aae">More...</a><br /></td></tr>
<tr class="separator:a0b60068f4332301ac697ebaf85663aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad798e54698ffb43903d5716ae0cee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abad798e54698ffb43903d5716ae0cee6">SetUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K)</td></tr>
<tr class="memdesc:abad798e54698ffb43903d5716ae0cee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the UKnots of range UIndex with K.  <a href="#abad798e54698ffb43903d5716ae0cee6">More...</a><br /></td></tr>
<tr class="separator:abad798e54698ffb43903d5716ae0cee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e744c1a00c58eed3f992caba7d1668a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7e744c1a00c58eed3f992caba7d1668a">SetUKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;UK)</td></tr>
<tr class="memdesc:a7e744c1a00c58eed3f992caba7d1668a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all the U-knots of the surface. The multiplicity of the knots are not modified.  <a href="#a7e744c1a00c58eed3f992caba7d1668a">More...</a><br /></td></tr>
<tr class="separator:a7e744c1a00c58eed3f992caba7d1668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739cf8b82973158284e38f9ab75fdfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a739cf8b82973158284e38f9ab75fdfce">SetUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a739cf8b82973158284e38f9ab75fdfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of the UKnots of range UIndex and increases its multiplicity.  <a href="#a739cf8b82973158284e38f9ab75fdfce">More...</a><br /></td></tr>
<tr class="separator:a739cf8b82973158284e38f9ab75fdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5f7237bcab9e4186b958668f951913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#afe5f7237bcab9e4186b958668f951913">SetVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K)</td></tr>
<tr class="memdesc:afe5f7237bcab9e4186b958668f951913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the VKnots of range VIndex with K.  <a href="#afe5f7237bcab9e4186b958668f951913">More...</a><br /></td></tr>
<tr class="separator:afe5f7237bcab9e4186b958668f951913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e3a15de8c8c282b6e264122a829e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a84e3a15de8c8c282b6e264122a829e0c">SetVKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;VK)</td></tr>
<tr class="memdesc:a84e3a15de8c8c282b6e264122a829e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all the V-knots of the surface. The multiplicity of the knots are not modified.  <a href="#a84e3a15de8c8c282b6e264122a829e0c">More...</a><br /></td></tr>
<tr class="separator:a84e3a15de8c8c282b6e264122a829e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e4111066ef4b2a33a62d345934a1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a54e4111066ef4b2a33a62d345934a1ea">SetVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a54e4111066ef4b2a33a62d345934a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of the VKnots of range VIndex and increases its multiplicity.  <a href="#a54e4111066ef4b2a33a62d345934a1ea">More...</a><br /></td></tr>
<tr class="separator:a54e4111066ef4b2a33a62d345934a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bd815cbc497fc6a76c788c96950454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a84bd815cbc497fc6a76c788c96950454">LocateU</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I1, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I2, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> WithKnotRepetition=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>) const</td></tr>
<tr class="memdesc:a84bd815cbc497fc6a76c788c96950454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the parametric value U in the sequence of UKnots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. UKnots (I1) &lt;= U &lt;= UKnots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; U &lt; UKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbUKnots =&gt; U &gt; UKnots(NbUKnots)+Abs(ParametricTolerance)  <a href="#a84bd815cbc497fc6a76c788c96950454">More...</a><br /></td></tr>
<tr class="separator:a84bd815cbc497fc6a76c788c96950454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236061bafa89740d15aa2c76eac73b07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a236061bafa89740d15aa2c76eac73b07">LocateV</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I1, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I2, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> WithKnotRepetition=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>) const</td></tr>
<tr class="memdesc:a236061bafa89740d15aa2c76eac73b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the parametric value V in the sequence of knots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. VKnots (I1) &lt;= V &lt;= VKnots (I2) . if I1 = I2 V is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; V &lt; VKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbVKnots =&gt; V &gt; VKnots(NbVKnots)+Abs(ParametricTolerance) poles insertion and removing The following methods are available only if the surface is Uniform or QuasiUniform in the considered direction The knot repartition is modified.  <a href="#a236061bafa89740d15aa2c76eac73b07">More...</a><br /></td></tr>
<tr class="separator:a236061bafa89740d15aa2c76eac73b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d65634d8c16cf435ca655cba8a7c50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a25d65634d8c16cf435ca655cba8a7c50">SetPole</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P)</td></tr>
<tr class="memdesc:a25d65634d8c16cf435ca655cba8a7c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the pole of range (UIndex, VIndex) with P. If the surface is rational the weight of range (UIndex, VIndex) is not modified.  <a href="#a25d65634d8c16cf435ca655cba8a7c50">More...</a><br /></td></tr>
<tr class="separator:a25d65634d8c16cf435ca655cba8a7c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15b262382cf0993d3f68e006a2475c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4f15b262382cf0993d3f68e006a2475c">SetPole</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="el" href="class_geom___b_spline_surface.html#a92ddca375feffee360d3f180cdbf38a1">Weight</a>)</td></tr>
<tr class="memdesc:a4f15b262382cf0993d3f68e006a2475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the pole and the weight of range (UIndex, VIndex) with P and W.  <a href="#a4f15b262382cf0993d3f68e006a2475c">More...</a><br /></td></tr>
<tr class="separator:a4f15b262382cf0993d3f68e006a2475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf9582ad0b35728f241da3a05240501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aacf9582ad0b35728f241da3a05240501">SetPoleCol</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles)</td></tr>
<tr class="memdesc:aacf9582ad0b35728f241da3a05240501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a column of poles or a part of this column. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles.  <a href="#aacf9582ad0b35728f241da3a05240501">More...</a><br /></td></tr>
<tr class="separator:aacf9582ad0b35728f241da3a05240501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f72b47dc1ef861bc0d8181dfcfa3295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4f72b47dc1ef861bc0d8181dfcfa3295">SetPoleCol</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a4f72b47dc1ef861bc0d8181dfcfa3295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a column of poles or a part of this column with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles.  <a href="#a4f72b47dc1ef861bc0d8181dfcfa3295">More...</a><br /></td></tr>
<tr class="separator:a4f72b47dc1ef861bc0d8181dfcfa3295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f66596b553b9f191350b8e4d700323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a93f66596b553b9f191350b8e4d700323">SetPoleRow</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a93f66596b553b9f191350b8e4d700323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a row of poles or a part of this row with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles.  <a href="#a93f66596b553b9f191350b8e4d700323">More...</a><br /></td></tr>
<tr class="separator:a93f66596b553b9f191350b8e4d700323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1784d238248031bb52c51bdd46a5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aff1784d238248031bb52c51bdd46a5cf">SetPoleRow</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles)</td></tr>
<tr class="memdesc:aff1784d238248031bb52c51bdd46a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a row of poles or a part of this row. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles.  <a href="#aff1784d238248031bb52c51bdd46a5cf">More...</a><br /></td></tr>
<tr class="separator:aff1784d238248031bb52c51bdd46a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387528d50fb7fe2abeef279e7a8aae86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a387528d50fb7fe2abeef279e7a8aae86">SetWeight</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="el" href="class_geom___b_spline_surface.html#a92ddca375feffee360d3f180cdbf38a1">Weight</a>)</td></tr>
<tr class="memdesc:a387528d50fb7fe2abeef279e7a8aae86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the weight of the pole of range UIndex, VIndex. If the surface was non rational it can become rational. If the surface was rational it can become non rational.  <a href="#a387528d50fb7fe2abeef279e7a8aae86">More...</a><br /></td></tr>
<tr class="separator:a387528d50fb7fe2abeef279e7a8aae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921397a82aed03feae72dd0f73dc823e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a921397a82aed03feae72dd0f73dc823e">SetWeightCol</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a921397a82aed03feae72dd0f73dc823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a column of weights of a part of this column.  <a href="#a921397a82aed03feae72dd0f73dc823e">More...</a><br /></td></tr>
<tr class="separator:a921397a82aed03feae72dd0f73dc823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e2900caa95bf15c02124b1d4f115b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1d9e2900caa95bf15c02124b1d4f115b">SetWeightRow</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a1d9e2900caa95bf15c02124b1d4f115b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a row of weights or a part of this row.  <a href="#a1d9e2900caa95bf15c02124b1d4f115b">More...</a><br /></td></tr>
<tr class="separator:a1d9e2900caa95bf15c02124b1d4f115b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914512eca1f25878577aee7499a2583b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a914512eca1f25878577aee7499a2583b">MovePoint</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex2, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;UFirstIndex, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;ULastIndex, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;VFirstIndex, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;VLastIndex)</td></tr>
<tr class="memdesc:a914512eca1f25878577aee7499a2583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a point with parameter U and V to P. given u,v as parameters) to reach a new position UIndex1, UIndex2, VIndex1, VIndex2: indicates the poles which can be moved if Problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0.  <a href="#a914512eca1f25878577aee7499a2583b">More...</a><br /></td></tr>
<tr class="separator:a914512eca1f25878577aee7499a2583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cc2ecc094017a734d43a203356d655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa6cc2ecc094017a734d43a203356d655">IsUClosed</a> () const override</td></tr>
<tr class="memdesc:aa6cc2ecc094017a734d43a203356d655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first control points row and the last control points row are identical. The tolerance criterion is Resolution from package gp.  <a href="#aa6cc2ecc094017a734d43a203356d655">More...</a><br /></td></tr>
<tr class="separator:aa6cc2ecc094017a734d43a203356d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784954ca35462143b660ac80a703b13e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a784954ca35462143b660ac80a703b13e">IsVClosed</a> () const override</td></tr>
<tr class="memdesc:a784954ca35462143b660ac80a703b13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first control points column and the last last control points column are identical. The tolerance criterion is Resolution from package gp.  <a href="#a784954ca35462143b660ac80a703b13e">More...</a><br /></td></tr>
<tr class="separator:a784954ca35462143b660ac80a703b13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b2bb688eb5c9db39cf72856f461b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a844b2bb688eb5c9db39cf72856f461b9">IsCNu</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> N) const override</td></tr>
<tr class="memdesc:a844b2bb688eb5c9db39cf72856f461b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the order of continuity of the surface in the U direction is N. Raised if N &lt; 0.  <a href="#a844b2bb688eb5c9db39cf72856f461b9">More...</a><br /></td></tr>
<tr class="separator:a844b2bb688eb5c9db39cf72856f461b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954d178310ce1b8db20287db9844aacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a954d178310ce1b8db20287db9844aacf">IsCNv</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> N) const override</td></tr>
<tr class="memdesc:a954d178310ce1b8db20287db9844aacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the order of continuity of the surface in the V direction is N. Raised if N &lt; 0.  <a href="#a954d178310ce1b8db20287db9844aacf">More...</a><br /></td></tr>
<tr class="separator:a954d178310ce1b8db20287db9844aacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a47c005dd3b371c091b905165dc5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a92a47c005dd3b371c091b905165dc5e3">IsUPeriodic</a> () const override</td></tr>
<tr class="memdesc:a92a47c005dd3b371c091b905165dc5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the surface is closed in the U direction and if the B-spline has been turned into a periodic surface using the function SetUPeriodic.  <a href="#a92a47c005dd3b371c091b905165dc5e3">More...</a><br /></td></tr>
<tr class="separator:a92a47c005dd3b371c091b905165dc5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ddaa964dfe4bea26fde59271ce3e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a22ddaa964dfe4bea26fde59271ce3e75">IsURational</a> () const</td></tr>
<tr class="memdesc:a22ddaa964dfe4bea26fde59271ce3e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns False if for each row of weights all the weights are identical. The tolerance criterion is resolution from package gp. Example : |1.0, 1.0, 1.0| if Weights = |0.5, 0.5, 0.5| returns False |2.0, 2.0, 2.0|.  <a href="#a22ddaa964dfe4bea26fde59271ce3e75">More...</a><br /></td></tr>
<tr class="separator:a22ddaa964dfe4bea26fde59271ce3e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4dda9bd4ca1139f372489b95ddc0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aaa4dda9bd4ca1139f372489b95ddc0cb">IsVPeriodic</a> () const override</td></tr>
<tr class="memdesc:aaa4dda9bd4ca1139f372489b95ddc0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the surface is closed in the V direction and if the B-spline has been turned into a periodic surface using the function SetVPeriodic.  <a href="#aaa4dda9bd4ca1139f372489b95ddc0cb">More...</a><br /></td></tr>
<tr class="separator:aaa4dda9bd4ca1139f372489b95ddc0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3676c7e01eb23c66f419769f03e1541c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a3676c7e01eb23c66f419769f03e1541c">IsVRational</a> () const</td></tr>
<tr class="memdesc:a3676c7e01eb23c66f419769f03e1541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns False if for each column of weights all the weights are identical. The tolerance criterion is resolution from package gp. Examples : |1.0, 2.0, 0.5| if Weights = |1.0, 2.0, 0.5| returns False |1.0, 2.0, 0.5|.  <a href="#a3676c7e01eb23c66f419769f03e1541c">More...</a><br /></td></tr>
<tr class="separator:a3676c7e01eb23c66f419769f03e1541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8e46390a662f9bf47773b0d193f469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1b8e46390a662f9bf47773b0d193f469">Bounds</a> (<a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U1, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U2, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V1, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V2) const override</td></tr>
<tr class="memdesc:a1b8e46390a662f9bf47773b0d193f469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parametric bounds of the surface. Warnings : These parametric values are the bounds of the array of knots UKnots and VKnots only if the first knots and the last knots have a multiplicity equal to UDegree + 1 or VDegree + 1.  <a href="#a1b8e46390a662f9bf47773b0d193f469">More...</a><br /></td></tr>
<tr class="separator:a1b8e46390a662f9bf47773b0d193f469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7893d9e0176410681dee0e305444d2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_geom_abs___shape_8hxx.html#a943632453b69386bece6c091156b1ed5">GeomAbs_Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa7893d9e0176410681dee0e305444d2f">Continuity</a> () const override</td></tr>
<tr class="memdesc:aa7893d9e0176410681dee0e305444d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the continuity of the surface : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Surface, C2 : continuity of the second derivative all along the Surface, C3 : continuity of the third derivative all along the Surface, CN : the order of continuity is infinite. A B-spline surface is infinitely continuously differentiable for the couple of parameters U, V such thats U != UKnots(i) and V != VKnots(i). The continuity of the surface at a knot value depends on the multiplicity of this knot. Example : If the surface is C1 in the V direction and C2 in the U direction this function returns Shape = C1.  <a href="#aa7893d9e0176410681dee0e305444d2f">More...</a><br /></td></tr>
<tr class="separator:aa7893d9e0176410681dee0e305444d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeffb1ea838e6044afc58c3120b5790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1aeffb1ea838e6044afc58c3120b5790">FirstUKnotIndex</a> () const</td></tr>
<tr class="memdesc:a1aeffb1ea838e6044afc58c3120b5790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the UKnots which gives the first parametric value of the surface in the U direction. The UIso curve corresponding to this value is a boundary curve of the surface.  <a href="#a1aeffb1ea838e6044afc58c3120b5790">More...</a><br /></td></tr>
<tr class="separator:a1aeffb1ea838e6044afc58c3120b5790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fa6a5fa15d98e768a8ecd11dd4dfe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ae4fa6a5fa15d98e768a8ecd11dd4dfe8">FirstVKnotIndex</a> () const</td></tr>
<tr class="memdesc:ae4fa6a5fa15d98e768a8ecd11dd4dfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the VKnots which gives the first parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface.  <a href="#ae4fa6a5fa15d98e768a8ecd11dd4dfe8">More...</a><br /></td></tr>
<tr class="separator:ae4fa6a5fa15d98e768a8ecd11dd4dfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a38bbb34e4e22552ef951c2588083e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8a38bbb34e4e22552ef951c2588083e3">LastUKnotIndex</a> () const</td></tr>
<tr class="memdesc:a8a38bbb34e4e22552ef951c2588083e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the UKnots which gives the last parametric value of the surface in the U direction. The UIso curve corresponding to this knot is a boundary curve of the surface.  <a href="#a8a38bbb34e4e22552ef951c2588083e3">More...</a><br /></td></tr>
<tr class="separator:a8a38bbb34e4e22552ef951c2588083e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03285118bbcc29ba75e3f017bf2dab12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a03285118bbcc29ba75e3f017bf2dab12">LastVKnotIndex</a> () const</td></tr>
<tr class="memdesc:a03285118bbcc29ba75e3f017bf2dab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the VKnots which gives the last parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface.  <a href="#a03285118bbcc29ba75e3f017bf2dab12">More...</a><br /></td></tr>
<tr class="separator:a03285118bbcc29ba75e3f017bf2dab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9f2b3403c270690df304de2e5488b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aeb9f2b3403c270690df304de2e5488b2">NbUKnots</a> () const</td></tr>
<tr class="memdesc:aeb9f2b3403c270690df304de2e5488b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of knots in the U direction.  <a href="#aeb9f2b3403c270690df304de2e5488b2">More...</a><br /></td></tr>
<tr class="separator:aeb9f2b3403c270690df304de2e5488b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62407b2e3da408f98963d4431a4dd5b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a62407b2e3da408f98963d4431a4dd5b2">NbUPoles</a> () const</td></tr>
<tr class="memdesc:a62407b2e3da408f98963d4431a4dd5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of poles in the U direction.  <a href="#a62407b2e3da408f98963d4431a4dd5b2">More...</a><br /></td></tr>
<tr class="separator:a62407b2e3da408f98963d4431a4dd5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f695247eecd1be92f0100c881329a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a93f695247eecd1be92f0100c881329a1">NbVKnots</a> () const</td></tr>
<tr class="memdesc:a93f695247eecd1be92f0100c881329a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of knots in the V direction.  <a href="#a93f695247eecd1be92f0100c881329a1">More...</a><br /></td></tr>
<tr class="separator:a93f695247eecd1be92f0100c881329a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4124728ffd7e288f05efccd3023f1f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4124728ffd7e288f05efccd3023f1f89">NbVPoles</a> () const</td></tr>
<tr class="memdesc:a4124728ffd7e288f05efccd3023f1f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of poles in the V direction.  <a href="#a4124728ffd7e288f05efccd3023f1f89">More...</a><br /></td></tr>
<tr class="separator:a4124728ffd7e288f05efccd3023f1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd7da6d45b7f158a453c9f4d9c7abea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7bd7da6d45b7f158a453c9f4d9c7abea">Pole</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const</td></tr>
<tr class="memdesc:a7bd7da6d45b7f158a453c9f4d9c7abea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pole of range (UIndex, VIndex).  <a href="#a7bd7da6d45b7f158a453c9f4d9c7abea">More...</a><br /></td></tr>
<tr class="separator:a7bd7da6d45b7f158a453c9f4d9c7abea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca9beddb794fad2a9183473dfcb6b55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#acca9beddb794fad2a9183473dfcb6b55">Poles</a> (<a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;P) const</td></tr>
<tr class="memdesc:acca9beddb794fad2a9183473dfcb6b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the poles of the B-spline surface.  <a href="#acca9beddb794fad2a9183473dfcb6b55">More...</a><br /></td></tr>
<tr class="separator:acca9beddb794fad2a9183473dfcb6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01062bdfde3c59ecc0682e6f1c2432ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a01062bdfde3c59ecc0682e6f1c2432ac">Poles</a> () const</td></tr>
<tr class="memdesc:a01062bdfde3c59ecc0682e6f1c2432ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the poles of the B-spline surface.  <a href="#a01062bdfde3c59ecc0682e6f1c2432ac">More...</a><br /></td></tr>
<tr class="separator:a01062bdfde3c59ecc0682e6f1c2432ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af450e43303facf90afbeb7adafc1da50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#af450e43303facf90afbeb7adafc1da50">UDegree</a> () const</td></tr>
<tr class="memdesc:af450e43303facf90afbeb7adafc1da50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of the normalized B-splines Ni,n in the U direction.  <a href="#af450e43303facf90afbeb7adafc1da50">More...</a><br /></td></tr>
<tr class="separator:af450e43303facf90afbeb7adafc1da50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb476a0f1935c574be3d11bc3cf7b886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#acb476a0f1935c574be3d11bc3cf7b886">UKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex) const</td></tr>
<tr class="memdesc:acb476a0f1935c574be3d11bc3cf7b886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Knot value of range UIndex. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots.  <a href="#acb476a0f1935c574be3d11bc3cf7b886">More...</a><br /></td></tr>
<tr class="separator:acb476a0f1935c574be3d11bc3cf7b886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110d56a72f988aaeae3f26c01cd54bbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a110d56a72f988aaeae3f26c01cd54bbd">UKnotDistribution</a> () const</td></tr>
<tr class="memdesc:a110d56a72f988aaeae3f26c01cd54bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the U direction the B-spline surface can be :  <a href="#a110d56a72f988aaeae3f26c01cd54bbd">More...</a><br /></td></tr>
<tr class="separator:a110d56a72f988aaeae3f26c01cd54bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797314c1a4f7bdccdedb8a90e494f68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a797314c1a4f7bdccdedb8a90e494f68e">UKnots</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Ku) const</td></tr>
<tr class="memdesc:a797314c1a4f7bdccdedb8a90e494f68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the U direction.  <a href="#a797314c1a4f7bdccdedb8a90e494f68e">More...</a><br /></td></tr>
<tr class="separator:a797314c1a4f7bdccdedb8a90e494f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a82908fd062a50c03830b65226ff65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a51a82908fd062a50c03830b65226ff65">UKnots</a> () const</td></tr>
<tr class="memdesc:a51a82908fd062a50c03830b65226ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the U direction.  <a href="#a51a82908fd062a50c03830b65226ff65">More...</a><br /></td></tr>
<tr class="separator:a51a82908fd062a50c03830b65226ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899a341022ecbc07e2cf9766f6a0af30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a899a341022ecbc07e2cf9766f6a0af30">UKnotSequence</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Ku) const</td></tr>
<tr class="memdesc:a899a341022ecbc07e2cf9766f6a0af30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#a899a341022ecbc07e2cf9766f6a0af30">More...</a><br /></td></tr>
<tr class="separator:a899a341022ecbc07e2cf9766f6a0af30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6d40901201fb4bdecee7300fd5d347"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1f6d40901201fb4bdecee7300fd5d347">UKnotSequence</a> () const</td></tr>
<tr class="memdesc:a1f6d40901201fb4bdecee7300fd5d347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#a1f6d40901201fb4bdecee7300fd5d347">More...</a><br /></td></tr>
<tr class="separator:a1f6d40901201fb4bdecee7300fd5d347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6409304c3ff4fb9f52761281f264ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a9d6409304c3ff4fb9f52761281f264ca">UMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex) const</td></tr>
<tr class="memdesc:a9d6409304c3ff4fb9f52761281f264ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicity value of knot of range UIndex in the u direction. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots.  <a href="#a9d6409304c3ff4fb9f52761281f264ca">More...</a><br /></td></tr>
<tr class="separator:a9d6409304c3ff4fb9f52761281f264ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacba292d660e62afe44f343985b9429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#afacba292d660e62afe44f343985b9429">UMultiplicities</a> (<a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mu) const</td></tr>
<tr class="memdesc:afacba292d660e62afe44f343985b9429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the U direction.  <a href="#afacba292d660e62afe44f343985b9429">More...</a><br /></td></tr>
<tr class="separator:afacba292d660e62afe44f343985b9429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967289dad8894531fe6ede9c4e76e9d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a967289dad8894531fe6ede9c4e76e9d2">UMultiplicities</a> () const</td></tr>
<tr class="memdesc:a967289dad8894531fe6ede9c4e76e9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the U direction.  <a href="#a967289dad8894531fe6ede9c4e76e9d2">More...</a><br /></td></tr>
<tr class="separator:a967289dad8894531fe6ede9c4e76e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14183eb2a06b72c428047199bbb0d30b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a14183eb2a06b72c428047199bbb0d30b">VDegree</a> () const</td></tr>
<tr class="memdesc:a14183eb2a06b72c428047199bbb0d30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of the normalized B-splines Ni,d in the V direction.  <a href="#a14183eb2a06b72c428047199bbb0d30b">More...</a><br /></td></tr>
<tr class="separator:a14183eb2a06b72c428047199bbb0d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1236c6ac22ad3b3ab4163c0bee1e65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab1236c6ac22ad3b3ab4163c0bee1e65e">VKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const</td></tr>
<tr class="memdesc:ab1236c6ac22ad3b3ab4163c0bee1e65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Knot value of range VIndex. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots.  <a href="#ab1236c6ac22ad3b3ab4163c0bee1e65e">More...</a><br /></td></tr>
<tr class="separator:ab1236c6ac22ad3b3ab4163c0bee1e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183a3e9e9a57856f306608a1e4c9b9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a183a3e9e9a57856f306608a1e4c9b9e5">VKnotDistribution</a> () const</td></tr>
<tr class="memdesc:a183a3e9e9a57856f306608a1e4c9b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the V direction the B-spline surface can be :  <a href="#a183a3e9e9a57856f306608a1e4c9b9e5">More...</a><br /></td></tr>
<tr class="separator:a183a3e9e9a57856f306608a1e4c9b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc42618b81f3c6a64d14782b8d813044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abc42618b81f3c6a64d14782b8d813044">VKnots</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Kv) const</td></tr>
<tr class="memdesc:abc42618b81f3c6a64d14782b8d813044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the V direction.  <a href="#abc42618b81f3c6a64d14782b8d813044">More...</a><br /></td></tr>
<tr class="separator:abc42618b81f3c6a64d14782b8d813044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13671bb6137103911652fa91a653b79"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ad13671bb6137103911652fa91a653b79">VKnots</a> () const</td></tr>
<tr class="memdesc:ad13671bb6137103911652fa91a653b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the V direction.  <a href="#ad13671bb6137103911652fa91a653b79">More...</a><br /></td></tr>
<tr class="separator:ad13671bb6137103911652fa91a653b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2f0f02c7db958f17590b373f1471fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2d2f0f02c7db958f17590b373f1471fc">VKnotSequence</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Kv) const</td></tr>
<tr class="memdesc:a2d2f0f02c7db958f17590b373f1471fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Kv = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#a2d2f0f02c7db958f17590b373f1471fc">More...</a><br /></td></tr>
<tr class="separator:a2d2f0f02c7db958f17590b373f1471fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14e06a546cce306fd6a3cbb7900f8bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab14e06a546cce306fd6a3cbb7900f8bc">VKnotSequence</a> () const</td></tr>
<tr class="memdesc:ab14e06a546cce306fd6a3cbb7900f8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#ab14e06a546cce306fd6a3cbb7900f8bc">More...</a><br /></td></tr>
<tr class="separator:ab14e06a546cce306fd6a3cbb7900f8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f3c1f35c02eeee6469adb6d0dc6155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#af7f3c1f35c02eeee6469adb6d0dc6155">VMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const</td></tr>
<tr class="memdesc:af7f3c1f35c02eeee6469adb6d0dc6155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicity value of knot of range VIndex in the v direction. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots.  <a href="#af7f3c1f35c02eeee6469adb6d0dc6155">More...</a><br /></td></tr>
<tr class="separator:af7f3c1f35c02eeee6469adb6d0dc6155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5e8c10b3033cedd4b3d76e347517e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7df5e8c10b3033cedd4b3d76e347517e">VMultiplicities</a> (<a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mv) const</td></tr>
<tr class="memdesc:a7df5e8c10b3033cedd4b3d76e347517e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the V direction.  <a href="#a7df5e8c10b3033cedd4b3d76e347517e">More...</a><br /></td></tr>
<tr class="separator:a7df5e8c10b3033cedd4b3d76e347517e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846146f8ea033f4970cccf9c0a6af6f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a846146f8ea033f4970cccf9c0a6af6f5">VMultiplicities</a> () const</td></tr>
<tr class="memdesc:a846146f8ea033f4970cccf9c0a6af6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the V direction.  <a href="#a846146f8ea033f4970cccf9c0a6af6f5">More...</a><br /></td></tr>
<tr class="separator:a846146f8ea033f4970cccf9c0a6af6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ddca375feffee360d3f180cdbf38a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a92ddca375feffee360d3f180cdbf38a1">Weight</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const</td></tr>
<tr class="memdesc:a92ddca375feffee360d3f180cdbf38a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight value of range UIndex, VIndex.  <a href="#a92ddca375feffee360d3f180cdbf38a1">More...</a><br /></td></tr>
<tr class="separator:a92ddca375feffee360d3f180cdbf38a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3432cbee6dc104640b28a3db917f868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab3432cbee6dc104640b28a3db917f868">Weights</a> (<a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;W) const</td></tr>
<tr class="memdesc:ab3432cbee6dc104640b28a3db917f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the B-spline surface.  <a href="#ab3432cbee6dc104640b28a3db917f868">More...</a><br /></td></tr>
<tr class="separator:ab3432cbee6dc104640b28a3db917f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4df08073e225763bc7dcb84dbcff902"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab4df08073e225763bc7dcb84dbcff902">Weights</a> () const</td></tr>
<tr class="memdesc:ab4df08073e225763bc7dcb84dbcff902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the B-spline surface. value and derivatives computation.  <a href="#ab4df08073e225763bc7dcb84dbcff902">More...</a><br /></td></tr>
<tr class="separator:ab4df08073e225763bc7dcb84dbcff902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07177b7b6518b51648d597c8b32232a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a07177b7b6518b51648d597c8b32232a2">D0</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P) const override</td></tr>
<tr class="memdesc:a07177b7b6518b51648d597c8b32232a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of parameter U,V on the surface.  <a href="#a07177b7b6518b51648d597c8b32232a2">More...</a><br /></td></tr>
<tr class="separator:a07177b7b6518b51648d597c8b32232a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98631e40889c2a56c3e6eacff5279a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a98631e40889c2a56c3e6eacff5279a0b">D1</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V) const override</td></tr>
<tr class="memdesc:a98631e40889c2a56c3e6eacff5279a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the continuity of the surface is not C1.  <a href="#a98631e40889c2a56c3e6eacff5279a0b">More...</a><br /></td></tr>
<tr class="separator:a98631e40889c2a56c3e6eacff5279a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209fd5b7c659ef9ac0cecfb1454c91f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a209fd5b7c659ef9ac0cecfb1454c91f5">D2</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV) const override</td></tr>
<tr class="memdesc:a209fd5b7c659ef9ac0cecfb1454c91f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the continuity of the surface is not C2.  <a href="#a209fd5b7c659ef9ac0cecfb1454c91f5">More...</a><br /></td></tr>
<tr class="separator:a209fd5b7c659ef9ac0cecfb1454c91f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbdf61c1beabe26f98feee4c93bb457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1dbdf61c1beabe26f98feee4c93bb457">D3</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UUV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UVV) const override</td></tr>
<tr class="memdesc:a1dbdf61c1beabe26f98feee4c93bb457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the continuity of the surface is not C3.  <a href="#a1dbdf61c1beabe26f98feee4c93bb457">More...</a><br /></td></tr>
<tr class="separator:a1dbdf61c1beabe26f98feee4c93bb457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca74b92f4d3b9fba78095a4731992ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4ca74b92f4d3b9fba78095a4731992ee">DN</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv) const override</td></tr>
<tr class="memdesc:a4ca74b92f4d3b9fba78095a4731992ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nu is the order of derivation in the U parametric direction and Nv is the order of derivation in the V parametric direction.  <a href="#a4ca74b92f4d3b9fba78095a4731992ee">More...</a><br /></td></tr>
<tr class="separator:a4ca74b92f4d3b9fba78095a4731992ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e64fe9e6d20c8fc4d0f2a58602a1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a94e64fe9e6d20c8fc4d0f2a58602a1c8">LocalD0</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P) const</td></tr>
<tr class="memdesc:a94e64fe9e6d20c8fc4d0f2a58602a1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a94e64fe9e6d20c8fc4d0f2a58602a1c8">More...</a><br /></td></tr>
<tr class="separator:a94e64fe9e6d20c8fc4d0f2a58602a1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a69ff7fd3bf66b4aa06a9b1d586d81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4a69ff7fd3bf66b4aa06a9b1d586d81b">LocalD1</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V) const</td></tr>
<tr class="memdesc:a4a69ff7fd3bf66b4aa06a9b1d586d81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not C1 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a4a69ff7fd3bf66b4aa06a9b1d586d81b">More...</a><br /></td></tr>
<tr class="separator:a4a69ff7fd3bf66b4aa06a9b1d586d81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277d0312549205f85aaaab4b493b538d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a277d0312549205f85aaaab4b493b538d">LocalD2</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV) const</td></tr>
<tr class="memdesc:a277d0312549205f85aaaab4b493b538d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not C2 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a277d0312549205f85aaaab4b493b538d">More...</a><br /></td></tr>
<tr class="separator:a277d0312549205f85aaaab4b493b538d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b50af58054e2a18b5631eea2aac4846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8b50af58054e2a18b5631eea2aac4846">LocalD3</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UUV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UVV) const</td></tr>
<tr class="memdesc:a8b50af58054e2a18b5631eea2aac4846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not C3 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a8b50af58054e2a18b5631eea2aac4846">More...</a><br /></td></tr>
<tr class="separator:a8b50af58054e2a18b5631eea2aac4846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd35a090b1e3153399d11d718f01091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7fd35a090b1e3153399d11d718f01091">LocalDN</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv) const</td></tr>
<tr class="memdesc:a7fd35a090b1e3153399d11d718f01091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not CNu between the knots FromUK1, ToUK2 and CNv between the knots FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a7fd35a090b1e3153399d11d718f01091">More...</a><br /></td></tr>
<tr class="separator:a7fd35a090b1e3153399d11d718f01091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922b68f08f1c87ba50d377dd35d8cbe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___pnt.html">gp_Pnt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a922b68f08f1c87ba50d377dd35d8cbe1">LocalValue</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2) const</td></tr>
<tr class="memdesc:a922b68f08f1c87ba50d377dd35d8cbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of parameter U, V on the BSpline surface patch defines between the knots UK1 UK2, VK1, VK2. U can be out of the bounds [Knot UK1, Knot UK2] and V can be outof the bounds [Knot VK1, Knot VK2] but for the computation we only use the definition of the surface between these knot values. Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a922b68f08f1c87ba50d377dd35d8cbe1">More...</a><br /></td></tr>
<tr class="separator:a922b68f08f1c87ba50d377dd35d8cbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810d15efc667b89905125a5cd0726b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a5810d15efc667b89905125a5cd0726b0">UIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U) const override</td></tr>
<tr class="memdesc:a5810d15efc667b89905125a5cd0726b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the U isoparametric curve. A B-spline curve is returned.  <a href="#a5810d15efc667b89905125a5cd0726b0">More...</a><br /></td></tr>
<tr class="separator:a5810d15efc667b89905125a5cd0726b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0975e8dfe3e9c01087cb353085d6aa30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0975e8dfe3e9c01087cb353085d6aa30">VIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V) const override</td></tr>
<tr class="memdesc:a0975e8dfe3e9c01087cb353085d6aa30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the V isoparametric curve. A B-spline curve is returned.  <a href="#a0975e8dfe3e9c01087cb353085d6aa30">More...</a><br /></td></tr>
<tr class="separator:a0975e8dfe3e9c01087cb353085d6aa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7959a4cb8247a2a6c8d4f057d83163d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7959a4cb8247a2a6c8d4f057d83163d7">UIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> CheckRational) const</td></tr>
<tr class="memdesc:a7959a4cb8247a2a6c8d4f057d83163d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the U isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned.  <a href="#a7959a4cb8247a2a6c8d4f057d83163d7">More...</a><br /></td></tr>
<tr class="separator:a7959a4cb8247a2a6c8d4f057d83163d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd55537982ae78216b6ac3a26ee45390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#acd55537982ae78216b6ac3a26ee45390">VIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> CheckRational) const</td></tr>
<tr class="memdesc:acd55537982ae78216b6ac3a26ee45390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the V isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. transformations.  <a href="#acd55537982ae78216b6ac3a26ee45390">More...</a><br /></td></tr>
<tr class="separator:acd55537982ae78216b6ac3a26ee45390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d26b8258d892130a39c05f119401fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8d26b8258d892130a39c05f119401fea">Transform</a> (const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) override</td></tr>
<tr class="memdesc:a8d26b8258d892130a39c05f119401fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the transformation T to this BSpline surface.  <a href="#a8d26b8258d892130a39c05f119401fea">More...</a><br /></td></tr>
<tr class="separator:a8d26b8258d892130a39c05f119401fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e184acbeca9bf93faf8ed888d37e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a86e184acbeca9bf93faf8ed888d37e1e">Resolution</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Tolerance3D, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;UTolerance, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;VTolerance)</td></tr>
<tr class="memdesc:a86e184acbeca9bf93faf8ed888d37e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes two tolerance values for this BSpline surface, based on the given tolerance in 3D space Tolerance3D. The tolerances computed are:  <a href="#a86e184acbeca9bf93faf8ed888d37e1e">More...</a><br /></td></tr>
<tr class="separator:a86e184acbeca9bf93faf8ed888d37e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee38dd5e7647bd35bc445058f3c9b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2ee38dd5e7647bd35bc445058f3c9b12">Copy</a> () const override</td></tr>
<tr class="memdesc:a2ee38dd5e7647bd35bc445058f3c9b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object which is a copy of this BSpline surface.  <a href="#a2ee38dd5e7647bd35bc445058f3c9b12">More...</a><br /></td></tr>
<tr class="separator:a2ee38dd5e7647bd35bc445058f3c9b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_geom___surface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_geom___surface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_geom___surface.html">Geom_Surface</a></td></tr>
<tr class="memitem:a432b807813f39b70fd464ed6e0da0962 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___surface.html">Geom_Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#a432b807813f39b70fd464ed6e0da0962">UReversed</a> () const</td></tr>
<tr class="memdesc:a432b807813f39b70fd464ed6e0da0962 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the U direction of parametrization of &lt;me&gt;. The bounds of the surface are not modified. A copy of &lt;me&gt; is returned.  <a href="class_geom___surface.html#a432b807813f39b70fd464ed6e0da0962">More...</a><br /></td></tr>
<tr class="separator:a432b807813f39b70fd464ed6e0da0962 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b2ea261cf6965dc9e1682a5d7b7c24 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___surface.html">Geom_Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#aa2b2ea261cf6965dc9e1682a5d7b7c24">VReversed</a> () const</td></tr>
<tr class="memdesc:aa2b2ea261cf6965dc9e1682a5d7b7c24 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the V direction of parametrization of &lt;me&gt;. The bounds of the surface are not modified. A copy of &lt;me&gt; is returned.  <a href="class_geom___surface.html#aa2b2ea261cf6965dc9e1682a5d7b7c24">More...</a><br /></td></tr>
<tr class="separator:aa2b2ea261cf6965dc9e1682a5d7b7c24 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9426fdda0713f4bd9381dfd7cb98626 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#ac9426fdda0713f4bd9381dfd7cb98626">TransformParameters</a> (<a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V, const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) const</td></tr>
<tr class="memdesc:ac9426fdda0713f4bd9381dfd7cb98626 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the parameters on the transformed surface for the transform of the point of parameters U,V on &lt;me&gt;.  <a href="class_geom___surface.html#ac9426fdda0713f4bd9381dfd7cb98626">More...</a><br /></td></tr>
<tr class="separator:ac9426fdda0713f4bd9381dfd7cb98626 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98cda47467a994eadcf632052f19c0f inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgp___g_trsf2d.html">gp_GTrsf2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#aa98cda47467a994eadcf632052f19c0f">ParametricTransformation</a> (const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) const</td></tr>
<tr class="memdesc:aa98cda47467a994eadcf632052f19c0f inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 2d transformation used to find the new parameters of a point on the transformed surface.  <a href="class_geom___surface.html#aa98cda47467a994eadcf632052f19c0f">More...</a><br /></td></tr>
<tr class="separator:aa98cda47467a994eadcf632052f19c0f inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f0d051b063210014f35ece2ccbd10 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#ac82f0d051b063210014f35ece2ccbd10">UPeriod</a> () const</td></tr>
<tr class="memdesc:ac82f0d051b063210014f35ece2ccbd10 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the period of this surface in the u parametric direction. raises if the surface is not uperiodic.  <a href="class_geom___surface.html#ac82f0d051b063210014f35ece2ccbd10">More...</a><br /></td></tr>
<tr class="separator:ac82f0d051b063210014f35ece2ccbd10 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3369659f02a52a06b3baa41d4c9d99 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#a6b3369659f02a52a06b3baa41d4c9d99">VPeriod</a> () const</td></tr>
<tr class="memdesc:a6b3369659f02a52a06b3baa41d4c9d99 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the period of this surface in the v parametric direction. raises if the surface is not vperiodic.  <a href="class_geom___surface.html#a6b3369659f02a52a06b3baa41d4c9d99">More...</a><br /></td></tr>
<tr class="separator:a6b3369659f02a52a06b3baa41d4c9d99 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a3ce54e96eba38e7fd0a471693b51f inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___pnt.html">gp_Pnt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#a80a3ce54e96eba38e7fd0a471693b51f">Value</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V) const</td></tr>
<tr class="memdesc:a80a3ce54e96eba38e7fd0a471693b51f inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of parameter U on the surface.  <a href="class_geom___surface.html#a80a3ce54e96eba38e7fd0a471693b51f">More...</a><br /></td></tr>
<tr class="separator:a80a3ce54e96eba38e7fd0a471693b51f inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_geom___geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_geom___geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_geom___geometry.html">Geom_Geometry</a></td></tr>
<tr class="memitem:a5534b9918fc2e64ab2b3cdc48d14e603 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a5534b9918fc2e64ab2b3cdc48d14e603">Mirror</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P)</td></tr>
<tr class="memdesc:a5534b9918fc2e64ab2b3cdc48d14e603 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the symmetrical transformation of a Geometry with respect to the point P which is the center of the symmetry.  <a href="class_geom___geometry.html#a5534b9918fc2e64ab2b3cdc48d14e603">More...</a><br /></td></tr>
<tr class="separator:a5534b9918fc2e64ab2b3cdc48d14e603 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2186df0fea82f372c81cf9416019e8 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a9f2186df0fea82f372c81cf9416019e8">Mirror</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1)</td></tr>
<tr class="memdesc:a9f2186df0fea82f372c81cf9416019e8 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the symmetrical transformation of a Geometry with respect to an axis placement which is the axis of the symmetry.  <a href="class_geom___geometry.html#a9f2186df0fea82f372c81cf9416019e8">More...</a><br /></td></tr>
<tr class="separator:a9f2186df0fea82f372c81cf9416019e8 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57306578533b91fbec9001ece88d845f inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a57306578533b91fbec9001ece88d845f">Mirror</a> (const <a class="el" href="classgp___ax2.html">gp_Ax2</a> &amp;A2)</td></tr>
<tr class="memdesc:a57306578533b91fbec9001ece88d845f inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the symmetrical transformation of a Geometry with respect to a plane. The axis placement A2 locates the plane of the symmetry : (Location, XDirection, YDirection).  <a href="class_geom___geometry.html#a57306578533b91fbec9001ece88d845f">More...</a><br /></td></tr>
<tr class="separator:a57306578533b91fbec9001ece88d845f inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda3db34908b9aed5812911c8f75799 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a7dda3db34908b9aed5812911c8f75799">Rotate</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Ang)</td></tr>
<tr class="memdesc:a7dda3db34908b9aed5812911c8f75799 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a Geometry. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.  <a href="class_geom___geometry.html#a7dda3db34908b9aed5812911c8f75799">More...</a><br /></td></tr>
<tr class="separator:a7dda3db34908b9aed5812911c8f75799 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0328beeef84f5d820e3432627fc8110 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#ae0328beeef84f5d820e3432627fc8110">Scale</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> S)</td></tr>
<tr class="memdesc:ae0328beeef84f5d820e3432627fc8110 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a Geometry. S is the scaling value.  <a href="class_geom___geometry.html#ae0328beeef84f5d820e3432627fc8110">More...</a><br /></td></tr>
<tr class="separator:ae0328beeef84f5d820e3432627fc8110 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9847ae89540ce9efac6d428dd9f5d2 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a7b9847ae89540ce9efac6d428dd9f5d2">Translate</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;V)</td></tr>
<tr class="memdesc:a7b9847ae89540ce9efac6d428dd9f5d2 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Geometry. V is the vector of the tanslation.  <a href="class_geom___geometry.html#a7b9847ae89540ce9efac6d428dd9f5d2">More...</a><br /></td></tr>
<tr class="separator:a7b9847ae89540ce9efac6d428dd9f5d2 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669eb0869256860f74d1c496b7a4e1dd inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a669eb0869256860f74d1c496b7a4e1dd">Translate</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P1, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P2)</td></tr>
<tr class="memdesc:a669eb0869256860f74d1c496b7a4e1dd inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Geometry from the point P1 to the point P2.  <a href="class_geom___geometry.html#a669eb0869256860f74d1c496b7a4e1dd">More...</a><br /></td></tr>
<tr class="separator:a669eb0869256860f74d1c496b7a4e1dd inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9dd1be7f5c5ec589b748e5d65b8778 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a8f9dd1be7f5c5ec589b748e5d65b8778">Mirrored</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P) const</td></tr>
<tr class="separator:a8f9dd1be7f5c5ec589b748e5d65b8778 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b45c125e8b660491823159b6ca3d0f7 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a5b45c125e8b660491823159b6ca3d0f7">Mirrored</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1) const</td></tr>
<tr class="separator:a5b45c125e8b660491823159b6ca3d0f7 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c40f8ea546e8706c2ab4f9feb156f67 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a4c40f8ea546e8706c2ab4f9feb156f67">Mirrored</a> (const <a class="el" href="classgp___ax2.html">gp_Ax2</a> &amp;A2) const</td></tr>
<tr class="separator:a4c40f8ea546e8706c2ab4f9feb156f67 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68789de19279c20e6a798c80abbbb38d inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a68789de19279c20e6a798c80abbbb38d">Rotated</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Ang) const</td></tr>
<tr class="separator:a68789de19279c20e6a798c80abbbb38d inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753d068e05c6289b8825c9036ff20ea6 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a753d068e05c6289b8825c9036ff20ea6">Scaled</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> S) const</td></tr>
<tr class="separator:a753d068e05c6289b8825c9036ff20ea6 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7109284d2bbb66ca9711a474b20640d6 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a7109284d2bbb66ca9711a474b20640d6">Transformed</a> (const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) const</td></tr>
<tr class="separator:a7109284d2bbb66ca9711a474b20640d6 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108febdab9159f36ef5faa3bf3a7599e inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a108febdab9159f36ef5faa3bf3a7599e">Translated</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;V) const</td></tr>
<tr class="separator:a108febdab9159f36ef5faa3bf3a7599e inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00abcb57bbbf5af658eaa3f7bc0dd473 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a00abcb57bbbf5af658eaa3f7bc0dd473">Translated</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P1, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P2) const</td></tr>
<tr class="separator:a00abcb57bbbf5af658eaa3f7bc0dd473 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_standard___transient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_standard___transient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_standard___transient.html">Standard_Transient</a></td></tr>
<tr class="memitem:a28c37998a6ef973851f456840b34de64 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a28c37998a6ef973851f456840b34de64">Standard_Transient</a> ()</td></tr>
<tr class="memdesc:a28c37998a6ef973851f456840b34de64 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="class_standard___transient.html#a28c37998a6ef973851f456840b34de64">More...</a><br /></td></tr>
<tr class="separator:a28c37998a6ef973851f456840b34de64 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857f1ada543829be61dbd804ae47c52f inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a857f1ada543829be61dbd804ae47c52f">Standard_Transient</a> (const <a class="el" href="class_standard___transient.html">Standard_Transient</a> &amp;)</td></tr>
<tr class="memdesc:a857f1ada543829be61dbd804ae47c52f inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor &ndash; does nothing.  <a href="class_standard___transient.html#a857f1ada543829be61dbd804ae47c52f">More...</a><br /></td></tr>
<tr class="separator:a857f1ada543829be61dbd804ae47c52f inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16b65e2f6a1922f42ce51f6b67c3c33 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_standard___transient.html">Standard_Transient</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#ad16b65e2f6a1922f42ce51f6b67c3c33">operator=</a> (const <a class="el" href="class_standard___transient.html">Standard_Transient</a> &amp;)</td></tr>
<tr class="memdesc:ad16b65e2f6a1922f42ce51f6b67c3c33 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, needed to avoid copying reference counter.  <a href="class_standard___transient.html#ad16b65e2f6a1922f42ce51f6b67c3c33">More...</a><br /></td></tr>
<tr class="separator:ad16b65e2f6a1922f42ce51f6b67c3c33 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534846a08f64eaba4d764ec84b0e7728 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a534846a08f64eaba4d764ec84b0e7728">~Standard_Transient</a> ()</td></tr>
<tr class="memdesc:a534846a08f64eaba4d764ec84b0e7728 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor must be virtual.  <a href="class_standard___transient.html#a534846a08f64eaba4d764ec84b0e7728">More...</a><br /></td></tr>
<tr class="separator:a534846a08f64eaba4d764ec84b0e7728 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71880667b7f2496b120dfdfe43b63955 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a71880667b7f2496b120dfdfe43b63955">Delete</a> () const</td></tr>
<tr class="memdesc:a71880667b7f2496b120dfdfe43b63955 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory deallocator for transient classes.  <a href="class_standard___transient.html#a71880667b7f2496b120dfdfe43b63955">More...</a><br /></td></tr>
<tr class="separator:a71880667b7f2496b120dfdfe43b63955 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81fdf63a60c1d6d1b65a4b34252e107 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#ad81fdf63a60c1d6d1b65a4b34252e107">DynamicType</a> () const</td></tr>
<tr class="memdesc:ad81fdf63a60c1d6d1b65a4b34252e107 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type descriptor about this object.  <a href="class_standard___transient.html#ad81fdf63a60c1d6d1b65a4b34252e107">More...</a><br /></td></tr>
<tr class="separator:ad81fdf63a60c1d6d1b65a4b34252e107 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9522d9c4ee17331d71fc7f94c5725733 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a9522d9c4ee17331d71fc7f94c5725733">IsInstance</a> (const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;theType) const</td></tr>
<tr class="memdesc:a9522d9c4ee17331d71fc7f94c5725733 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a true value if this is an instance of Type.  <a href="class_standard___transient.html#a9522d9c4ee17331d71fc7f94c5725733">More...</a><br /></td></tr>
<tr class="separator:a9522d9c4ee17331d71fc7f94c5725733 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10f064d6e570a9245b3f207744610b2 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#ac10f064d6e570a9245b3f207744610b2">IsInstance</a> (const <a class="el" href="_standard___type_def_8hxx.html#aee98bfe6774a1f4d9570c388805de3cc">Standard_CString</a> theTypeName) const</td></tr>
<tr class="memdesc:ac10f064d6e570a9245b3f207744610b2 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a true value if this is an instance of TypeName.  <a href="class_standard___transient.html#ac10f064d6e570a9245b3f207744610b2">More...</a><br /></td></tr>
<tr class="separator:ac10f064d6e570a9245b3f207744610b2 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0584415bace3004f90b1ce16a7023b inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#aae0584415bace3004f90b1ce16a7023b">IsKind</a> (const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;theType) const</td></tr>
<tr class="memdesc:aae0584415bace3004f90b1ce16a7023b inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is an instance of Type or an instance of any class that inherits from Type. Note that multiple inheritance is not supported by OCCT RTTI mechanism.  <a href="class_standard___transient.html#aae0584415bace3004f90b1ce16a7023b">More...</a><br /></td></tr>
<tr class="separator:aae0584415bace3004f90b1ce16a7023b inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657f67fe41e8084df5cc033258583c7 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a6657f67fe41e8084df5cc033258583c7">IsKind</a> (const <a class="el" href="_standard___type_def_8hxx.html#aee98bfe6774a1f4d9570c388805de3cc">Standard_CString</a> theTypeName) const</td></tr>
<tr class="memdesc:a6657f67fe41e8084df5cc033258583c7 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is an instance of TypeName or an instance of any class that inherits from TypeName. Note that multiple inheritance is not supported by OCCT RTTI mechanism.  <a href="class_standard___transient.html#a6657f67fe41e8084df5cc033258583c7">More...</a><br /></td></tr>
<tr class="separator:a6657f67fe41e8084df5cc033258583c7 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc558de4eb11eaa1d70baf3fdb05448 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_standard___transient.html">Standard_Transient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#aabc558de4eb11eaa1d70baf3fdb05448">This</a> () const</td></tr>
<tr class="memdesc:aabc558de4eb11eaa1d70baf3fdb05448 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const pointer to this object (like const_cast). For protection against creating handle to objects allocated in stack or call from constructor, it will raise exception Standard_ProgramError if reference counter is zero.  <a href="class_standard___transient.html#aabc558de4eb11eaa1d70baf3fdb05448">More...</a><br /></td></tr>
<tr class="separator:aabc558de4eb11eaa1d70baf3fdb05448 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a559cd635400b3e17112c7be60c996 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a02a559cd635400b3e17112c7be60c996">GetRefCount</a> () const</td></tr>
<tr class="memdesc:a02a559cd635400b3e17112c7be60c996 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference counter of this object.  <a href="class_standard___transient.html#a02a559cd635400b3e17112c7be60c996">More...</a><br /></td></tr>
<tr class="separator:a02a559cd635400b3e17112c7be60c996 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1865cf934e9d65727caaa6783b4f3cfc inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a1865cf934e9d65727caaa6783b4f3cfc">IncrementRefCounter</a> () const</td></tr>
<tr class="memdesc:a1865cf934e9d65727caaa6783b4f3cfc inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference counter of this object.  <a href="class_standard___transient.html#a1865cf934e9d65727caaa6783b4f3cfc">More...</a><br /></td></tr>
<tr class="separator:a1865cf934e9d65727caaa6783b4f3cfc inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50aac4b364cfcdadd80c2bed3b8c00a inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#ad50aac4b364cfcdadd80c2bed3b8c00a">DecrementRefCounter</a> () const</td></tr>
<tr class="memdesc:ad50aac4b364cfcdadd80c2bed3b8c00a inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference counter of this object; returns the decremented value.  <a href="class_standard___transient.html#ad50aac4b364cfcdadd80c2bed3b8c00a">More...</a><br /></td></tr>
<tr class="separator:ad50aac4b364cfcdadd80c2bed3b8c00a inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac1496de7ea0d7268ee94ba738c61dd0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac1496de7ea0d7268ee94ba738c61dd0e">MaxDegree</a> ()</td></tr>
<tr class="memdesc:ac1496de7ea0d7268ee94ba738c61dd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v directions.  <a href="#ac1496de7ea0d7268ee94ba738c61dd0e">More...</a><br /></td></tr>
<tr class="separator:ac1496de7ea0d7268ee94ba738c61dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_standard___transient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_standard___transient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_standard___transient.html">Standard_Transient</a></td></tr>
<tr class="memitem:a0f5a2b0f378a5a58ca42d50092ae637a inherit pub_static_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a0f5a2b0f378a5a58ca42d50092ae637a">get_type_name</a> ()</td></tr>
<tr class="memdesc:a0f5a2b0f378a5a58ca42d50092ae637a inherit pub_static_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type descriptor about this object.  <a href="class_standard___transient.html#a0f5a2b0f378a5a58ca42d50092ae637a">More...</a><br /></td></tr>
<tr class="separator:a0f5a2b0f378a5a58ca42d50092ae637a inherit pub_static_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d7949596235d35c1a5b7a4bbd77f2 inherit pub_static_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a7b7d7949596235d35c1a5b7a4bbd77f2">get_type_descriptor</a> ()</td></tr>
<tr class="memdesc:a7b7d7949596235d35c1a5b7a4bbd77f2 inherit pub_static_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type descriptor of <a class="el" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. ">Standard_Transient</a> class.  <a href="class_standard___transient.html#a7b7d7949596235d35c1a5b7a4bbd77f2">More...</a><br /></td></tr>
<tr class="separator:a7b7d7949596235d35c1a5b7a4bbd77f2 inherit pub_static_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dc8418edec13c452e97feca0a8baffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0dc8418edec13c452e97feca0a8baffb">segment</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> EpsU, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> EpsV, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> SegmentInU, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> SegmentInV)</td></tr>
<tr class="memdesc:a0dc8418edec13c452e97feca0a8baffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same.  <a href="#a0dc8418edec13c452e97feca0a8baffb">More...</a><br /></td></tr>
<tr class="separator:a0dc8418edec13c452e97feca0a8baffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_standard___transient"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_standard___transient')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_standard___transient.html">Standard_Transient</a></td></tr>
<tr class="memitem:a6cdf8e1478fba7bae45bcbc8c4e4ebb9 inherit pub_types_class_standard___transient"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a6cdf8e1478fba7bae45bcbc8c4e4ebb9">base_type</a></td></tr>
<tr class="memdesc:a6cdf8e1478fba7bae45bcbc8c4e4ebb9 inherit pub_types_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type descriptor about this object.  <a href="class_standard___transient.html#a6cdf8e1478fba7bae45bcbc8c4e4ebb9">More...</a><br /></td></tr>
<tr class="separator:a6cdf8e1478fba7bae45bcbc8c4e4ebb9 inherit pub_types_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes a BSpline surface. In each parametric direction, a BSpline surface can be: </p>
<ul>
<li>uniform or non-uniform,</li>
<li>rational or non-rational,</li>
<li>periodic or non-periodic. A BSpline surface is defined by:</li>
<li>its degrees, in the u and v parametric directions,</li>
<li>its periodic characteristic, in the u and v parametric directions,</li>
<li>a table of poles, also called control points (together with the associated weights if the surface is rational), and</li>
<li>a table of knots, together with the associated multiplicities. The degree of a <a class="el" href="class_geom___b_spline_surface.html" title="Describes a BSpline surface. In each parametric direction, a BSpline surface can be: ...">Geom_BSplineSurface</a> is limited to a value (25) which is defined and controlled by the system. This value is returned by the function MaxDegree. Poles and Weights Poles and Weights are manipulated using two associative double arrays:</li>
<li>the poles table, which is a double array of <a class="el" href="classgp___pnt.html" title="Defines a 3D cartesian point. ">gp_Pnt</a> points, and</li>
<li>the weights table, which is a double array of reals. The bounds of the poles and weights arrays are:</li>
<li>1 and NbUPoles for the row bounds (provided that the BSpline surface is not periodic in the u parametric direction), where NbUPoles is the number of poles of the surface in the u parametric direction, and</li>
<li>1 and NbVPoles for the column bounds (provided that the BSpline surface is not periodic in the v parametric direction), where NbVPoles is the number of poles of the surface in the v parametric direction. The poles of the surface are the points used to shape and reshape the surface. They comprise a rectangular network. If the surface is not periodic:</li>
<li>The points (1, 1), (NbUPoles, 1), (1, NbVPoles), and (NbUPoles, NbVPoles) are the four parametric "corners" of the surface.</li>
<li>The first column of poles and the last column of poles define two BSpline curves which delimit the surface in the v parametric direction. These are the v isoparametric curves corresponding to the two bounds of the v parameter.</li>
<li>The first row of poles and the last row of poles define two BSpline curves which delimit the surface in the u parametric direction. These are the u isoparametric curves corresponding to the two bounds of the u parameter. If the surface is periodic, these geometric properties are not verified. It is more difficult to define a geometrical significance for the weights. However they are useful for representing a quadric surface precisely. Moreover, if the weights of all the poles are equal, the surface has a polynomial equation, and hence is a "non-rational surface". The non-rational surface is a special, but frequently used, case, where all poles have identical weights. The weights are defined and used only in the case of a rational surface. The rational characteristic is defined in each parametric direction. A surface can be rational in the u parametric direction, and non-rational in the v parametric direction. Knots and Multiplicities For a <a class="el" href="class_geom___b_spline_surface.html" title="Describes a BSpline surface. In each parametric direction, a BSpline surface can be: ...">Geom_BSplineSurface</a> the table of knots is made up of two increasing sequences of reals, without repetition, one for each parametric direction. The multiplicities define the repetition of the knots. A BSpline surface comprises multiple contiguous patches, which are themselves polynomial or rational surfaces. The knots are the parameters of the isoparametric curves which limit these contiguous patches. The multiplicity of a knot on a BSpline surface (in a given parametric direction) is related to the degree of continuity of the surface at that knot in that parametric direction: Degree of continuity at knot(i) = Degree - Multi(i) where:</li>
<li>Degree is the degree of the BSpline surface in the given parametric direction, and</li>
<li>Multi(i) is the multiplicity of knot number i in the given parametric direction. There are some special cases, where the knots are regularly spaced in one parametric direction (i.e. the difference between two consecutive knots is a constant).</li>
<li>"Uniform": all the multiplicities are equal to 1.</li>
<li>"Quasi-uniform": all the multiplicities are equal to 1, except for the first and last knots in this parametric direction, and these are equal to Degree + 1.</li>
<li>"Piecewise Bezier": all the multiplicities are equal to Degree except for the first and last knots, which are equal to Degree + 1. This surface is a concatenation of Bezier patches in the given parametric direction. If the BSpline surface is not periodic in a given parametric direction, the bounds of the knots and multiplicities tables are 1 and NbKnots, where NbKnots is the number of knots of the BSpline surface in that parametric direction. If the BSpline surface is periodic in a given parametric direction, and there are k periodic knots and p periodic poles in that parametric direction:</li>
<li>the period is such that: period = Knot(k+1) - Knot(1), and</li>
<li>the poles and knots tables in that parametric direction can be considered as infinite tables, such that: Knot(i+k) = Knot(i) + period, and Pole(i+p) = Pole(i) Note: The data structure tables for a periodic BSpline surface are more complex than those of a non-periodic one. References : . A survey of curve and surface methods in CADG Wolfgang BOHM CAGD 1 (1984) . On de Boor-like algorithms and blossoming Wolfgang BOEHM cagd 5 (1988) . Blossoming and knot insertion algorithms for B-spline curves Ronald N. GOLDMAN . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA . Curves and Surfaces for Computer Aided Geometric Design, a practical guide Gerald Farin </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2cceaf7bab6ce3a234166ebbd9671f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cceaf7bab6ce3a234166ebbd9671f6e">&#9670;&nbsp;</a></span>Geom_BSplineSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Geom_BSplineSurface::Geom_BSplineSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>Poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>UKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>VKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>UMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>VMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>UPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>VPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-rational b-spline surface (weights default value is 1.). The following conditions must be verified. 0 &lt; UDegree &lt;= MaxDegree. UKnots.Length() == UMults.Length() &gt;= 2 UKnots(i) &lt; UKnots(i+1) (Knots are increasing) 1 &lt;= UMults(i) &lt;= UDegree On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). On a uperiodic surface the first and the last umultiplicities must be the same. on non-uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 &gt;= 2 on uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) except the first or last The previous conditions for U holds also for V, with the RowLength of the poles. </p>

</div>
</div>
<a id="a4ccceccdf053e7164b6a6ac38251b709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccceccdf053e7164b6a6ac38251b709">&#9670;&nbsp;</a></span>Geom_BSplineSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Geom_BSplineSurface::Geom_BSplineSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>Poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>UKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>VKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>UMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>VMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>UPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>VPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-rational b-spline surface (weights default value is 1.). </p>
<p>The following conditions must be verified. 0 &lt; UDegree &lt;= MaxDegree.</p>
<p>UKnots.Length() == UMults.Length() &gt;= 2</p>
<p>UKnots(i) &lt; UKnots(i+1) (Knots are increasing) 1 &lt;= UMults(i) &lt;= UDegree</p>
<p>On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole).</p>
<p>On a uperiodic surface the first and the last umultiplicities must be the same.</p>
<p>on non-uperiodic surfaces</p>
<p>Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 &gt;= 2</p>
<p>on uperiodic surfaces</p>
<p>Poles.ColLength() == Sum(UMults(i)) except the first or last</p>
<p>The previous conditions for U holds also for V, with the RowLength of the poles. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b8e46390a662f9bf47773b0d193f469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8e46390a662f9bf47773b0d193f469">&#9670;&nbsp;</a></span>Bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parametric bounds of the surface. Warnings : These parametric values are the bounds of the array of knots UKnots and VKnots only if the first knots and the last knots have a multiplicity equal to UDegree + 1 or VDegree + 1. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a8a331ff3930c2da125ee1c03008664b1">Geom_Surface</a>.</p>

</div>
</div>
<a id="a0b60068f4332301ac697ebaf85663aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b60068f4332301ac697ebaf85663aae">&#9670;&nbsp;</a></span>CheckAndSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::CheckAndSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>theUTolerance</em> = <code><a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>theVTolerance</em> = <code><a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. </p>
<p>same as <a class="el" href="struct_segment.html">Segment</a> but do nothing if U1 and U2 (resp. V1 and V2) are equal to the bounds in U (resp. in V) of &lt;me&gt;. For example, if &lt;me&gt; is periodic in V, it will be always periodic in V after the segmentation if the bounds in V are unchanged</p>
<p>Parameters theUTolerance, theVTolerance define the possible proximity along the correponding direction of the segment boundaries and B-spline knots to treat them as equal.</p>
<p>Warnings : Even if &lt;me&gt; is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the surface &lt;me&gt; or if the surface makes loop. raises if U2 &lt; U1 or V2 &lt; V1. Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces. i.e. ((U2 - U1) - UPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>. Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces. i.e. ((V2 - V1) - VPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>). </p>

</div>
</div>
<a id="aa7893d9e0176410681dee0e305444d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7893d9e0176410681dee0e305444d2f">&#9670;&nbsp;</a></span>Continuity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_geom_abs___shape_8hxx.html#a943632453b69386bece6c091156b1ed5">GeomAbs_Shape</a> Geom_BSplineSurface::Continuity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the continuity of the surface : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Surface, C2 : continuity of the second derivative all along the Surface, C3 : continuity of the third derivative all along the Surface, CN : the order of continuity is infinite. A B-spline surface is infinitely continuously differentiable for the couple of parameters U, V such thats U != UKnots(i) and V != VKnots(i). The continuity of the surface at a knot value depends on the multiplicity of this knot. Example : If the surface is C1 in the V direction and C2 in the U direction this function returns Shape = C1. </p>

<p>Implements <a class="el" href="class_geom___surface.html#affd0e9fefab9d523254b4a6cb4ab3759">Geom_Surface</a>.</p>

</div>
</div>
<a id="a2ee38dd5e7647bd35bc445058f3c9b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee38dd5e7647bd35bc445058f3c9b12">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt; Geom_BSplineSurface::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object which is a copy of this BSpline surface. </p>

<p>Implements <a class="el" href="class_geom___geometry.html#a6ed956ee06a1003c931f27231b6a99ba">Geom_Geometry</a>.</p>

</div>
</div>
<a id="a07177b7b6518b51648d597c8b32232a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07177b7b6518b51648d597c8b32232a2">&#9670;&nbsp;</a></span>D0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the point of parameter U,V on the surface. </p>
<p>Raised only for an "OffsetSurface" if it is not possible to compute the current point. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ac5b495f5de52a893d9c490efa465e933">Geom_Surface</a>.</p>

</div>
</div>
<a id="a98631e40889c2a56c3e6eacff5279a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98631e40889c2a56c3e6eacff5279a0b">&#9670;&nbsp;</a></span>D1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raised if the continuity of the surface is not C1. </p>

<p>Implements <a class="el" href="class_geom___surface.html#afdd522a8a675b0f0b59a9ee2187f73bd">Geom_Surface</a>.</p>

</div>
</div>
<a id="a209fd5b7c659ef9ac0cecfb1454c91f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209fd5b7c659ef9ac0cecfb1454c91f5">&#9670;&nbsp;</a></span>D2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raised if the continuity of the surface is not C2. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ad3aca908acdeae39d846899971848da3">Geom_Surface</a>.</p>

</div>
</div>
<a id="a1dbdf61c1beabe26f98feee4c93bb457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbdf61c1beabe26f98feee4c93bb457">&#9670;&nbsp;</a></span>D3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raised if the continuity of the surface is not C3. </p>

<p>Implements <a class="el" href="class_geom___surface.html#aeebbc20a3bf2b97bc903ea23d54a7fc0">Geom_Surface</a>.</p>

</div>
</div>
<a id="a4ca74b92f4d3b9fba78095a4731992ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca74b92f4d3b9fba78095a4731992ee">&#9670;&nbsp;</a></span>DN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___vec.html">gp_Vec</a> Geom_BSplineSurface::DN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nu is the order of derivation in the U parametric direction and Nv is the order of derivation in the V parametric direction. </p>
<p>Raised if the continuity of the surface is not CNu in the U direction and CNv in the V direction.</p>
<p>Raised if Nu + Nv &lt; 1 or Nu &lt; 0 or Nv &lt; 0.</p>
<p>The following functions computes the point for the parametric values (U, V) and the derivatives at this point on the B-spline surface patch delimited with the knots FromUK1, FromVK1 and the knots ToUK2, ToVK2. (U, V) can be out of these parametric bounds but for the computation we only use the definition of the surface between these knots. This method is useful to compute local derivative, if the order of continuity of the whole surface is not greater enough. Inside the parametric knot's domain previously defined the evaluations are the same as if we consider the whole definition of the surface. Of course the evaluations are different outside this parametric domain. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a0d733bd9ae23f35251c688489717c1b4">Geom_Surface</a>.</p>

</div>
</div>
<a id="aafa7cb8c9a667e9afa729fa388b0f6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa7cb8c9a667e9afa729fa388b0f6c6">&#9670;&nbsp;</a></span>ExchangeUV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::ExchangeUV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the u and v parametric directions on this BSpline surface. As a consequence: </p>
<ul>
<li>the poles and weights tables are transposed,</li>
<li>the knots and multiplicities tables are exchanged,</li>
<li>degrees of continuity, and rational, periodic and uniform characteristics are exchanged, and</li>
<li>the orientation of the surface is inverted. </li>
</ul>

</div>
</div>
<a id="a1aeffb1ea838e6044afc58c3120b5790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeffb1ea838e6044afc58c3120b5790">&#9670;&nbsp;</a></span>FirstUKnotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::FirstUKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the UKnots which gives the first parametric value of the surface in the U direction. The UIso curve corresponding to this value is a boundary curve of the surface. </p>

</div>
</div>
<a id="ae4fa6a5fa15d98e768a8ecd11dd4dfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fa6a5fa15d98e768a8ecd11dd4dfe8">&#9670;&nbsp;</a></span>FirstVKnotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::FirstVKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the VKnots which gives the first parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface. </p>

</div>
</div>
<a id="a1518b83991ee2eea82617ffcb61b6125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1518b83991ee2eea82617ffcb61b6125">&#9670;&nbsp;</a></span>IncreaseDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VDegree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the degrees of this BSpline surface to UDegree and VDegree in the u and v parametric directions respectively. As a result, the tables of poles, weights and multiplicities are modified. The tables of knots is not changed. Note: Nothing is done if the given degree is less than or equal to the current degree in the corresponding parametric direction. Exceptions Standard_ConstructionError if UDegree or VDegree is greater than <a class="el" href="class_geom___b_spline_surface.html#ac1496de7ea0d7268ee94ba738c61dd0e" title="Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v dir...">Geom_BSplineSurface::MaxDegree()</a>. </p>

</div>
</div>
<a id="a89f7df653df09054582143a163655682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f7df653df09054582143a163655682">&#9670;&nbsp;</a></span>IncreaseUMultiplicity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseUMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the multiplicity of the knot of range UIndex in the UKnots sequence. M is the new multiplicity. M must be greater than the previous multiplicity and lower or equal to the degree of the surface in the U parametric direction. Raised if M is not in the range [1, UDegree]. </p>
<p>Raised if UIndex is not in the range [FirstUKnotIndex, LastUKnotIndex] given by the methods with the same name. </p>

</div>
</div>
<a id="a2e1bace85d54741492dfbeb8620d87b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1bace85d54741492dfbeb8620d87b3">&#9670;&nbsp;</a></span>IncreaseUMultiplicity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseUMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the U direction. This method can be used to make a B_spline surface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non uniform. </p>
<p>Raised if FromI1 or ToI2 is out of the range [FirstUKnotIndex, LastUKnotIndex].</p>
<p>M should be greater than the previous multiplicity of the all the knots FromI1,..., ToI2 and lower or equal to the Degree of the surface in the U parametric direction. </p>

</div>
</div>
<a id="ac0038875c69a1f5d9cea7a1658b50960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0038875c69a1f5d9cea7a1658b50960">&#9670;&nbsp;</a></span>IncreaseVMultiplicity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseVMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the multiplicity of a knot in the V direction. M is the new multiplicity. </p>
<p>M should be greater than the previous multiplicity and lower than the degree of the surface in the V parametric direction.</p>
<p>Raised if VIndex is not in the range [FirstVKnotIndex, LastVKnotIndex] given by the methods with the same name. </p>

</div>
</div>
<a id="a265fe70c543a2126a9a6a8e9e0f599c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265fe70c543a2126a9a6a8e9e0f599c4">&#9670;&nbsp;</a></span>IncreaseVMultiplicity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseVMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the V direction. This method can be used to make a BSplineSurface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non-uniform. </p>
<p>Raised if FromI1 or ToI2 is out of the range [FirstVKnotIndex, LastVKnotIndex] given by the methods with the same name.</p>
<p>M should be greater than the previous multiplicity of the all the knots FromI1,..., ToI2 and lower or equal to the Degree of the surface in the V parametric direction. </p>

</div>
</div>
<a id="a53653996a730f05b0d43429646555f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53653996a730f05b0d43429646555f71">&#9670;&nbsp;</a></span>IncrementUMultiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncrementUMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the multiplicity of the consecutives uknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the UDegree of the B_spline. </p>
<p>Raised if FromI1 or ToI2 is not in the range [FirstUKnotIndex, LastUKnotIndex]</p>
<p>Raised if one knot has a multiplicity greater than UDegree. </p>

</div>
</div>
<a id="a90604191893bb2dc3bca30b3447aa8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90604191893bb2dc3bca30b3447aa8bb">&#9670;&nbsp;</a></span>IncrementVMultiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncrementVMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the multiplicity of the consecutives vknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the VDegree of the B_spline. </p>
<p>Raised if FromI1 or ToI2 is not in the range [FirstVKnotIndex, LastVKnotIndex]</p>
<p>Raised if one knot has a multiplicity greater than VDegree. </p>

</div>
</div>
<a id="abd4b07416d5e8d9a87f447e41cb477fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4b07416d5e8d9a87f447e41cb477fb">&#9670;&nbsp;</a></span>InsertUKnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a knot value in the sequence of UKnots. If U is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M else it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp. </p>
<p>Raised if U is out of the bounds [U1, U2] given by the methods Bounds, the criterion ParametricTolerance is used. Raised if M is not in the range [1, UDegree]. </p>

</div>
</div>
<a id="a99eabcf868d4a08c60eeac5913b96095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eabcf868d4a08c60eeac5913b96095">&#9670;&nbsp;</a></span>InsertUKnots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertUKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts into the knots table for the U parametric direction of this BSpline surface: </p>
<ul>
<li>the values of the array Knots, with their respective multiplicities, Mults. If the knot value to insert already exists in the table, its multiplicity is:</li>
<li>increased by M, if Add is true (the default), or</li>
<li>increased to M, if Add is false. The tolerance criterion used to check the equality of the knots is the larger of the values ParametricTolerance and Standard_Real::Epsilon(val), where val is the knot value to be inserted. Warning</li>
<li>If a given multiplicity coefficient is null, or negative, nothing is done.</li>
<li>The new multiplicity of a knot is limited to the degree of this BSpline surface in the corresponding parametric direction. Exceptions Standard_ConstructionError if a knot value to insert is outside the bounds of this BSpline surface in the specified parametric direction. The comparison uses the precision criterion ParametricTolerance. </li>
</ul>

</div>
</div>
<a id="a1695d16dec722f5ee1cef55b980e95a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1695d16dec722f5ee1cef55b980e95a1">&#9670;&nbsp;</a></span>InsertVKnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a knot value in the sequence of VKnots. If V is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M otherwise it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp. </p>
<p>raises if V is out of the Bounds [V1, V2] given by the methods Bounds, the criterion ParametricTolerance is used. raises if M is not in the range [1, VDegree]. </p>

</div>
</div>
<a id="ab0cec108eb6a0e03fc0548be17fd0692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cec108eb6a0e03fc0548be17fd0692">&#9670;&nbsp;</a></span>InsertVKnots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertVKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts into the knots table for the V parametric direction of this BSpline surface: </p>
<ul>
<li>the values of the array Knots, with their respective multiplicities, Mults. If the knot value to insert already exists in the table, its multiplicity is:</li>
<li>increased by M, if Add is true (the default), or</li>
<li>increased to M, if Add is false. The tolerance criterion used to check the equality of the knots is the larger of the values ParametricTolerance and Standard_Real::Epsilon(val), where val is the knot value to be inserted. Warning</li>
<li>If a given multiplicity coefficient is null, or negative, nothing is done.</li>
<li>The new multiplicity of a knot is limited to the degree of this BSpline surface in the corresponding parametric direction. Exceptions Standard_ConstructionError if a knot value to insert is outside the bounds of this BSpline surface in the specified parametric direction. The comparison uses the precision criterion ParametricTolerance. </li>
</ul>

</div>
</div>
<a id="a844b2bb688eb5c9db39cf72856f461b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844b2bb688eb5c9db39cf72856f461b9">&#9670;&nbsp;</a></span>IsCNu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsCNu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the order of continuity of the surface in the U direction is N. Raised if N &lt; 0. </p>

<p>Implements <a class="el" href="class_geom___surface.html#aa5530f84863e56c6ebf908f3bae55178">Geom_Surface</a>.</p>

</div>
</div>
<a id="a954d178310ce1b8db20287db9844aacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954d178310ce1b8db20287db9844aacf">&#9670;&nbsp;</a></span>IsCNv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsCNv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the order of continuity of the surface in the V direction is N. Raised if N &lt; 0. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ab95163f54a0e2110873c62241dd4f1c5">Geom_Surface</a>.</p>

</div>
</div>
<a id="aa6cc2ecc094017a734d43a203356d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cc2ecc094017a734d43a203356d655">&#9670;&nbsp;</a></span>IsUClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsUClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first control points row and the last control points row are identical. The tolerance criterion is Resolution from package gp. </p>

<p>Implements <a class="el" href="class_geom___surface.html#af19a3402429c4133c86dac00789c55a0">Geom_Surface</a>.</p>

</div>
</div>
<a id="a92a47c005dd3b371c091b905165dc5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a47c005dd3b371c091b905165dc5e3">&#9670;&nbsp;</a></span>IsUPeriodic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsUPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the surface is closed in the U direction and if the B-spline has been turned into a periodic surface using the function SetUPeriodic. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ac26ac42d048250c92f1ac7f026f418d8">Geom_Surface</a>.</p>

</div>
</div>
<a id="a22ddaa964dfe4bea26fde59271ce3e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ddaa964dfe4bea26fde59271ce3e75">&#9670;&nbsp;</a></span>IsURational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsURational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns False if for each row of weights all the weights are identical. The tolerance criterion is resolution from package gp. Example : |1.0, 1.0, 1.0| if Weights = |0.5, 0.5, 0.5| returns False |2.0, 2.0, 2.0|. </p>

</div>
</div>
<a id="a784954ca35462143b660ac80a703b13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784954ca35462143b660ac80a703b13e">&#9670;&nbsp;</a></span>IsVClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsVClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first control points column and the last last control points column are identical. The tolerance criterion is Resolution from package gp. </p>

<p>Implements <a class="el" href="class_geom___surface.html#af190e75d819100823c16d81d7bd1dd50">Geom_Surface</a>.</p>

</div>
</div>
<a id="aaa4dda9bd4ca1139f372489b95ddc0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4dda9bd4ca1139f372489b95ddc0cb">&#9670;&nbsp;</a></span>IsVPeriodic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsVPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the surface is closed in the V direction and if the B-spline has been turned into a periodic surface using the function SetVPeriodic. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a95a2dcb52c0e4521a1805eabf95dbae6">Geom_Surface</a>.</p>

</div>
</div>
<a id="a3676c7e01eb23c66f419769f03e1541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3676c7e01eb23c66f419769f03e1541c">&#9670;&nbsp;</a></span>IsVRational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::IsVRational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns False if for each column of weights all the weights are identical. The tolerance criterion is resolution from package gp. Examples : |1.0, 2.0, 0.5| if Weights = |1.0, 2.0, 0.5| returns False |1.0, 2.0, 0.5|. </p>

</div>
</div>
<a id="a8a38bbb34e4e22552ef951c2588083e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a38bbb34e4e22552ef951c2588083e3">&#9670;&nbsp;</a></span>LastUKnotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::LastUKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the UKnots which gives the last parametric value of the surface in the U direction. The UIso curve corresponding to this knot is a boundary curve of the surface. </p>

</div>
</div>
<a id="a03285118bbcc29ba75e3f017bf2dab12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03285118bbcc29ba75e3f017bf2dab12">&#9670;&nbsp;</a></span>LastVKnotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::LastVKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the VKnots which gives the last parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface. </p>

</div>
</div>
<a id="a94e64fe9e6d20c8fc4d0f2a58602a1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e64fe9e6d20c8fc4d0f2a58602a1c8">&#9670;&nbsp;</a></span>LocalD0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a id="a4a69ff7fd3bf66b4aa06a9b1d586d81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a69ff7fd3bf66b4aa06a9b1d586d81b">&#9670;&nbsp;</a></span>LocalD1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not C1 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a id="a277d0312549205f85aaaab4b493b538d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277d0312549205f85aaaab4b493b538d">&#9670;&nbsp;</a></span>LocalD2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not C2 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a id="a8b50af58054e2a18b5631eea2aac4846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b50af58054e2a18b5631eea2aac4846">&#9670;&nbsp;</a></span>LocalD3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not C3 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a id="a7fd35a090b1e3153399d11d718f01091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd35a090b1e3153399d11d718f01091">&#9670;&nbsp;</a></span>LocalDN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___vec.html">gp_Vec</a> Geom_BSplineSurface::LocalDN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not CNu between the knots FromUK1, ToUK2 and CNv between the knots FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a id="a922b68f08f1c87ba50d377dd35d8cbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922b68f08f1c87ba50d377dd35d8cbe1">&#9670;&nbsp;</a></span>LocalValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___pnt.html">gp_Pnt</a> Geom_BSplineSurface::LocalValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point of parameter U, V on the BSpline surface patch defines between the knots UK1 UK2, VK1, VK2. U can be out of the bounds [Knot UK1, Knot UK2] and V can be outof the bounds [Knot VK1, Knot VK2] but for the computation we only use the definition of the surface between these knot values. Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a id="a84bd815cbc497fc6a76c788c96950454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bd815cbc497fc6a76c788c96950454">&#9670;&nbsp;</a></span>LocateU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocateU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>WithKnotRepetition</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the parametric value U in the sequence of UKnots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. UKnots (I1) &lt;= U &lt;= UKnots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; U &lt; UKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbUKnots =&gt; U &gt; UKnots(NbUKnots)+Abs(ParametricTolerance) </p>

</div>
</div>
<a id="a236061bafa89740d15aa2c76eac73b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236061bafa89740d15aa2c76eac73b07">&#9670;&nbsp;</a></span>LocateV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocateV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>WithKnotRepetition</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the parametric value V in the sequence of knots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. VKnots (I1) &lt;= V &lt;= VKnots (I2) . if I1 = I2 V is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; V &lt; VKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbVKnots =&gt; V &gt; VKnots(NbVKnots)+Abs(ParametricTolerance) poles insertion and removing The following methods are available only if the surface is Uniform or QuasiUniform in the considered direction The knot repartition is modified. </p>

</div>
</div>
<a id="ac1496de7ea0d7268ee94ba738c61dd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1496de7ea0d7268ee94ba738c61dd0e">&#9670;&nbsp;</a></span>MaxDegree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::MaxDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v directions. </p>

</div>
</div>
<a id="a914512eca1f25878577aee7499a2583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914512eca1f25878577aee7499a2583b">&#9670;&nbsp;</a></span>MovePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::MovePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>UFirstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>ULastIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>VFirstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>VLastIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a point with parameter U and V to P. given u,v as parameters) to reach a new position UIndex1, UIndex2, VIndex1, VIndex2: indicates the poles which can be moved if Problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0. </p>
<p>Raised if UIndex1 &lt; UIndex2 or VIndex1 &lt; VIndex2 or UIndex1 &lt; 1 || UIndex1 &gt; NbUPoles or UIndex2 &lt; 1 || UIndex2 &gt; NbUPoles VIndex1 &lt; 1 || VIndex1 &gt; NbVPoles or VIndex2 &lt; 1 || VIndex2 &gt; NbVPoles characteristics of the surface </p>

</div>
</div>
<a id="aeb9f2b3403c270690df304de2e5488b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9f2b3403c270690df304de2e5488b2">&#9670;&nbsp;</a></span>NbUKnots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbUKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of knots in the U direction. </p>

</div>
</div>
<a id="a62407b2e3da408f98963d4431a4dd5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62407b2e3da408f98963d4431a4dd5b2">&#9670;&nbsp;</a></span>NbUPoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbUPoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of poles in the U direction. </p>

</div>
</div>
<a id="a93f695247eecd1be92f0100c881329a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f695247eecd1be92f0100c881329a1">&#9670;&nbsp;</a></span>NbVKnots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbVKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of knots in the V direction. </p>

</div>
</div>
<a id="a4124728ffd7e288f05efccd3023f1f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4124728ffd7e288f05efccd3023f1f89">&#9670;&nbsp;</a></span>NbVPoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbVPoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of poles in the V direction. </p>

</div>
</div>
<a id="a4c4358e949b42ba536d9f5011df35037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4358e949b42ba536d9f5011df35037">&#9670;&nbsp;</a></span>PeriodicNormalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::PeriodicNormalization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the parameter normalized within the period if the surface is periodic : otherwise does not do anything </p>

</div>
</div>
<a id="a7bd7da6d45b7f158a453c9f4d9c7abea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd7da6d45b7f158a453c9f4d9c7abea">&#9670;&nbsp;</a></span>Pole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgp___pnt.html">gp_Pnt</a>&amp; Geom_BSplineSurface::Pole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the pole of range (UIndex, VIndex). </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. </p>

</div>
</div>
<a id="acca9beddb794fad2a9183473dfcb6b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca9beddb794fad2a9183473dfcb6b55">&#9670;&nbsp;</a></span>Poles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Poles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the poles of the B-spline surface. </p>
<p>Raised if the length of P in the U and V direction is not equal to NbUpoles and NbVPoles. </p>

</div>
</div>
<a id="a01062bdfde3c59ecc0682e6f1c2432ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01062bdfde3c59ecc0682e6f1c2432ac">&#9670;&nbsp;</a></span>Poles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a>&amp; Geom_BSplineSurface::Poles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the poles of the B-spline surface. </p>

</div>
</div>
<a id="a392ae7d2d902abef64aa61e4a04d0b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392ae7d2d902abef64aa61e4a04d0b63">&#9670;&nbsp;</a></span>RemoveUKnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::RemoveUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces to M the multiplicity of the knot of index Index in the U parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface. </p>

</div>
</div>
<a id="abba2001d928b071ceb0b5847ea56e74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba2001d928b071ceb0b5847ea56e74c">&#9670;&nbsp;</a></span>RemoveVKnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Geom_BSplineSurface::RemoveVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces to M the multiplicity of the knot of index Index in the V parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface. </p>

</div>
</div>
<a id="a86e184acbeca9bf93faf8ed888d37e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e184acbeca9bf93faf8ed888d37e1e">&#9670;&nbsp;</a></span>Resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Resolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Tolerance3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>UTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>VTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes two tolerance values for this BSpline surface, based on the given tolerance in 3D space Tolerance3D. The tolerances computed are: </p>
<ul>
<li>UTolerance in the u parametric direction, and</li>
<li>VTolerance in the v parametric direction. If f(u,v) is the equation of this BSpline surface, UTolerance and VTolerance guarantee that : | u1 - u0 | &lt; UTolerance and | v1 - v0 | &lt; VTolerance ====&gt; |f (u1,v1) - f (u0,v0)| &lt; Tolerance3D </li>
</ul>

</div>
</div>
<a id="a25d182b275cba4fd24058caea4f9c6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d182b275cba4fd24058caea4f9c6f9">&#9670;&nbsp;</a></span>Segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>theUTolerance</em> = <code><a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>theVTolerance</em> = <code><a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">Precision::PConfusion</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same. </p>
<p>Parameters theUTolerance, theVTolerance define the possible proximity along the correponding direction of the segment boundaries and B-spline knots to treat them as equal.</p>
<p>Warnings : Even if &lt;me&gt; is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the surface &lt;me&gt; or if the surface makes loop. raises if U2 &lt; U1 or V2 &lt; V1. Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces. i.e. ((U2 - U1) - UPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>. Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces. i.e. ((V2 - V1) - VPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>). </p>

</div>
</div>
<a id="a0dc8418edec13c452e97feca0a8baffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc8418edec13c452e97feca0a8baffb">&#9670;&nbsp;</a></span>segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>EpsU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>EpsV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>SegmentInU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>SegmentInV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same. </p>
<p>Parameters EpsU, EpsV define the proximity along U-Direction and V-Direction respectively. </p>

</div>
</div>
<a id="a25d65634d8c16cf435ca655cba8a7c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d65634d8c16cf435ca655cba8a7c50">&#9670;&nbsp;</a></span>SetPole() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the pole of range (UIndex, VIndex) with P. If the surface is rational the weight of range (UIndex, VIndex) is not modified. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. </p>

</div>
</div>
<a id="a4f15b262382cf0993d3f68e006a2475c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f15b262382cf0993d3f68e006a2475c">&#9670;&nbsp;</a></span>SetPole() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the pole and the weight of range (UIndex, VIndex) with P and W. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. Raised if Weight &lt;= Resolution from package gp. </p>

</div>
</div>
<a id="aacf9582ad0b35728f241da3a05240501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf9582ad0b35728f241da3a05240501">&#9670;&nbsp;</a></span>SetPoleCol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a column of poles or a part of this column. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbUPoles. </p>

</div>
</div>
<a id="a4f72b47dc1ef861bc0d8181dfcfa3295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f72b47dc1ef861bc0d8181dfcfa3295">&#9670;&nbsp;</a></span>SetPoleCol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a column of poles or a part of this column with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbUPoles Raised if the bounds of CPoleWeights are not the same as the bounds of CPoles. Raised if one of the weight value of CPoleWeights is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a id="a93f66596b553b9f191350b8e4d700323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f66596b553b9f191350b8e4d700323">&#9670;&nbsp;</a></span>SetPoleRow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a row of poles or a part of this row with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbVPoles raises if the bounds of CPoleWeights are not the same as the bounds of CPoles. Raised if one of the weight value of CPoleWeights is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a id="aff1784d238248031bb52c51bdd46a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1784d238248031bb52c51bdd46a5cf">&#9670;&nbsp;</a></span>SetPoleRow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a row of poles or a part of this row. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbVPoles. </p>

</div>
</div>
<a id="abad798e54698ffb43903d5716ae0cee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad798e54698ffb43903d5716ae0cee6">&#9670;&nbsp;</a></span>SetUKnot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the UKnots of range UIndex with K. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots</p>
<p>Raised if K &gt;= UKnots(UIndex+1) or K &lt;= UKnots(UIndex-1) </p>

</div>
</div>
<a id="a739cf8b82973158284e38f9ab75fdfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739cf8b82973158284e38f9ab75fdfce">&#9670;&nbsp;</a></span>SetUKnot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value of the UKnots of range UIndex and increases its multiplicity. </p>
<p>Raised if UIndex is not in the range [FirstUKnotIndex, LastUKnotIndex] given by the methods with the same name.</p>
<p>Raised if K &gt;= UKnots(UIndex+1) or K &lt;= UKnots(UIndex-1) M must be lower than UDegree and greater than the previous multiplicity of the knot of range UIndex. </p>

</div>
</div>
<a id="a7e744c1a00c58eed3f992caba7d1668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e744c1a00c58eed3f992caba7d1668a">&#9670;&nbsp;</a></span>SetUKnots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>UK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all the U-knots of the surface. The multiplicity of the knots are not modified. </p>
<p>Raised if there is an index such that UK (Index+1) &lt;= UK (Index).</p>
<p>Raised if UK.Lower() &lt; 1 or UK.Upper() &gt; NbUKnots </p>

</div>
</div>
<a id="ac90ee06d28faf0e7992b4745ff6afbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90ee06d28faf0e7992b4745ff6afbb0">&#9670;&nbsp;</a></span>SetUNotPeriodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUNotPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface U not periodic. Changes this BSpline surface into a non-periodic surface along U direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified. </p>

</div>
</div>
<a id="adb456214cd15f2d60c1937fcd67bb967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb456214cd15f2d60c1937fcd67bb967">&#9670;&nbsp;</a></span>SetUOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction. </p>

</div>
</div>
<a id="aa0b39ea036cefa180705348855e68e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b39ea036cefa180705348855e68e78">&#9670;&nbsp;</a></span>SetUPeriodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface U periodic. Modifies this surface to be periodic in the U parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction. </p>

</div>
</div>
<a id="afe5f7237bcab9e4186b958668f951913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5f7237bcab9e4186b958668f951913">&#9670;&nbsp;</a></span>SetVKnot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the VKnots of range VIndex with K. </p>
<p>Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots</p>
<p>Raised if K &gt;= VKnots(VIndex+1) or K &lt;= VKnots(VIndex-1) </p>

</div>
</div>
<a id="a54e4111066ef4b2a33a62d345934a1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e4111066ef4b2a33a62d345934a1ea">&#9670;&nbsp;</a></span>SetVKnot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value of the VKnots of range VIndex and increases its multiplicity. </p>
<p>Raised if VIndex is not in the range [FirstVKnotIndex, LastVKnotIndex] given by the methods with the same name.</p>
<p>Raised if K &gt;= VKnots(VIndex+1) or K &lt;= VKnots(VIndex-1) M must be lower than VDegree and greater than the previous multiplicity of the knot of range VIndex. </p>

</div>
</div>
<a id="a84e3a15de8c8c282b6e264122a829e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e3a15de8c8c282b6e264122a829e0c">&#9670;&nbsp;</a></span>SetVKnots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>VK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all the V-knots of the surface. The multiplicity of the knots are not modified. </p>
<p>Raised if there is an index such that VK (Index+1) &lt;= VK (Index).</p>
<p>Raised if VK.Lower() &lt; 1 or VK.Upper() &gt; NbVKnots </p>

</div>
</div>
<a id="af335087f0d79b4fbaf141b50f6e46f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af335087f0d79b4fbaf141b50f6e46f2b">&#9670;&nbsp;</a></span>SetVNotPeriodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVNotPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface V not periodic. Changes this BSpline surface into a non-periodic surface along V direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified. </p>

</div>
</div>
<a id="ade5ff76aa0fb4ea90203db02da110fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ff76aa0fb4ea90203db02da110fc2">&#9670;&nbsp;</a></span>SetVOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction. </p>

</div>
</div>
<a id="a1376ba80d7503a1519c35ee8fadfa2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1376ba80d7503a1519c35ee8fadfa2c2">&#9670;&nbsp;</a></span>SetVPeriodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface V periodic. Modifies this surface to be periodic in the V parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstVKnotIndex and LastVKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction. </p>

</div>
</div>
<a id="a387528d50fb7fe2abeef279e7a8aae86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387528d50fb7fe2abeef279e7a8aae86">&#9670;&nbsp;</a></span>SetWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the weight of the pole of range UIndex, VIndex. If the surface was non rational it can become rational. If the surface was rational it can become non rational. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles</p>
<p>Raised if weight is lower or equal to Resolution from package gp </p>

</div>
</div>
<a id="a921397a82aed03feae72dd0f73dc823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921397a82aed03feae72dd0f73dc823e">&#9670;&nbsp;</a></span>SetWeightCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetWeightCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a column of weights of a part of this column. </p>
<p>Raised if VIndex &lt; 1 or VIndex &gt; NbVPoles</p>
<p>Raised if CPoleWeights.Lower() &lt; 1 or CPoleWeights.Upper() &gt; NbUPoles. Raised if a weight value is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a id="a1d9e2900caa95bf15c02124b1d4f115b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9e2900caa95bf15c02124b1d4f115b">&#9670;&nbsp;</a></span>SetWeightRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetWeightRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a row of weights or a part of this row. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles</p>
<p>Raised if CPoleWeights.Lower() &lt; 1 or CPoleWeights.Upper() &gt; NbVPoles. Raised if a weight value is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a id="a8d26b8258d892130a39c05f119401fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d26b8258d892130a39c05f119401fea">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the transformation T to this BSpline surface. </p>

<p>Implements <a class="el" href="class_geom___geometry.html#a480bcb8e7ce3be50e592e692592f604a">Geom_Geometry</a>.</p>

</div>
</div>
<a id="af450e43303facf90afbeb7adafc1da50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af450e43303facf90afbeb7adafc1da50">&#9670;&nbsp;</a></span>UDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::UDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the degree of the normalized B-splines Ni,n in the U direction. </p>

</div>
</div>
<a id="a5810d15efc667b89905125a5cd0726b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5810d15efc667b89905125a5cd0726b0">&#9670;&nbsp;</a></span>UIso() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::UIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the U isoparametric curve. A B-spline curve is returned. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ad015857909168877ae707eb6db15e0ce">Geom_Surface</a>.</p>

</div>
</div>
<a id="a7959a4cb8247a2a6c8d4f057d83163d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7959a4cb8247a2a6c8d4f057d83163d7">&#9670;&nbsp;</a></span>UIso() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::UIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>CheckRational</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the U isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. </p>

</div>
</div>
<a id="acb476a0f1935c574be3d11bc3cf7b886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb476a0f1935c574be3d11bc3cf7b886">&#9670;&nbsp;</a></span>UKnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::UKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Knot value of range UIndex. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots. </p>

</div>
</div>
<a id="a110d56a72f988aaeae3f26c01cd54bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110d56a72f988aaeae3f26c01cd54bbd">&#9670;&nbsp;</a></span>UKnotDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a> Geom_BSplineSurface::UKnotDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the U direction the B-spline surface can be : </p>
<ul>
<li>Uniform if all the knots are of multiplicity 1,</li>
<li>QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1,</li>
<li>PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree otherwise the surface is non uniform in the U direction The tolerance criterion is Resolution from package gp. </li>
</ul>

</div>
</div>
<a id="a797314c1a4f7bdccdedb8a90e494f68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797314c1a4f7bdccdedb8a90e494f68e">&#9670;&nbsp;</a></span>UKnots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UKnots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Ku</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the U direction. </p>
<p>Raised if the length of Ku is not equal to the number of knots in the U direction. </p>

</div>
</div>
<a id="a51a82908fd062a50c03830b65226ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a82908fd062a50c03830b65226ff65">&#9670;&nbsp;</a></span>UKnots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::UKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the U direction. </p>

</div>
</div>
<a id="a899a341022ecbc07e2cf9766f6a0af30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899a341022ecbc07e2cf9766f6a0af30">&#9670;&nbsp;</a></span>UKnotSequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UKnotSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Ku</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>
<p>Raised if the length of Ku is not equal to NbUPoles + UDegree + 1 </p>

</div>
</div>
<a id="a1f6d40901201fb4bdecee7300fd5d347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6d40901201fb4bdecee7300fd5d347">&#9670;&nbsp;</a></span>UKnotSequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::UKnotSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>

</div>
</div>
<a id="afacba292d660e62afe44f343985b9429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacba292d660e62afe44f343985b9429">&#9670;&nbsp;</a></span>UMultiplicities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UMultiplicities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mu</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the U direction. </p>
<p>Raised if the length of Mu is not equal to the number of knots in the U direction. </p>

</div>
</div>
<a id="a967289dad8894531fe6ede9c4e76e9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967289dad8894531fe6ede9c4e76e9d2">&#9670;&nbsp;</a></span>UMultiplicities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a>&amp; Geom_BSplineSurface::UMultiplicities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the U direction. </p>

</div>
</div>
<a id="a9d6409304c3ff4fb9f52761281f264ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6409304c3ff4fb9f52761281f264ca">&#9670;&nbsp;</a></span>UMultiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::UMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicity value of knot of range UIndex in the u direction. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots. </p>

</div>
</div>
<a id="aee0fcef877230439568db763810a1a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0fcef877230439568db763810a1a28">&#9670;&nbsp;</a></span>UReverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UReverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the orientation of this BSpline surface in the U parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a72049f8a81936e5d981c14cccb4504f5">Geom_Surface</a>.</p>

</div>
</div>
<a id="ac27422832e7a67f53e85ecba1ae4fe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27422832e7a67f53e85ecba1ae4fe36">&#9670;&nbsp;</a></span>UReversedParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::UReversedParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the u parameter on the modified surface, produced by reversing its U parametric direction, for the point of u parameter U, on this BSpline surface. For a BSpline surface, these functions return respectively: </p>
<ul>
<li>UFirst + ULast - U, where UFirst, ULast are the values of the first and last parameters of this BSpline surface, in the u parametric directions. </li>
</ul>

<p>Implements <a class="el" href="class_geom___surface.html#a075c45a13034659cd420cf539a4e3fa3">Geom_Surface</a>.</p>

</div>
</div>
<a id="a14183eb2a06b72c428047199bbb0d30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14183eb2a06b72c428047199bbb0d30b">&#9670;&nbsp;</a></span>VDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::VDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the degree of the normalized B-splines Ni,d in the V direction. </p>

</div>
</div>
<a id="a0975e8dfe3e9c01087cb353085d6aa30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0975e8dfe3e9c01087cb353085d6aa30">&#9670;&nbsp;</a></span>VIso() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::VIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the V isoparametric curve. A B-spline curve is returned. </p>

<p>Implements <a class="el" href="class_geom___surface.html#afa73ab63bcf84dc88f4c8cbd8c8a4197">Geom_Surface</a>.</p>

</div>
</div>
<a id="acd55537982ae78216b6ac3a26ee45390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd55537982ae78216b6ac3a26ee45390">&#9670;&nbsp;</a></span>VIso() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::VIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>CheckRational</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the V isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. transformations. </p>

</div>
</div>
<a id="ab1236c6ac22ad3b3ab4163c0bee1e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1236c6ac22ad3b3ab4163c0bee1e65e">&#9670;&nbsp;</a></span>VKnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::VKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Knot value of range VIndex. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots. </p>

</div>
</div>
<a id="a183a3e9e9a57856f306608a1e4c9b9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183a3e9e9a57856f306608a1e4c9b9e5">&#9670;&nbsp;</a></span>VKnotDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a> Geom_BSplineSurface::VKnotDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the V direction the B-spline surface can be : </p>
<ul>
<li>Uniform if all the knots are of multiplicity 1,</li>
<li>QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1,</li>
<li>PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree otherwise the surface is non uniform in the V direction. The tolerance criterion is Resolution from package gp. </li>
</ul>

</div>
</div>
<a id="abc42618b81f3c6a64d14782b8d813044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc42618b81f3c6a64d14782b8d813044">&#9670;&nbsp;</a></span>VKnots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VKnots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Kv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the V direction. </p>
<p>Raised if the length of Kv is not equal to the number of knots in the V direction. </p>

</div>
</div>
<a id="ad13671bb6137103911652fa91a653b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13671bb6137103911652fa91a653b79">&#9670;&nbsp;</a></span>VKnots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::VKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the V direction. </p>

</div>
</div>
<a id="a2d2f0f02c7db958f17590b373f1471fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2f0f02c7db958f17590b373f1471fc">&#9670;&nbsp;</a></span>VKnotSequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VKnotSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Kv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Kv = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>
<p>Raised if the length of Kv is not equal to NbVPoles + VDegree + 1 </p>

</div>
</div>
<a id="ab14e06a546cce306fd6a3cbb7900f8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14e06a546cce306fd6a3cbb7900f8bc">&#9670;&nbsp;</a></span>VKnotSequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::VKnotSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>

</div>
</div>
<a id="a7df5e8c10b3033cedd4b3d76e347517e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df5e8c10b3033cedd4b3d76e347517e">&#9670;&nbsp;</a></span>VMultiplicities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VMultiplicities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the V direction. </p>
<p>Raised if the length of Mv is not equal to the number of knots in the V direction. </p>

</div>
</div>
<a id="a846146f8ea033f4970cccf9c0a6af6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846146f8ea033f4970cccf9c0a6af6f5">&#9670;&nbsp;</a></span>VMultiplicities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a>&amp; Geom_BSplineSurface::VMultiplicities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the V direction. </p>

</div>
</div>
<a id="af7f3c1f35c02eeee6469adb6d0dc6155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f3c1f35c02eeee6469adb6d0dc6155">&#9670;&nbsp;</a></span>VMultiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::VMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicity value of knot of range VIndex in the v direction. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots. </p>

</div>
</div>
<a id="aeba4946263dde87c57e9aa6329625767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba4946263dde87c57e9aa6329625767">&#9670;&nbsp;</a></span>VReverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VReverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the orientation of this BSpline surface in the V parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified. </p>

<p>Implements <a class="el" href="class_geom___surface.html#aa2616fd0be00595e1c917a4a3fdbfdbc">Geom_Surface</a>.</p>

</div>
</div>
<a id="a5abf1cd08b7428661d747f54461c47e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abf1cd08b7428661d747f54461c47e5">&#9670;&nbsp;</a></span>VReversedParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::VReversedParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the v parameter on the modified surface, produced by reversing its V parametric direction, for the point of v parameter V on this BSpline surface. For a BSpline surface, these functions return respectively: </p>
<ul>
<li>VFirst + VLast - V, VFirst and VLast are the values of the first and last parameters of this BSpline surface, in the v pametric directions. </li>
</ul>

<p>Implements <a class="el" href="class_geom___surface.html#a12a473dc37ae2212cdad154c5bc1419b">Geom_Surface</a>.</p>

</div>
</div>
<a id="a92ddca375feffee360d3f180cdbf38a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ddca375feffee360d3f180cdbf38a1">&#9670;&nbsp;</a></span>Weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::Weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weight value of range UIndex, VIndex. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. </p>

</div>
</div>
<a id="ab3432cbee6dc104640b28a3db917f868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3432cbee6dc104640b28a3db917f868">&#9670;&nbsp;</a></span>Weights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the B-spline surface. </p>
<p>Raised if the length of W in the U and V direction is not equal to NbUPoles and NbVPoles. </p>

</div>
</div>
<a id="ab4df08073e225763bc7dcb84dbcff902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4df08073e225763bc7dcb84dbcff902">&#9670;&nbsp;</a></span>Weights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a>* Geom_BSplineSurface::Weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the B-spline surface. value and derivatives computation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_geom___b_spline_surface_8hxx.html">Geom_BSplineSurface.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

