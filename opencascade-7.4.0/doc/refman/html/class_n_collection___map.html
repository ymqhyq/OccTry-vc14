<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: NCollection_Map&lt; TheKeyType, Hasher &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Open CASCADE Technology</a></li><li class="navelem"><a class="el" href="module_foundationclasses.html">Module FoundationClasses</a></li><li class="navelem"><a class="el" href="toolkit_tkernel.html">Toolkit TKernel</a></li>    <li class="navelem"><a class="el" href="package_ncollection.html">Package NCollection </a>      </li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">NCollection_Map&lt; TheKeyType, Hasher &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;NCollection_Map.hxx&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NCollection_Map&lt; TheKeyType, Hasher &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_n_collection___map__inherit__graph.png" border="0" usemap="#_n_collection___map_3_01_the_key_type_00_01_hasher_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_n_collection___map_3_01_the_key_type_00_01_hasher_01_4_inherit__map" id="_n_collection___map_3_01_the_key_type_00_01_hasher_01_4_inherit__map">
<area shape="rect" id="node2" href="class_n_collection___base_map.html" title="NCollection_BaseMap" alt="" coords="34,5,185,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="class_n_collection___map_1_1_iterator.html" title="Implementation of the Iterator interface. ">Iterator</a> interface.  <a href="class_n_collection___map_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map_1_1_map_node.html">MapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptation of the TListNode to the map notations.  <a href="class_n_collection___map_1_1_map_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad5af0e2379426bcf5afc5755ad611086"><td class="memItemLeft" align="right" valign="top">typedef TheKeyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#ad5af0e2379426bcf5afc5755ad611086">key_type</a></td></tr>
<tr class="memdesc:ad5af0e2379426bcf5afc5755ad611086"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compliant typedef for key type.  <a href="#ad5af0e2379426bcf5afc5755ad611086">More...</a><br /></td></tr>
<tr class="separator:ad5af0e2379426bcf5afc5755ad611086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335f147d5c3fdfad986ffdb423e3190c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_n_collection___stl_iterator.html">NCollection_StlIterator</a>&lt; std::forward_iterator_tag, <a class="el" href="class_n_collection___map_1_1_iterator.html">Iterator</a>, TheKeyType, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a335f147d5c3fdfad986ffdb423e3190c">const_iterator</a></td></tr>
<tr class="memdesc:a335f147d5c3fdfad986ffdb423e3190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a constant iterator type.  <a href="#a335f147d5c3fdfad986ffdb423e3190c">More...</a><br /></td></tr>
<tr class="separator:a335f147d5c3fdfad986ffdb423e3190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a49730980fa677d919047cd830570fef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_collection___map.html#a335f147d5c3fdfad986ffdb423e3190c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a49730980fa677d919047cd830570fef1">cbegin</a> () const</td></tr>
<tr class="memdesc:a49730980fa677d919047cd830570fef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to the first element in the map.  <a href="#a49730980fa677d919047cd830570fef1">More...</a><br /></td></tr>
<tr class="separator:a49730980fa677d919047cd830570fef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd4ed06387dd2e9b5643fa2dd655504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_collection___map.html#a335f147d5c3fdfad986ffdb423e3190c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a6cd4ed06387dd2e9b5643fa2dd655504">cend</a> () const</td></tr>
<tr class="memdesc:a6cd4ed06387dd2e9b5643fa2dd655504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator referring to the past-the-end element in the map.  <a href="#a6cd4ed06387dd2e9b5643fa2dd655504">More...</a><br /></td></tr>
<tr class="separator:a6cd4ed06387dd2e9b5643fa2dd655504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f37395c5c5e7c3680ec0fbf23c1d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#aa26f37395c5c5e7c3680ec0fbf23c1d8">NCollection_Map</a> ()</td></tr>
<tr class="memdesc:aa26f37395c5c5e7c3680ec0fbf23c1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#aa26f37395c5c5e7c3680ec0fbf23c1d8">More...</a><br /></td></tr>
<tr class="separator:aa26f37395c5c5e7c3680ec0fbf23c1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32334468bb85aebcb999cf7db5259565"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a32334468bb85aebcb999cf7db5259565">NCollection_Map</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> theNbBuckets, const <a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt; &amp;theAllocator=0L)</td></tr>
<tr class="memdesc:a32334468bb85aebcb999cf7db5259565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a32334468bb85aebcb999cf7db5259565">More...</a><br /></td></tr>
<tr class="separator:a32334468bb85aebcb999cf7db5259565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc208564bf8b7d1f5c93e59fa51930f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a6bc208564bf8b7d1f5c93e59fa51930f">NCollection_Map</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:a6bc208564bf8b7d1f5c93e59fa51930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a6bc208564bf8b7d1f5c93e59fa51930f">More...</a><br /></td></tr>
<tr class="separator:a6bc208564bf8b7d1f5c93e59fa51930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7da61b217b1ffdda35464b955d1fece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#ab7da61b217b1ffdda35464b955d1fece">Exchange</a> (<a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:ab7da61b217b1ffdda35464b955d1fece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!  <a href="#ab7da61b217b1ffdda35464b955d1fece">More...</a><br /></td></tr>
<tr class="separator:ab7da61b217b1ffdda35464b955d1fece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05a801f4931c996935d1b3f4443253f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#ac05a801f4931c996935d1b3f4443253f">Assign</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:ac05a801f4931c996935d1b3f4443253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign. This method does not change the internal allocator.  <a href="#ac05a801f4931c996935d1b3f4443253f">More...</a><br /></td></tr>
<tr class="separator:ac05a801f4931c996935d1b3f4443253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa203f2c50ce494c483b78a8a487c247d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#aa203f2c50ce494c483b78a8a487c247d">operator=</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:aa203f2c50ce494c483b78a8a487c247d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign operator.  <a href="#aa203f2c50ce494c483b78a8a487c247d">More...</a><br /></td></tr>
<tr class="separator:aa203f2c50ce494c483b78a8a487c247d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc841361509dd1e389923d3400f433a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#acc841361509dd1e389923d3400f433a9">ReSize</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> N)</td></tr>
<tr class="memdesc:acc841361509dd1e389923d3400f433a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReSize.  <a href="#acc841361509dd1e389923d3400f433a9">More...</a><br /></td></tr>
<tr class="separator:acc841361509dd1e389923d3400f433a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0deb5eae077c6b36021784120c2a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a5c0deb5eae077c6b36021784120c2a4e">Add</a> (const TheKeyType &amp;K)</td></tr>
<tr class="memdesc:a5c0deb5eae077c6b36021784120c2a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add.  <a href="#a5c0deb5eae077c6b36021784120c2a4e">More...</a><br /></td></tr>
<tr class="separator:a5c0deb5eae077c6b36021784120c2a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dbf042a0269c69c64647fd721c3734"><td class="memItemLeft" align="right" valign="top">const TheKeyType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#ab1dbf042a0269c69c64647fd721c3734">Added</a> (const TheKeyType &amp;K)</td></tr>
<tr class="memdesc:ab1dbf042a0269c69c64647fd721c3734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Added: add a new key if not yet in the map, and return reference to either newly added or previously existing object.  <a href="#ab1dbf042a0269c69c64647fd721c3734">More...</a><br /></td></tr>
<tr class="separator:ab1dbf042a0269c69c64647fd721c3734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd023842dd0bf3533606f0f4dbfdcc9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#afd023842dd0bf3533606f0f4dbfdcc9c">Contains</a> (const TheKeyType &amp;K) const</td></tr>
<tr class="memdesc:afd023842dd0bf3533606f0f4dbfdcc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains.  <a href="#afd023842dd0bf3533606f0f4dbfdcc9c">More...</a><br /></td></tr>
<tr class="separator:afd023842dd0bf3533606f0f4dbfdcc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fc364c62f65ffa7af53e208afd0dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a03fc364c62f65ffa7af53e208afd0dc0">Remove</a> (const TheKeyType &amp;K)</td></tr>
<tr class="memdesc:a03fc364c62f65ffa7af53e208afd0dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove.  <a href="#a03fc364c62f65ffa7af53e208afd0dc0">More...</a><br /></td></tr>
<tr class="separator:a03fc364c62f65ffa7af53e208afd0dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932ca21b0daed82c5d55f962c80a3543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a932ca21b0daed82c5d55f962c80a3543">Clear</a> (const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> doReleaseMemory=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:a932ca21b0daed82c5d55f962c80a3543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.  <a href="#a932ca21b0daed82c5d55f962c80a3543">More...</a><br /></td></tr>
<tr class="separator:a932ca21b0daed82c5d55f962c80a3543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ae909271e4e0b57cc5ca7eba01149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a207ae909271e4e0b57cc5ca7eba01149">Clear</a> (const <a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt; &amp;theAllocator)</td></tr>
<tr class="memdesc:a207ae909271e4e0b57cc5ca7eba01149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear data and reset allocator.  <a href="#a207ae909271e4e0b57cc5ca7eba01149">More...</a><br /></td></tr>
<tr class="separator:a207ae909271e4e0b57cc5ca7eba01149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b14ed18770d0cabd7704b3ec57b804"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#ad3b14ed18770d0cabd7704b3ec57b804">~NCollection_Map</a> (void)</td></tr>
<tr class="memdesc:ad3b14ed18770d0cabd7704b3ec57b804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad3b14ed18770d0cabd7704b3ec57b804">More...</a><br /></td></tr>
<tr class="separator:ad3b14ed18770d0cabd7704b3ec57b804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808dbc609dab8817a7b93da94689ccad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a808dbc609dab8817a7b93da94689ccad">Size</a> (void) const</td></tr>
<tr class="memdesc:a808dbc609dab8817a7b93da94689ccad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size.  <a href="#a808dbc609dab8817a7b93da94689ccad">More...</a><br /></td></tr>
<tr class="separator:a808dbc609dab8817a7b93da94689ccad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Boolean operations with maps as sets of keys</div></td></tr>
<tr class="memitem:a209f77f84325ffa80bf39900a39ce473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a209f77f84325ffa80bf39900a39ce473">IsEqual</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther) const</td></tr>
<tr class="separator:a209f77f84325ffa80bf39900a39ce473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ed57bb0bf6406ab2b3c55081eeaabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a80ed57bb0bf6406ab2b3c55081eeaabd">Contains</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther) const</td></tr>
<tr class="separator:a80ed57bb0bf6406ab2b3c55081eeaabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d0359206d85f8d32d39483dac0372d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a51d0359206d85f8d32d39483dac0372d">Union</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theLeft, const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theRight)</td></tr>
<tr class="memdesc:a51d0359206d85f8d32d39483dac0372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps The new Map contains the values that are contained either in the first map or in the second map or in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be passed as one of operands.  <a href="#a51d0359206d85f8d32d39483dac0372d">More...</a><br /></td></tr>
<tr class="separator:a51d0359206d85f8d32d39483dac0372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92da2c877c9690cfbd2ec4db827a24a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a92da2c877c9690cfbd2ec4db827a24a6">Unite</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:a92da2c877c9690cfbd2ec4db827a24a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map. The result contains the values that were previously contained in this map or contained in the given (operand) map. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a51d0359206d85f8d32d39483dac0372d" title="Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two...">Union()</a>. Returns True if contents of this map is changed.  <a href="#a92da2c877c9690cfbd2ec4db827a24a6">More...</a><br /></td></tr>
<tr class="separator:a92da2c877c9690cfbd2ec4db827a24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9eb1bde402e06341801ee095710ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a5d9eb1bde402e06341801ee095710ca6">HasIntersection</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theMap) const</td></tr>
<tr class="memdesc:a5d9eb1bde402e06341801ee095710ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this and theMap have common elements.  <a href="#a5d9eb1bde402e06341801ee095710ca6">More...</a><br /></td></tr>
<tr class="separator:a5d9eb1bde402e06341801ee095710ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae013dd7547d277004048942a0179a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a18ae013dd7547d277004048942a0179a">Intersection</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theLeft, const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theRight)</td></tr>
<tr class="memdesc:a18ae013dd7547d277004048942a0179a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps. The new Map contains only the values that are contained in both map operands. All previous content of this Map is cleared. This same map (result of the boolean operation) can also be used as one of operands.  <a href="#a18ae013dd7547d277004048942a0179a">More...</a><br /></td></tr>
<tr class="separator:a18ae013dd7547d277004048942a0179a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626733e9e0cb5c758110861925cf0ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#ac626733e9e0cb5c758110861925cf0ff">Intersect</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:ac626733e9e0cb5c758110861925cf0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map. The result contains only the values that are contained in both this and the given maps. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a18ae013dd7547d277004048942a0179a" title="Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation be...">Intersection()</a>. Returns True if contents of this map is changed.  <a href="#ac626733e9e0cb5c758110861925cf0ff">More...</a><br /></td></tr>
<tr class="separator:ac626733e9e0cb5c758110861925cf0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c50f56f8966f41ff2033e4131140667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a0c50f56f8966f41ff2033e4131140667">Subtraction</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theLeft, const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theRight)</td></tr>
<tr class="memdesc:a0c50f56f8966f41ff2033e4131140667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation between two given Maps. The new Map contains only the values that are contained in the first map operands and not contained in the second one. All previous content of this Map is cleared.  <a href="#a0c50f56f8966f41ff2033e4131140667">More...</a><br /></td></tr>
<tr class="separator:a0c50f56f8966f41ff2033e4131140667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055b53b4c2087e3f7621d3ce73aaaba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a055b53b4c2087e3f7621d3ce73aaaba7">Subtract</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:a055b53b4c2087e3f7621d3ce73aaaba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a055b53b4c2087e3f7621d3ce73aaaba7" title="Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method Subtract() with two operands. Returns True if contents of this map is changed. ">Subtract()</a> with two operands. Returns True if contents of this map is changed.  <a href="#a055b53b4c2087e3f7621d3ce73aaaba7">More...</a><br /></td></tr>
<tr class="separator:a055b53b4c2087e3f7621d3ce73aaaba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745ccc143a116ce804587c17838e9d1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a745ccc143a116ce804587c17838e9d1e">Difference</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theLeft, const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theRight)</td></tr>
<tr class="memdesc:a745ccc143a116ce804587c17838e9d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.  <a href="#a745ccc143a116ce804587c17838e9d1e">More...</a><br /></td></tr>
<tr class="separator:a745ccc143a116ce804587c17838e9d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4087799d10d389ee672324bb05a4e302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___map.html#a4087799d10d389ee672324bb05a4e302">Differ</a> (const <a class="el" href="class_n_collection___map.html">NCollection_Map</a> &amp;theOther)</td></tr>
<tr class="memdesc:a4087799d10d389ee672324bb05a4e302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map. The result contains the values that are contained only in this or the operand map, but not in both. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a745ccc143a116ce804587c17838e9d1e" title="Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands. ">Difference()</a>. Returns True if contents of this map is changed.  <a href="#a4087799d10d389ee672324bb05a4e302">More...</a><br /></td></tr>
<tr class="separator:a4087799d10d389ee672324bb05a4e302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_n_collection___base_map"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_n_collection___base_map')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_n_collection___base_map.html">NCollection_BaseMap</a></td></tr>
<tr class="memitem:a104e73e51fffa49c159eaac57ea2b763 inherit pub_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a104e73e51fffa49c159eaac57ea2b763">NbBuckets</a> () const</td></tr>
<tr class="memdesc:a104e73e51fffa49c159eaac57ea2b763 inherit pub_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">NbBuckets.  <a href="class_n_collection___base_map.html#a104e73e51fffa49c159eaac57ea2b763">More...</a><br /></td></tr>
<tr class="separator:a104e73e51fffa49c159eaac57ea2b763 inherit pub_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8089854e15993c4a0abcc7b55cb793b inherit pub_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#af8089854e15993c4a0abcc7b55cb793b">Extent</a> () const</td></tr>
<tr class="memdesc:af8089854e15993c4a0abcc7b55cb793b inherit pub_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extent.  <a href="class_n_collection___base_map.html#af8089854e15993c4a0abcc7b55cb793b">More...</a><br /></td></tr>
<tr class="separator:af8089854e15993c4a0abcc7b55cb793b inherit pub_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad252dc979c38ca0f49a9595e823e8c13 inherit pub_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#ad252dc979c38ca0f49a9595e823e8c13">IsEmpty</a> () const</td></tr>
<tr class="memdesc:ad252dc979c38ca0f49a9595e823e8c13 inherit pub_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsEmpty.  <a href="class_n_collection___base_map.html#ad252dc979c38ca0f49a9595e823e8c13">More...</a><br /></td></tr>
<tr class="separator:ad252dc979c38ca0f49a9595e823e8c13 inherit pub_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce2633e580c6045eaab7394f6be1765 inherit pub_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a5ce2633e580c6045eaab7394f6be1765">Statistics</a> (<a class="el" href="_standard___o_stream_8hxx.html#aace51db7b9aac68b6cffc3b3325a3585">Standard_OStream</a> &amp;S) const</td></tr>
<tr class="memdesc:a5ce2633e580c6045eaab7394f6be1765 inherit pub_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics.  <a href="class_n_collection___base_map.html#a5ce2633e580c6045eaab7394f6be1765">More...</a><br /></td></tr>
<tr class="separator:a5ce2633e580c6045eaab7394f6be1765 inherit pub_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235a7c981e932cc637869df87c0c7ce2 inherit pub_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a235a7c981e932cc637869df87c0c7ce2">Allocator</a> () const</td></tr>
<tr class="memdesc:a235a7c981e932cc637869df87c0c7ce2 inherit pub_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns attached allocator.  <a href="class_n_collection___base_map.html#a235a7c981e932cc637869df87c0c7ce2">More...</a><br /></td></tr>
<tr class="separator:a235a7c981e932cc637869df87c0c7ce2 inherit pub_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_n_collection___base_map"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_n_collection___base_map')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_n_collection___base_map.html">NCollection_BaseMap</a></td></tr>
<tr class="memitem:a5a56bd8d5059f292a17f91a784187ce9 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a5a56bd8d5059f292a17f91a784187ce9">NCollection_BaseMap</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_n_collection___base_map.html#a104e73e51fffa49c159eaac57ea2b763">NbBuckets</a>, const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> single, const <a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt; &amp;theAllocator)</td></tr>
<tr class="memdesc:a5a56bd8d5059f292a17f91a784187ce9 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_n_collection___base_map.html#a5a56bd8d5059f292a17f91a784187ce9">More...</a><br /></td></tr>
<tr class="separator:a5a56bd8d5059f292a17f91a784187ce9 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06307692e8b2e6a0eb833c372ac5ddf4 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a06307692e8b2e6a0eb833c372ac5ddf4">~NCollection_BaseMap</a> ()</td></tr>
<tr class="memdesc:a06307692e8b2e6a0eb833c372ac5ddf4 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_n_collection___base_map.html#a06307692e8b2e6a0eb833c372ac5ddf4">More...</a><br /></td></tr>
<tr class="separator:a06307692e8b2e6a0eb833c372ac5ddf4 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5a5bc6eeebdcad7d6e52dbee3a9d8d inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a5f5a5bc6eeebdcad7d6e52dbee3a9d8d">BeginResize</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_n_collection___base_map.html#a104e73e51fffa49c159eaac57ea2b763">NbBuckets</a>, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;NewBuckets, <a class="el" href="class_n_collection___list_node.html">NCollection_ListNode</a> **&amp;data1, <a class="el" href="class_n_collection___list_node.html">NCollection_ListNode</a> **&amp;data2) const</td></tr>
<tr class="memdesc:a5f5a5bc6eeebdcad7d6e52dbee3a9d8d inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">BeginResize.  <a href="class_n_collection___base_map.html#a5f5a5bc6eeebdcad7d6e52dbee3a9d8d">More...</a><br /></td></tr>
<tr class="separator:a5f5a5bc6eeebdcad7d6e52dbee3a9d8d inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05963d7afe60a17f154de9dfa816683 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#ab05963d7afe60a17f154de9dfa816683">EndResize</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_n_collection___base_map.html#a104e73e51fffa49c159eaac57ea2b763">NbBuckets</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> NewBuckets, <a class="el" href="class_n_collection___list_node.html">NCollection_ListNode</a> **data1, <a class="el" href="class_n_collection___list_node.html">NCollection_ListNode</a> **data2)</td></tr>
<tr class="memdesc:ab05963d7afe60a17f154de9dfa816683 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">EndResize.  <a href="class_n_collection___base_map.html#ab05963d7afe60a17f154de9dfa816683">More...</a><br /></td></tr>
<tr class="separator:ab05963d7afe60a17f154de9dfa816683 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae877dfd2c440972f3f00bf821a99d1b5 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#ae877dfd2c440972f3f00bf821a99d1b5">Resizable</a> () const</td></tr>
<tr class="memdesc:ae877dfd2c440972f3f00bf821a99d1b5 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizable.  <a href="class_n_collection___base_map.html#ae877dfd2c440972f3f00bf821a99d1b5">More...</a><br /></td></tr>
<tr class="separator:ae877dfd2c440972f3f00bf821a99d1b5 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a47985ec816467a9d7068b45c67a35 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#ad5a47985ec816467a9d7068b45c67a35">Increment</a> ()</td></tr>
<tr class="memdesc:ad5a47985ec816467a9d7068b45c67a35 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment.  <a href="class_n_collection___base_map.html#ad5a47985ec816467a9d7068b45c67a35">More...</a><br /></td></tr>
<tr class="separator:ad5a47985ec816467a9d7068b45c67a35 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedc8031401af4ef5caae96beb8ad010 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#adedc8031401af4ef5caae96beb8ad010">Decrement</a> ()</td></tr>
<tr class="memdesc:adedc8031401af4ef5caae96beb8ad010 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement.  <a href="class_n_collection___base_map.html#adedc8031401af4ef5caae96beb8ad010">More...</a><br /></td></tr>
<tr class="separator:adedc8031401af4ef5caae96beb8ad010 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e7a5a3c22b577214081ab7b30781f4 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#ad3e7a5a3c22b577214081ab7b30781f4">Destroy</a> (<a class="el" href="_n_collection___base_map_8hxx.html#ad00b41ec49ce29c60e98d504e385f1b9">NCollection_DelMapNode</a> fDel, <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> doReleaseMemory=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:ad3e7a5a3c22b577214081ab7b30781f4 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy.  <a href="class_n_collection___base_map.html#ad3e7a5a3c22b577214081ab7b30781f4">More...</a><br /></td></tr>
<tr class="separator:ad3e7a5a3c22b577214081ab7b30781f4 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcf16ab794b51bb0c425ae9a34a9268 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#aadcf16ab794b51bb0c425ae9a34a9268">NextPrimeForMap</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> N) const</td></tr>
<tr class="memdesc:aadcf16ab794b51bb0c425ae9a34a9268 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">NextPrimeForMap.  <a href="class_n_collection___base_map.html#aadcf16ab794b51bb0c425ae9a34a9268">More...</a><br /></td></tr>
<tr class="separator:aadcf16ab794b51bb0c425ae9a34a9268 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22117237125582cf22e46394fb9a758 inherit pro_methods_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#ac22117237125582cf22e46394fb9a758">exchangeMapsData</a> (<a class="el" href="class_n_collection___base_map.html">NCollection_BaseMap</a> &amp;theOther)</td></tr>
<tr class="memdesc:ac22117237125582cf22e46394fb9a758 inherit pro_methods_class_n_collection___base_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange content of two maps without data copying.  <a href="class_n_collection___base_map.html#ac22117237125582cf22e46394fb9a758">More...</a><br /></td></tr>
<tr class="separator:ac22117237125582cf22e46394fb9a758 inherit pro_methods_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_n_collection___base_map"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_n_collection___base_map')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_n_collection___base_map.html">NCollection_BaseMap</a></td></tr>
<tr class="memitem:a3296bf84b51cfc82af914fbb3e21ad59 inherit pro_attribs_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a3296bf84b51cfc82af914fbb3e21ad59">myAllocator</a></td></tr>
<tr class="separator:a3296bf84b51cfc82af914fbb3e21ad59 inherit pro_attribs_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b0fc7f35414f4a26a009069c67e200 inherit pro_attribs_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_collection___list_node.html">NCollection_ListNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#a63b0fc7f35414f4a26a009069c67e200">myData1</a></td></tr>
<tr class="separator:a63b0fc7f35414f4a26a009069c67e200 inherit pro_attribs_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c449522afa2e934ab063f155ff5338 inherit pro_attribs_class_n_collection___base_map"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_collection___list_node.html">NCollection_ListNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_collection___base_map.html#af9c449522afa2e934ab063f155ff5338">myData2</a></td></tr>
<tr class="separator:af9c449522afa2e934ab063f155ff5338 inherit pro_attribs_class_n_collection___base_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt;<br />
class NCollection_Map&lt; TheKeyType, Hasher &gt;</h3>

<p>Purpose: Single hashed Map. This Map is used to store and retrieve keys in linear time.</p>
<p>The ::Iterator class can be used to explore the content of the map. It is not wise to iterate and modify a map in parallel.</p>
<p>To compute the hashcode of the key the function <a class="el" href="_mesh_v_s___two_nodes_8hxx.html#a7cf9fb0688ca168e6de3312405c9d855" title="Computes a hash code for two nodes, in the range [1, theUpperBound]. ">HashCode</a> must be defined in the global namespace</p>
<p>To compare two keys the function <a class="el" href="_mesh_v_s___two_colors_8hxx.html#aa8bdc9ae6653e65f307cd8560d48fc22">IsEqual</a> must be defined in the global namespace.</p>
<p>The performance of a Map is conditionned by its number of buckets that should be kept greater to the number of keys. This map has an automatic management of the number of buckets. It is resized when the number of Keys becomes greater than the number of buckets.</p>
<p>If you have a fair idea of the number of objects you can save on automatic resizing by giving a number of buckets at creation or using the ReSize method. This should be consider only for crucial optimisation issues. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a335f147d5c3fdfad986ffdb423e3190c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335f147d5c3fdfad986ffdb423e3190c">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_n_collection___stl_iterator.html">NCollection_StlIterator</a>&lt;std::forward_iterator_tag, <a class="el" href="class_n_collection___map_1_1_iterator.html">Iterator</a>, TheKeyType, true&gt; <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::<a class="el" href="class_n_collection___map.html#a335f147d5c3fdfad986ffdb423e3190c">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorthand for a constant iterator type. </p>

</div>
</div>
<a id="ad5af0e2379426bcf5afc5755ad611086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5af0e2379426bcf5afc5755ad611086">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TheKeyType <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::<a class="el" href="class_n_collection___map.html#ad5af0e2379426bcf5afc5755ad611086">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-compliant typedef for key type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa26f37395c5c5e7c3680ec0fbf23c1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26f37395c5c5e7c3680ec0fbf23c1d8">&#9670;&nbsp;</a></span>NCollection_Map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::<a class="el" href="class_n_collection___map.html">NCollection_Map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>

</div>
</div>
<a id="a32334468bb85aebcb999cf7db5259565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32334468bb85aebcb999cf7db5259565">&#9670;&nbsp;</a></span>NCollection_Map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::<a class="el" href="class_n_collection___map.html">NCollection_Map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>theNbBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theAllocator</em> = <code>0L</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a6bc208564bf8b7d1f5c93e59fa51930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc208564bf8b7d1f5c93e59fa51930f">&#9670;&nbsp;</a></span>NCollection_Map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::<a class="el" href="class_n_collection___map.html">NCollection_Map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ad3b14ed18770d0cabd7704b3ec57b804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b14ed18770d0cabd7704b3ec57b804">&#9670;&nbsp;</a></span>~NCollection_Map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::~<a class="el" href="class_n_collection___map.html">NCollection_Map</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c0deb5eae077c6b36021784120c2a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0deb5eae077c6b36021784120c2a4e">&#9670;&nbsp;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Add </td>
          <td>(</td>
          <td class="paramtype">const TheKeyType &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add. </p>

</div>
</div>
<a id="ab1dbf042a0269c69c64647fd721c3734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dbf042a0269c69c64647fd721c3734">&#9670;&nbsp;</a></span>Added()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TheKeyType&amp; <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Added </td>
          <td>(</td>
          <td class="paramtype">const TheKeyType &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Added: add a new key if not yet in the map, and return reference to either newly added or previously existing object. </p>

</div>
</div>
<a id="ac05a801f4931c996935d1b3f4443253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05a801f4931c996935d1b3f4443253f">&#9670;&nbsp;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html">NCollection_Map</a>&amp; <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign. This method does not change the internal allocator. </p>

</div>
</div>
<a id="a49730980fa677d919047cd830570fef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49730980fa677d919047cd830570fef1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html#a335f147d5c3fdfad986ffdb423e3190c">const_iterator</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to the first element in the map. </p>

</div>
</div>
<a id="a6cd4ed06387dd2e9b5643fa2dd655504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd4ed06387dd2e9b5643fa2dd655504">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html#a335f147d5c3fdfad986ffdb423e3190c">const_iterator</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator referring to the past-the-end element in the map. </p>

</div>
</div>
<a id="a932ca21b0daed82c5d55f962c80a3543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932ca21b0daed82c5d55f962c80a3543">&#9670;&nbsp;</a></span>Clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>doReleaseMemory</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused. </p>

</div>
</div>
<a id="a207ae909271e4e0b57cc5ca7eba01149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207ae909271e4e0b57cc5ca7eba01149">&#9670;&nbsp;</a></span>Clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_n_collection___base_allocator.html">NCollection_BaseAllocator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theAllocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear data and reset allocator. </p>

</div>
</div>
<a id="afd023842dd0bf3533606f0f4dbfdcc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd023842dd0bf3533606f0f4dbfdcc9c">&#9670;&nbsp;</a></span>Contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const TheKeyType &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains. </p>

</div>
</div>
<a id="a80ed57bb0bf6406ab2b3c55081eeaabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ed57bb0bf6406ab2b3c55081eeaabd">&#9670;&nbsp;</a></span>Contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this map contains ALL keys of another map. </dd></dl>

</div>
</div>
<a id="a4087799d10d389ee672324bb05a4e302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4087799d10d389ee672324bb05a4e302">&#9670;&nbsp;</a></span>Differ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Differ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map. The result contains the values that are contained only in this or the operand map, but not in both. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a745ccc143a116ce804587c17838e9d1e" title="Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands. ">Difference()</a>. Returns True if contents of this map is changed. </p>

</div>
</div>
<a id="a745ccc143a116ce804587c17838e9d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745ccc143a116ce804587c17838e9d1e">&#9670;&nbsp;</a></span>Difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands. </p>

</div>
</div>
<a id="ab7da61b217b1ffdda35464b955d1fece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7da61b217b1ffdda35464b955d1fece">&#9670;&nbsp;</a></span>Exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well! </p>

</div>
</div>
<a id="a5d9eb1bde402e06341801ee095710ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9eb1bde402e06341801ee095710ca6">&#9670;&nbsp;</a></span>HasIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::HasIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theMap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this and theMap have common elements. </p>

</div>
</div>
<a id="ac626733e9e0cb5c758110861925cf0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac626733e9e0cb5c758110861925cf0ff">&#9670;&nbsp;</a></span>Intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map. The result contains only the values that are contained in both this and the given maps. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a18ae013dd7547d277004048942a0179a" title="Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation be...">Intersection()</a>. Returns True if contents of this map is changed. </p>

</div>
</div>
<a id="a18ae013dd7547d277004048942a0179a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae013dd7547d277004048942a0179a">&#9670;&nbsp;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps. The new Map contains only the values that are contained in both map operands. All previous content of this Map is cleared. This same map (result of the boolean operation) can also be used as one of operands. </p>

</div>
</div>
<a id="a209f77f84325ffa80bf39900a39ce473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209f77f84325ffa80bf39900a39ce473">&#9670;&nbsp;</a></span>IsEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::IsEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if two maps contains exactly the same keys </dd></dl>

</div>
</div>
<a id="aa203f2c50ce494c483b78a8a487c247d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa203f2c50ce494c483b78a8a487c247d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_collection___map.html">NCollection_Map</a>&amp; <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign operator. </p>

</div>
</div>
<a id="a03fc364c62f65ffa7af53e208afd0dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fc364c62f65ffa7af53e208afd0dc0">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const TheKeyType &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove. </p>

</div>
</div>
<a id="acc841361509dd1e389923d3400f433a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc841361509dd1e389923d3400f433a9">&#9670;&nbsp;</a></span>ReSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::ReSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReSize. </p>

</div>
</div>
<a id="a808dbc609dab8817a7b93da94689ccad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808dbc609dab8817a7b93da94689ccad">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size. </p>

</div>
</div>
<a id="a055b53b4c2087e3f7621d3ce73aaaba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055b53b4c2087e3f7621d3ce73aaaba7">&#9670;&nbsp;</a></span>Subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a055b53b4c2087e3f7621d3ce73aaaba7" title="Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method Subtract() with two operands. Returns True if contents of this map is changed. ">Subtract()</a> with two operands. Returns True if contents of this map is changed. </p>

</div>
</div>
<a id="a0c50f56f8966f41ff2033e4131140667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c50f56f8966f41ff2033e4131140667">&#9670;&nbsp;</a></span>Subtraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Subtraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation between two given Maps. The new Map contains only the values that are contained in the first map operands and not contained in the second one. All previous content of this Map is cleared. </p>

</div>
</div>
<a id="a51d0359206d85f8d32d39483dac0372d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d0359206d85f8d32d39483dac0372d">&#9670;&nbsp;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps The new Map contains the values that are contained either in the first map or in the second map or in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be passed as one of operands. </p>

</div>
</div>
<a id="a92da2c877c9690cfbd2ec4db827a24a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92da2c877c9690cfbd2ec4db827a24a6">&#9670;&nbsp;</a></span>Unite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheKeyType, class Hasher = NCollection_DefaultHasher&lt;TheKeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt;::Unite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_collection___map.html">NCollection_Map</a>&lt; TheKeyType, Hasher &gt; &amp;&#160;</td>
          <td class="paramname"><em>theOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map. The result contains the values that were previously contained in this map or contained in the given (operand) map. This algorithm is similar to method <a class="el" href="class_n_collection___map.html#a51d0359206d85f8d32d39483dac0372d" title="Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two...">Union()</a>. Returns True if contents of this map is changed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_n_collection___map_8hxx.html">NCollection_Map.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

