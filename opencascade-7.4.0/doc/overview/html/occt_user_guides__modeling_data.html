<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Modeling Data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__modeling_data.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Modeling Data </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_modat_0">Introduction</a></li>
<li class="level1"><a href="#occt_modat_1">Geometry Utilities</a><ul><li class="level2"><a href="#occt_modat_1_1">Interpolations and Approximations</a><ul><li class="level3"><a href="#occt_modat_1_1_1">Analysis of a set of points</a></li>
<li class="level3"><a href="#occt_modat_1_1_2">Basic Interpolation and Approximation</a></li>
<li class="level3"><a href="#occt_modat_1_1_3">Advanced Approximation</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modat_1_2">Direct Construction</a><ul><li class="level3"><a href="#occt_modat_1_2_1">Simple geometric entities</a></li>
<li class="level3"><a href="#occt_modat_1_2_2">Geometric entities manipulated by handle</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modat_1_3">Conversion to and from BSplines</a></li>
<li class="level2"><a href="#occt_modat_1_4">Points on Curves</a></li>
<li class="level2"><a href="#occt_modat_1_5">Extrema</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modat_2">2D Geometry</a></li>
<li class="level1"><a href="#occt_modat_3">3D Geometry</a></li>
<li class="level1"><a href="#occt_modat_4">Properties of Shapes</a><ul><li class="level2"><a href="#occt_modat_4_1">Local Properties of Shapes</a></li>
<li class="level2"><a href="#occt_modat_4_2">Local Properties of Curves and Surfaces</a></li>
<li class="level2"><a href="#occt_modat_4_2a">Continuity of Curves and Surfaces</a></li>
<li class="level2"><a href="#occt_modat_4_2b">Regularity of Shared Edges</a></li>
<li class="level2"><a href="#occt_modat_4_3">Global Properties of Shapes</a></li>
<li class="level2"><a href="#occt_modat_4_4">Adaptors for Curves and Surfaces</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modat_5">Topology</a><ul><li class="level2"><a href="#occt_modat_5_1">Shape Location</a></li>
<li class="level2"><a href="#occt_modat_5_2">Naming shapes, sub-shapes, their orientation and state</a><ul><li class="level3"><a href="#occt_modat_5_2_1">Topological types</a></li>
<li class="level3"><a href="#occt_modat_5_2_2">Orientation</a></li>
<li class="level3"><a href="#occt_modat_5_2_3">State</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modat_5_3">Manipulating shapes and sub-shapes</a></li>
<li class="level2"><a href="#occt_modat_5_4">Exploration of Topological Data Structures</a></li>
<li class="level2"><a href="#occt_modat_5_5">Lists and Maps of Shapes</a><ul><li class="level3"><a href="#occt_modat_5_5_1">Wire Explorer</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modat_5_6">Storage of shapes</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modat_6">Bounding boxes</a><ul><li class="level2"><a href="#occt_modat_6_1">Brief description of some algorithms working with OBB</a><ul><li class="level3"><a href="#occt_modat_6_1_1">Creation of OBB from set of points</a></li>
<li class="level3"><a href="#occt_modat_6_1_1_opt">Creation of Optimal OBB from set of points</a></li>
<li class="level3"><a href="#occt_modat_6_1_2">Creation of OBB based on Axes of inertia</a></li>
<li class="level3"><a href="#occt_modat_6_1_3">Method IsOut for a point</a></li>
<li class="level3"><a href="#occt_modat_6_1_4">Method IsOut for another OBB</a></li>
<li class="level3"><a href="#occt_modat_6_1_5">Method Add for point or another bounding box</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modat_6_2">Add a shape</a></li>
<li class="level2"><a href="#occt_modat_6_3">Limitations of algorithm for OBB creation.</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_modat_0"></a>
Introduction</h1>
<p>Modeling Data supplies data structures to represent 2D and 3D geometric models.</p>
<p>This manual explains how to use Modeling Data. For advanced information on modeling data, see our <a href="https://www.opencascade.com/content/tutorial-learning">E-learning &amp; Training</a> offerings.</p>
<h1><a class="anchor" id="occt_modat_1"></a>
Geometry Utilities</h1>
<p>Geometry Utilities provide the following services:</p><ul>
<li>Creation of shapes by interpolation and approximation</li>
<li>Direct construction of shapes</li>
<li>Conversion of curves and surfaces to BSpline curves and surfaces</li>
<li>Computation of the coordinates of points on 2D and 3D curves</li>
<li>Calculation of extrema between shapes.</li>
</ul>
<h2><a class="anchor" id="occt_modat_1_1"></a>
Interpolations and Approximations</h2>
<p>In modeling, it is often required to approximate or interpolate points into curves and surfaces. In interpolation, the process is complete when the curve or surface passes through all the points; in approximation, when it is as close to these points as possible.</p>
<p>Approximation of Curves and Surfaces groups together a variety of functions used in 2D and 3D geometry for:</p><ul>
<li>the interpolation of a set of 2D points using a 2D BSpline or Bezier curve;</li>
<li>the approximation of a set of 2D points using a 2D BSpline or Bezier curve;</li>
<li>the interpolation of a set of 3D points using a 3D BSpline or Bezier curve, or a BSpline surface;</li>
<li>the approximation of a set of 3D points using a 3D BSpline or Bezier curve, or a BSpline surface.</li>
</ul>
<p>You can program approximations in two ways:</p>
<ul>
<li>Using high-level functions, designed to provide a simple method for obtaining approximations with minimal programming,</li>
<li>Using low-level functions, designed for users requiring more control over the approximations.</li>
</ul>
<h3><a class="anchor" id="occt_modat_1_1_1"></a>
Analysis of a set of points</h3>
<p>The class <em>PEquation</em> from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_g_prop.html">GProp</a></em> package allows analyzing a collection or cloud of points and verifying if they are coincident, collinear or coplanar within a given precision. If they are, the algorithm computes the mean point, the mean line or the mean plane of the points. If they are not, the algorithm computes the minimal box, which includes all the points.</p>
<h3><a class="anchor" id="occt_modat_1_1_2"></a>
Basic Interpolation and Approximation</h3>
<p>Packages <em>Geom2dAPI</em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i.html">GeomAPI</a></em> provide simple methods for approximation and interpolation with minimal programming</p>
<h4>2D Interpolation</h4>
<p>The class <em>Interpolate</em> from <em>Geom2dAPI</em> package allows building a constrained 2D BSpline curve, defined by a table of points through which the curve passes. If required, the parameter values and vectors of the tangents can be given for each point in the table.</p>
<h4>3D Interpolation</h4>
<p>The class <em>Interpolate</em> from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i.html">GeomAPI</a></em> package allows building a constrained 3D BSpline curve, defined by a table of points through which the curve passes. If required, the parameter values and vectors of the tangents can be given for each point in the table.</p>
<div class="image">
<img src="modeling_data_image003.png" alt="modeling_data_image003.png"/>
<div class="caption">
Approximation of a BSpline from scattered points</div></div>
<p> This class may be instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_Interpolate Interp(Points); </div></div><!-- fragment --><p>From this object, the BSpline curve may be requested as follows: </p><div class="fragment"><div class="line">Handle(Geom_BSplineCurve) C = Interp.Curve(); </div></div><!-- fragment --><h4>2D Approximation</h4>
<p>The class <em>PointsToBSpline</em> from <em>Geom2dAPI</em> package allows building a 2DBSpline curve, which approximates a set of points. You have to define the lowest and highest degree of the curve, its continuity and a tolerance value for it.The tolerance value is used to check that points are not too close to each other, or tangential vectors not too small. The resulting BSpline curve will beC2 or second degree continuous, except where a tangency constraint is defined on a point through which the curve passes. In this case, it will be only C1continuous.</p>
<h4>3D Approximation</h4>
<p>The class <em>PointsToBSpline</em> from <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i.html">GeomAPI</a> package allows building a 3D BSplinecurve, which approximates a set of points. It is necessary to define the lowest and highest degree of the curve, its continuity and tolerance. The tolerance value is used to check that points are not too close to each other,or that tangential vectors are not too small.</p>
<p>The resulting BSpline curve will be C2 or second degree continuous, except where a tangency constraint is defined on a point, through which the curve passes. In this case, it will be only C1 continuous. This class is instantiated as follows:</p>
<div class="fragment"><div class="line">GeomAPI_PointsToBSpline </div><div class="line">Approx(Points,DegMin,DegMax,Continuity, Tol); </div></div><!-- fragment --><p>From this object, the BSpline curve may be requested as follows:</p>
<div class="fragment"><div class="line">Handle(Geom_BSplineCurve) K = Approx.Curve(); </div></div><!-- fragment --><h4>Surface Approximation</h4>
<p>The class <b>PointsToBSplineSurface</b> from <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i.html">GeomAPI</a> package allows building a BSpline surface, which approximates or interpolates a set of points.</p>
<h3><a class="anchor" id="occt_modat_1_1_3"></a>
Advanced Approximation</h3>
<p>Packages <em>AppDef</em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_app_par_curves.html">AppParCurves</a></em> provide low-level functions, allowing more control over the approximations.</p>
<p>The low-level functions provide a second API with functions to:</p><ul>
<li>Define compulsory tangents for an approximation. These tangents have origins and extremities.</li>
<li>Approximate a set of curves in parallel to respect identical parameterization.</li>
<li>Smooth approximations. This is to produce a faired curve.</li>
</ul>
<p>You can also find functions to compute:</p><ul>
<li>The minimal box which includes a set of points</li>
<li>The mean plane, line or point of a set of coplanar, collinear or coincident points.</li>
</ul>
<h4>Approximation by multiple point constraints</h4>
<p><em>AppDef</em> package provides low-level tools to allow parallel approximation of groups of points into Bezier or B-Spline curves using multiple point constraints.</p>
<p>The following low level services are provided:</p>
<ul>
<li><p class="startli">Definition of an array of point constraints:</p>
<p class="startli">The class <em>MultiLine</em> allows defining a given number of multi-point constraints in order to build the multi-line, multiple lines passing through ordered multiple point constraints.</p>
<div class="image">
<img src="modeling_data_image004.png" alt="modeling_data_image004.png"/>
<div class="caption">
Definition of a MultiLine using Multiple Point Constraints</div></div>
<p> In this image:</p><ul>
<li><em>Pi</em>, <em>Qi</em>, <em>Ri</em> ... <em>Si</em> can be 2D or 3D points.</li>
<li>Defined as a group: <em>Pn</em>, <em>Qn</em>, <em>Rn,</em> ... <em>Sn</em> form a MultipointConstraint. They possess the same passage, tangency and curvature constraints.</li>
<li><em>P1</em>, <em>P2</em>, ... <em>Pn</em>, or the <em>Q</em>, <em>R</em>, ... or <em>S</em> series represent the lines to be approximated.</li>
</ul>
</li>
<li><p class="startli">Definition of a set of point constraints:</p>
<p class="startli">The class <em>MultiPointConstraint</em> allows defining a multiple point constraint and computing the approximation of sets of points to several curves.</p>
</li>
<li><p class="startli">Computation of an approximation of a Bezier curve from a set of points:</p>
<p class="startli">The class <em>Compute</em> allows making an approximation of a set of points to a Bezier curve</p>
</li>
<li><p class="startli">Computation of an approximation of a BSpline curve from a set of points:</p>
<p class="startli">The class <em>BSplineCompute</em> allows making an approximation of a set of points to a BSpline curve.</p>
</li>
<li>Definition of Variational Criteria:</li>
</ul>
<p>The class <em>TheVariational</em> allows fairing the approximation curve to a given number of points using a least squares method in conjunction with a variational criterion, usually the weights at each constraint point.</p>
<h4>Approximation by parametric or geometric constraints</h4>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_app_par_curves.html">AppParCurves</a></em> package provides low-level tools to allow parallel approximation of groups of points into Bezier or B-Spline curve with parametric or geometric constraints, such as a requirement for the curve to pass through given points, or to have a given tangency or curvature at a particular point.</p>
<p>The algorithms used include:</p><ul>
<li>the least squares method</li>
<li>a search for the best approximation within a given tolerance value.</li>
</ul>
<p>The following low-level services are provided:</p>
<ul>
<li>Association of an index to an object:</li>
</ul>
<p>The class <em>ConstraintCouple</em> allows you associating an index to an object to compute faired curves using <em>AppDef_TheVariational</em>.</p>
<ul>
<li>Definition of a set of approximations of Bezier curves:</li>
</ul>
<p>The class <em>MultiCurve</em> allows defining the approximation of a multi-line made up of multiple Bezier curves.</p>
<ul>
<li>Definition of a set of approximations of BSpline curves:</li>
</ul>
<p>The class <em>MultiBSpCurve</em> allows defining the approximation of a multi-line made up of multiple BSpline curves.</p>
<ul>
<li>Definition of points making up a set of point constraints</li>
</ul>
<p>The class <em>MultiPoint</em> allows defining groups of 2D or 3D points making up a multi-line.</p>
<h4>Example: How to approximate a curve with respect to tangency</h4>
<p>To approximate a curve with respect to tangency, follow these steps:</p>
<ol type="1">
<li>Create an object of type <em> AppDef_MultiPointConstraints</em> from the set of points to approximate and use the method <em> SetTang </em>to set the tangency vectors.</li>
<li>Create an object of type <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_app_def___multi_line.html">AppDef_MultiLine</a> </em>from the <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_app_def___multi_point_constraint.html">AppDef_MultiPointConstraint</a></em>.</li>
<li>Use <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_app_def___b_spline_compute.html">AppDef_BSplineCompute</a></em>, which instantiates <em>Approx_BSplineComputeLine</em> to perform the approximation.</li>
</ol>
<h2><a class="anchor" id="occt_modat_1_2"></a>
Direct Construction</h2>
<p>Direct Construction methods from <em>gce</em>, <em>GC</em> and <em>GCE2d</em> packages provide simplified algorithms to build elementary geometric entities such as lines, circles and curves. They complement the reference definitions provided by the <em>gp</em>, <em>Geom</em> and <em>Geom2d</em> packages.</p>
<p>The algorithms implemented by <em> gce</em>, <em> GCE2d</em> and <em> GC</em> packages are simple: there is no creation of objects defined by advanced positional constraints (for more information on this subject, see <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a></em> and <em>GccAna</em>, which describe geometry by constraints).</p>
<p>For example, to construct a circle from a point and a radius using the <em>gp</em> package, it is necessary to construct axis <em>Ax2d</em> before creating the circle. If <em>gce</em> package is used, and <em>Ox</em> is taken for the axis, it is possible to create a circle directly from a point and a radius.</p>
<p>Another example is the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgce___make_circ.html">gce_MakeCirc</a></em> providing a framework for defining eight problems encountered in the geometric construction of circles and implementing the eight related construction algorithms.</p>
<p>The object created (or implemented) is an algorithm which can be consulted to find out, in particular:</p>
<ul>
<li>its result, which is a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___circ.html">gp_Circ</a></em>, and</li>
<li>its status. Here, the status indicates whether or not the construction was successful.</li>
</ul>
<p>If it was unsuccessful, the status gives the reason for the failure.</p>
<div class="fragment"><div class="line">gp_Pnt P1 (0.,0.,0.);</div><div class="line">gp_Pnt P2 (0.,10.,0.);</div><div class="line">gp_Pnt P3 (10.,0.,0.);</div><div class="line">gce_MakeCirc MC (P1,P2,P3);</div><div class="line">if (MC.IsDone()) {</div><div class="line">    const gp_Circ&amp; C = MC.Value();</div><div class="line">}</div></div><!-- fragment --><p>In addition, <em> gce</em>, <em> GCE2d</em> and <em> GC</em> each have a <em>Root</em> class. This class is the root of all classes in the package, which return a status. The returned status (successful construction or construction error) is described by the enumeration <em>gce_ErrorType</em>.</p>
<p>Note, that classes, which construct geometric transformations do not return a status, and therefore do not inherit from <em>Root</em>.</p>
<h3><a class="anchor" id="occt_modat_1_2_1"></a>
Simple geometric entities</h3>
<p>The following algorithms used to build entities from <em>gp</em> package are provided by <em>gce</em> package.</p><ul>
<li>2D line parallel to another at a distance,</li>
<li>2D line parallel to another passing through a point,</li>
<li>2D circle passing through two points,</li>
<li>2D circle parallel to another at a distance,</li>
<li>2D circle parallel to another passing through a point,</li>
<li>2D circle passing through three points,</li>
<li>2D circle from a center and a radius,</li>
<li>2D hyperbola from five points,</li>
<li>2D hyperbola from a center and two apexes,</li>
<li>2D ellipse from five points,</li>
<li>2D ellipse from a center and two apexes,</li>
<li>2D parabola from three points,</li>
<li>2D parabola from a center and an apex,</li>
<li>line parallel to another passing through a point,</li>
<li>line passing through two points,</li>
<li>circle coaxial to another passing through a point,</li>
<li>circle coaxial to another at a given distance,</li>
<li>circle passing through three points,</li>
<li>circle with its center, radius, and normal to the plane,</li>
<li>circle with its axis (center + normal),</li>
<li>hyperbola with its center and two apexes,</li>
<li>ellipse with its center and two apexes,</li>
<li>plane passing through three points,</li>
<li>plane from its normal,</li>
<li>plane parallel to another plane at a given distance,</li>
<li>plane parallel to another passing through a point,</li>
<li>plane from an array of points,</li>
<li>cylinder from a given axis and a given radius,</li>
<li>cylinder from a circular base,</li>
<li>cylinder from three points,</li>
<li>cylinder parallel to another cylinder at a given distance,</li>
<li>cylinder parallel to another cylinder passing through a point,</li>
<li>cone from four points,</li>
<li>cone from a given axis and two passing points,</li>
<li>cone from two points (an axis) and two radii,</li>
<li>cone parallel to another at a given distance,</li>
<li>cone parallel to another passing through a point,</li>
<li>all transformations (rotations, translations, mirrors,scaling transformations, etc.).</li>
</ul>
<p>Each class from <em>gp</em> package, such as <em>Circ, Circ2d, Mirror, Mirror2d</em>, etc., has the corresponding <em>MakeCirc, MakeCirc2d, MakeMirror, MakeMirror2d</em>, etc. class from <em>gce</em> package.</p>
<p>It is possible to create a point using a <em>gce</em> package class, then question it to recover the corresponding <em>gp</em> object.</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a> Point1,Point2; </div><div class="line">...</div><div class="line"><span class="comment">//Initialization of Point1 and Point2 </span></div><div class="line">gce_MakeLin2d L = <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgce___make_lin2d.html">gce_MakeLin2d</a>(Point1,Point2); </div><div class="line"><span class="keywordflow">if</span> (L.Status() == <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/gce___error_type_8hxx.html#a5004bbccd7c5a5e222822ef54783ddc9a9f2d628bcd7ffc86902b1883cd8324ac">gce_Done</a>() ){ </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___lin2d.html">gp_Lin2d</a> l = L.Value(); </div><div class="line">}</div></div><!-- fragment --><p>This is useful if you are uncertain as to whether the arguments can create the <em>gp</em> object without raising an exception. In the case above, if <em>Point1</em> and <em>Point2</em> are closer than the tolerance value required by <em>MakeLin2d</em>, the function <em>Status</em> will return the enumeration <em>gce_ConfusedPoint</em>. This tells you why the <em>gp</em> object cannot be created. If you know that the points <em>Point1</em> and <em>Point2</em> are separated by the value exceeding the tolerance value, then you may create the <em>gp</em> object directly, as follows:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___lin2d.html">gp_Lin2d</a> l = <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgce___make_lin2d.html">gce_MakeLin2d</a>(Point1,Point2); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modat_1_2_2"></a>
Geometric entities manipulated by handle</h3>
<p><em>GC</em> and <em>GCE2d</em> packages provides an implementation of algorithms used to build entities from <em>Geom</em> and <em>Geom2D</em> packages. They implement the same algorithms as the <em>gce</em> package, and also contain algorithms for trimmed surfaces and curves. The following algorithms are available:</p><ul>
<li>arc of a circle trimmed by two points,</li>
<li>arc of a circle trimmed by two parameters,</li>
<li>arc of a circle trimmed by one point and one parameter,</li>
<li>arc of an ellipse from an ellipse trimmed by two points,</li>
<li>arc of an ellipse from an ellipse trimmed by two parameters,</li>
<li>arc of an ellipse from an ellipse trimmed by one point and one parameter,</li>
<li>arc of a parabola from a parabola trimmed by two points,</li>
<li>arc of a parabola from a parabola trimmed by two parameters,</li>
<li>arc of a parabola from a parabola trimmed by one point and one parameter,</li>
<li>arc of a hyperbola from a hyperbola trimmed by two points,</li>
<li>arc of a hyperbola from a hyperbola trimmed by two parameters,</li>
<li>arc of a hyperbola from a hyperbola trimmed by one point and one parameter,</li>
<li>segment of a line from two points,</li>
<li>segment of a line from two parameters,</li>
<li>segment of a line from one point and one parameter,</li>
<li>trimmed cylinder from a circular base and a height,</li>
<li>trimmed cylinder from three points,</li>
<li>trimmed cylinder from an axis, a radius, and a height,</li>
<li>trimmed cone from four points,</li>
<li>trimmed cone from two points (an axis) and a radius,</li>
<li>trimmed cone from two coaxial circles.</li>
</ul>
<p>Each class from <em>GCE2d</em> package, such as <em>Circle, Ellipse, Mirror</em>, etc., has the corresponding <em>MakeCircle, MakeEllipse, MakeMirror</em>, etc. class from <em>Geom2d</em> package. Besides, the class <em>MakeArcOfCircle</em> returns an object of type <em>TrimmedCurve</em> from <em>Geom2d</em>.</p>
<p>Each class from <em>GC</em> package, such as <em>Circle, Ellipse, Mirror</em>, etc., has the corresponding <em>MakeCircle, MakeEllipse, MakeMirror</em>, etc. class from <em>Geom</em> package. The following classes return objects of type <em>TrimmedCurve</em> from <em>Geom</em>:</p><ul>
<li><em>MakeArcOfCircle</em></li>
<li><em>MakeArcOfEllipse</em></li>
<li><em>MakeArcOfHyperbola</em></li>
<li><em>MakeArcOfParabola</em></li>
<li><em>MakeSegment</em></li>
</ul>
<h2><a class="anchor" id="occt_modat_1_3"></a>
Conversion to and from BSplines</h2>
<p>The Conversion to and from BSplines component has two distinct purposes:</p><ul>
<li>Firstly, it provides a homogeneous formulation which can be used to describe any curve or surface. This is useful for writing algorithms for a single data structure model. The BSpline formulation can be used to represent most basic geometric objects provided by the components which describe geometric data structures ("Fundamental Geometry Types", "2D Geometry Types" and "3D Geometry Types" components).</li>
<li>Secondly, it can be used to divide a BSpline curve or surface into a series of curves or surfaces, thereby providing a higher degree of continuity. This is useful for writing algorithms which require a specific degree of continuity in the objects to which they are applied. Discontinuities are situated on the boundaries of objects only.</li>
</ul>
<p>The "Conversion to and from BSplines" component is composed of three packages.</p>
<p>The <em> Convert </em> package provides algorithms to convert the following into a BSpline curve or surface:</p>
<ul>
<li>a bounded curve based on an elementary 2D curve (line, circle or conic) from the <em> gp </em> package,</li>
<li>a bounded surface based on an elementary surface (cylinder, cone, sphere or torus) from the <em> gp</em> package,</li>
<li>a series of adjacent 2D or 3D Bezier curves defined by their poles.</li>
</ul>
<p>These algorithms compute the data needed to define the resulting BSpline curve or surface. This elementary data (degrees, periodic characteristics, poles and weights, knots and multiplicities) may then be used directly in an algorithm, or can be used to construct the curve or the surface by calling the appropriate constructor provided by the classes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___b_spline_curve.html">Geom2d_BSplineCurve</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___b_spline_curve.html">Geom_BSplineCurve</a> </em> or <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___b_spline_surface.html">Geom_BSplineSurface</a></em>.</p>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_convert.html">Geom2dConvert</a></em> package provides the following:</p>
<ul>
<li>a global function which is used to construct a BSpline curve from a bounded curve based on a 2D curve from the Geom2d package,</li>
<li>a splitting algorithm which computes the points at which a 2D BSpline curve should be cut in order to obtain arcs with the same degree of continuity,</li>
<li>global functions used to construct the BSpline curves created by this splitting algorithm, or by other types of segmentation of the BSpline curve,</li>
<li>an algorithm which converts a 2D BSpline curve into a series of adjacent Bezier curves.</li>
</ul>
<p>The <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_convert.html">GeomConvert</a></em> package also provides the following:</p>
<ul>
<li>a global function used to construct a BSpline curve from a bounded curve based on a curve from the Geom package,</li>
<li>a splitting algorithm, which computes the points at which a BSpline curve should be cut in order to obtain arcs with the same degree of continuity,</li>
<li>global functions to construct BSpline curves created by this splitting algorithm, or by other types of BSpline curve segmentation,</li>
<li>an algorithm, which converts a BSpline curve into a series of adjacent Bezier curves,</li>
<li>a global function to construct a BSpline surface from a bounded surface based on a surface from the Geom package,</li>
<li>a splitting algorithm, which determines the curves along which a BSpline surface should be cut in order to obtain patches with the same degree of continuity,</li>
<li>global functions to construct BSpline surfaces created by this splitting algorithm, or by other types of BSpline surface segmentation,</li>
<li>an algorithm, which converts a BSpline surface into a series of adjacent Bezier surfaces,</li>
<li>an algorithm, which converts a grid of adjacent Bezier surfaces into a BSpline surface.</li>
</ul>
<h2><a class="anchor" id="occt_modat_1_4"></a>
Points on Curves</h2>
<p>The Points on Curves component comprises high level functions providing an API for complex algorithms that compute points on a 2D or 3D curve.</p>
<p>The following characteristic points exist on parameterized curves in 3d space:</p><ul>
<li>points equally spaced on a curve,</li>
<li>points distributed along a curve with equal chords,</li>
<li>a point at a given distance from another point on a curve.</li>
</ul>
<p><em>GCPnts</em> package provides algorithms to calculate such points:</p><ul>
<li><em>AbscissaPoint</em> calculates a point on a curve at a given distance from another point on the curve.</li>
<li><em>UniformAbscissa</em> calculates a set of points at a given abscissa on a curve.</li>
<li><em>UniformDeflection</em> calculates a set of points at maximum constant deflection between the curve and the polygon that results from the computed points.</li>
</ul>
<h3>Example: Visualizing a curve.</h3>
<p>Let us take an adapted curve <b>C</b>, i.e. an object which is an interface between the services provided by either a 2D curve from the package Geom2d (in case of an Adaptor_Curve2d curve) or a 3D curve from the package Geom (in case of an Adaptor_Curve curve), and the services required on the curve by the computation algorithm. The adapted curve is created in the following way:</p>
<p><b>2D case :</b> </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a>) mycurve = ... ; </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_adaptor___curve.html">Geom2dAdaptor_Curve</a> C (mycurve) ; </div></div><!-- fragment --><p><b>3D case :</b> </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___curve.html">Geom_Curve</a>) mycurve = ... ; </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_adaptor___curve.html">GeomAdaptor_Curve</a> C (mycurve) ; </div></div><!-- fragment --><p>The algorithm is then constructed with this object:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_g_c_pnts___uniform_deflection.html">GCPnts_UniformDeflection</a> myAlgo () ; </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Deflection = ... ; </div><div class="line">myAlgo.Initialize ( C , Deflection ) ; </div><div class="line"><span class="keywordflow">if</span> ( myAlgo.IsDone() ) </div><div class="line">{</div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> nbr = myAlgo.NbPoints() ; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> param ; </div><div class="line">   <span class="keywordflow">for</span> ( <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> i = 1 ; i &lt;= nbr ; i++ ) </div><div class="line">  { </div><div class="line">    param = myAlgo.Parameter (i) ; </div><div class="line">    ...</div><div class="line">  } </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="occt_modat_1_5"></a>
Extrema</h2>
<p>The classes to calculate the minimum distance between points, curves, and surfaces in 2d and 3d are provided by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i.html">GeomAPI</a></em> and <em>Geom2dAPI</em> packages.</p>
<p>These packages calculate the extrema of distance between:</p><ul>
<li>point and a curve,</li>
<li>point and a surface,</li>
<li>two curves,</li>
<li>a curve and a surface,</li>
<li>two surfaces.</li>
</ul>
<h3>Extrema between Point and Curve / Surface</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> class allows calculation of all extrema between a point and a curve. Extrema are the lengths of the segments orthogonal to the curve. The <em>GeomAPI_ProjectPointOnSurface</em> class allows calculation of all extrema between a point and a surface. Extrema are the lengths of the segments orthogonal to the surface. These classes use the "Projection" criteria for optimization.</p>
<h3>Extrema between Curves</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___extrema_curve_curve.html">Geom2dAPI_ExtremaCurveCurve</a></em> class allows calculation of all minimal distances between two 2D geometric curves. The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___extrema_curve_curve.html">GeomAPI_ExtremaCurveCurve</a></em> class allows calculation of all minimal distances between two 3D geometric curves. These classes use Euclidean distance as the criteria for optimization.</p>
<h3>Extrema between Curve and Surface</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___extrema_curve_surface.html">GeomAPI_ExtremaCurveSurface</a></em> class allows calculation of one extrema between a 3D curve and a surface. Extrema are the lengths of the segments orthogonal to the curve and the surface. This class uses the "Projection" criteria for optimization.</p>
<h3>Extrema between Surfaces</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___extrema_surface_surface.html">GeomAPI_ExtremaSurfaceSurface</a></em> class allows calculation of one minimal and one maximal distance between two surfaces. This class uses Euclidean distance to compute the minimum, and "Projection" criteria to compute the maximum.</p>
<h1><a class="anchor" id="occt_modat_2"></a>
2D Geometry</h1>
<p><em>Geom2d</em> package defines geometric objects in 2dspace. All geometric entities are STEP processed. The objects are handled by reference.</p>
<p>In particular, <em>Geom2d</em> package provides classes for:</p><ul>
<li>description of points, vectors and curves,</li>
<li>their positioning in the plane using coordinate systems,</li>
<li>their geometric transformation, by applying translations, rotations, symmetries, scaling transformations and combinations thereof.</li>
</ul>
<p>The following objects are available:</p><ul>
<li>point,</li>
<li>Cartesian point,</li>
<li>vector,</li>
<li>direction,</li>
<li>vector with magnitude,</li>
<li>axis,</li>
<li>curve,</li>
<li>line,</li>
<li>conic: circle, ellipse, hyperbola, parabola,</li>
<li>rounded curve: trimmed curve, NURBS curve, Bezier curve,</li>
<li>offset curve.</li>
</ul>
<p>Before creating a geometric object, it is necessary to decide how the object is handled. The objects provided by <em>Geom2d</em> package are handled by reference rather than by value. Copying an instance copies the handle, not the object, so that a change to one instance is reflected in each occurrence of it. If a set of object instances is needed rather than a single object instance, <em>TColGeom2d</em> package can be used. This package provides standard and frequently used instantiations of one-dimensional arrays and sequences for curves from <em>Geom2d</em> package. All objects are available in two versions:</p><ul>
<li>handled by reference and</li>
<li>handled by value.</li>
</ul>
<p>The key characteristic of <em> Geom2d </em> curves is that they are parameterized. Each class provides functions to work with the parametric equation of the curve, and, in particular, to compute the point of parameter u on a curve and the derivative vectors of order 1, 2.., N at this point.</p>
<p>As a consequence of the parameterization, a <em> Geom2d </em> curve is naturally oriented.</p>
<p>Parameterization and orientation differentiate elementary <em>Geom2d</em>curves from their equivalent as provided by <em> gp</em> package. <em>Geom2d</em> package provides conversion functions to transform a <em> Geom2d</em> object into a <em> gp</em> object, and vice-versa, when this is possible.</p>
<p>Moreover, <em> Geom2d</em> package provides more complex curves, including Bezier curves, BSpline curves, trimmed curves and offset curves.</p>
<p><em> Geom2d </em> objects are organized according to an inheritance structure over several levels.</p>
<p>Thus, an ellipse (specific class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___ellipse.html">Geom2d_Ellipse</a></em>) is also a conical curve and inherits from the abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___conic.html">Geom2d_Conic</a></em>, while a Bezier curve (concrete class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___bezier_curve.html">Geom2d_BezierCurve</a></em>) is also a bounded curve and inherits from the abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___bounded_curve.html">Geom2d_BoundedCurve</a></em>; both these examples are also curves (abstract class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>). Curves, points and vectors inherit from the abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___geometry.html">Geom2d_Geometry</a>,</em> which describes the properties common to any geometric object from the <em>Geom2d</em> package.</p>
<p>This inheritance structure is open and it is possible to describe new objects, which inherit from those provided in the <em>Geom2d</em> package, provided that they respect the behavior of the classes from which they are to inherit.</p>
<p>Finally, <em> Geom2d</em> objects can be shared within more complex data structures. This is why they are used within topological data structures, for example.</p>
<p><em>Geom2d</em>package uses the services of the <em> gp</em> package to:</p><ul>
<li>implement elementary algebraic calculus and basic analytic geometry,</li>
<li>describe geometric transformations which can be applied to <em> Geom2d</em> objects,</li>
<li>describe the elementary data structures of <em>Geom2d</em> objects.</li>
</ul>
<p>However, the <em> Geom2d</em> package essentially provides data structures and not algorithms. You can refer to the <em> GCE2d </em> package to find more evolved construction algorithms for <em> Geom2d </em> objects.</p>
<h1><a class="anchor" id="occt_modat_3"></a>
3D Geometry</h1>
<p>The <em>Geom</em> package defines geometric objects in 3d space and contains all basic geometric transformations, such as identity, rotation, translation, mirroring, scale transformations, combinations of transformations, etc. as well as special functions depending on the reference definition of the geometric object (e.g. addition of a control point on a B-Spline curve,modification of a curve, etc.). All geometrical entities are STEP processed.</p>
<p>In particular, it provides classes for:</p><ul>
<li>description of points, vectors, curves and surfaces,</li>
<li>their positioning in 3D space using axis or coordinate systems, and</li>
<li>their geometric transformation, by applying translations, rotations, symmetries, scaling transformations and combinations thereof.</li>
</ul>
<p>The following objects are available:</p><ul>
<li>Point</li>
<li>Cartesian point</li>
<li>Vector</li>
<li>Direction</li>
<li>Vector with magnitude</li>
<li>Axis</li>
<li>Curve</li>
<li>Line</li>
<li>Conic: circle, ellipse, hyperbola, parabola</li>
<li>Offset curve</li>
<li>Elementary surface: plane, cylinder, cone, sphere, torus</li>
<li>Bounded curve: trimmed curve, NURBS curve, Bezier curve</li>
<li>Bounded surface: rectangular trimmed surface, NURBS surface,Bezier surface</li>
<li>Swept surface: surface of linear extrusion, surface of revolution</li>
<li>Offset surface.</li>
</ul>
<p>The key characteristic of <em>Geom</em> curves and surfaces is that they are parameterized. Each class provides functions to work with the parametric equation of the curve or surface, and, in particular, to compute:</p><ul>
<li>the point of parameter u on a curve, or</li>
<li>the point of parameters (u, v) on a surface. together with the derivative vectors of order 1, 2, ... N at this point.</li>
</ul>
<p>As a consequence of this parameterization, a Geom curve or surface is naturally oriented.</p>
<p>Parameterization and orientation differentiate elementary Geom curves and surfaces from the classes of the same (or similar) names found in <em> gp</em> package. <em>Geom</em> package also provides conversion functions to transform a Geom object into a <em> gp</em> object, and vice-versa, when such transformation is possible.</p>
<p>Moreover, <em> Geom </em>package provides more complex curves and surfaces, including:</p><ul>
<li>Bezier and BSpline curves and surfaces,</li>
<li>swept surfaces, for example surfaces of revolution and surfaces of linear extrusion,</li>
<li>trimmed curves and surfaces, and</li>
<li>offset curves and surfaces.</li>
</ul>
<p>Geom objects are organized according to an inheritance structure over several levels. Thus, a sphere (concrete class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___spherical_surface.html">Geom_SphericalSurface</a></em>) is also an elementary surface and inherits from the abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___elementary_surface.html">Geom_ElementarySurface</a></em>, while a Bezier surface (concrete class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___bezier_surface.html">Geom_BezierSurface</a></em>) is also a bounded surface and inherits from the abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___bounded_surface.html">Geom_BoundedSurface</a></em>; both these examples are also surfaces (abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em>). Curves, points and vectors inherit from the abstract class <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___geometry.html">Geom_Geometry</a>,</em> which describes the properties common to any geometric object from the <em>Geom</em> package.</p>
<p>This inheritance structure is open and it is possible to describe new objects, which inherit from those provided in the Geom package, on the condition that they respect the behavior of the classes from which they are to inherit.</p>
<p>Finally, Geom objects can be shared within more complex data structures. This is why they are used within topological data structures, for example.</p>
<p>If a set of object instances is needed rather than a single object instance, <em>TColGeom</em> package can be used. This package provides instantiations of one- and two-dimensional arrays and sequences for curves from <em>Geom</em> package. All objects are available in two versions:</p><ul>
<li>handled by reference and</li>
<li>handled by value.</li>
</ul>
<p>The <em> Geom</em> package uses the services of the <em> gp</em> package to:</p><ul>
<li>implement elementary algebraic calculus and basic analytic geometry,</li>
<li>describe geometric transformations which can be applied to Geom objects,</li>
<li>describe the elementary data structures of Geom objects.</li>
</ul>
<p>However, the Geom package essentially provides data structures, not algorithms.</p>
<p>You can refer to the <em> GC</em> package to find more evolved construction algorithms for Geom objects.</p>
<h1><a class="anchor" id="occt_modat_4"></a>
Properties of Shapes</h1>
<h2><a class="anchor" id="occt_modat_4_1"></a>
Local Properties of Shapes</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_l_prop.html">BRepLProp</a></em> package provides the Local Properties of Shapes component, which contains algorithms computing various local properties on edges and faces in a BRep model.</p>
<p>The local properties which may be queried are:</p>
<ul>
<li>for a point of parameter u on a curve which supports an edge :<ul>
<li>the point,</li>
<li>the derivative vectors, up to the third degree,</li>
<li>the tangent vector,</li>
<li>the normal,</li>
<li>the curvature, and the center of curvature;</li>
</ul>
</li>
<li>for a point of parameter (u, v) on a surface which supports a face :<ul>
<li>the point,</li>
<li>the derivative vectors, up to the second degree,</li>
<li>the tangent vectors to the u and v isoparametric curves,</li>
<li>the normal vector,</li>
<li>the minimum or maximum curvature, and the corresponding directions of curvature;</li>
</ul>
</li>
<li>the degree of continuity of a curve which supports an edge, built by the concatenation of two other edges, at their junction point.</li>
</ul>
<p>Analyzed edges and faces are described as <em> BRepAdaptor</em> curves and surfaces, which provide shapes with an interface for the description of their geometric support. The base point for local properties is defined by its u parameter value on a curve, or its (u, v) parameter values on a surface.</p>
<h2><a class="anchor" id="occt_modat_4_2"></a>
Local Properties of Curves and Surfaces</h2>
<p>The "Local Properties of Curves and Surfaces" component provides algorithms for computing various local properties on a Geom curve (in 2D or 3D space) or a surface. It is composed of:</p>
<ul>
<li><em> Geom2dLProp</em> package, which allows computing Derivative and Tangent vectors (normal and curvature) of a parametric point on a 2D curve;</li>
<li><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_l_prop.html">GeomLProp</a> </em> package, which provides local properties on 3D curves and surfaces</li>
<li><em> LProp </em> package, which provides an enumeration used to characterize a particular point on a 2D curve.</li>
</ul>
<p>Curves are either <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___curve.html">Geom_Curve</a> </em> curves (in 3D space) or <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a> </em> curves (in the plane). Surfaces are <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a> </em> surfaces. The point on which local properties are calculated is defined by its u parameter value on a curve, and its (u,v) parameter values on a surface.</p>
<p>It is possible to query the same local properties for points as mentioned above, and additionally for 2D curves:</p>
<ul>
<li>the points corresponding to a minimum or a maximum of curvature;</li>
<li>the inflection points.</li>
</ul>
<h4>Example: How to check the surface concavity</h4>
<p>To check the concavity of a surface, proceed as follows:</p>
<ol type="1">
<li>Sample the surface and compute at each point the Gaussian curvature.</li>
<li>If the value of the curvature changes of sign, the surface is concave or convex depending on the point of view.</li>
<li>To compute a Gaussian curvature, use the class <em> SLprops</em> from <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_l_prop.html">GeomLProp</a></em>, which instantiates the generic class <em> SLProps </em>from <em> LProp</em> and use the method <em> GaussianCurvature</em>.</li>
</ol>
<h2><a class="anchor" id="occt_modat_4_2a"></a>
Continuity of Curves and Surfaces</h2>
<p>Types of supported continuities for curves and surfaces are described in <em>GeomAbs_Shape</em> enumeration.</p>
<p>In respect of curves, the following types of continuity are supported (see the figure below):</p><ul>
<li>C0 (<em>GeomAbs_C0</em>) - parametric continuity. It is the same as G0 (geometric continuity), so the last one is not represented by separate variable.</li>
<li>G1 (<em>GeomAbs_G1</em>) - tangent vectors on left and on right are parallel.</li>
<li>C1 (<em>GeomAbs_C1</em>) - indicates the continuity of the first derivative.</li>
<li>G2 (<em>GeomAbs_G2</em>) - in addition to G1 continuity, the centers of curvature on left and on right are the same.</li>
<li>C2 (<em>GeomAbs_C2</em>) - continuity of all derivatives till the second order.</li>
<li>C3 (<em>GeomAbs_C3</em>) - continuity of all derivatives till the third order.</li>
<li>CN (<em>GeomAbs_CN</em>) - continuity of all derivatives till the N-th order (infinite order of continuity).</li>
</ul>
<p><em>Note:</em> Geometric continuity (G1, G2) means that the curve can be reparametrized to have parametric (C1, C2) continuity.</p>
<div class="image">
<object type="image/svg+xml" data="modeling_data_continuity_curves.svg">modeling_data_continuity_curves.svg</object>
<div class="caption">
Continuity of Curves</div></div>
<p> The following types of surface continuity are supported:</p><ul>
<li>C0 (<em>GeomAbs_C0</em>) - parametric continuity (the surface has no points or curves of discontinuity).</li>
<li>G1 (<em>GeomAbs_G1</em>) - surface has single tangent plane in each point.</li>
<li>C1 (<em>GeomAbs_C1</em>) - indicates the continuity of the first derivatives.</li>
<li>G2 (<em>GeomAbs_G2</em>) - in addition to G1 continuity, principal curvatures and directions are continuous.</li>
<li>C2 (<em>GeomAbs_C2</em>) - continuity of all derivatives till the second order.</li>
<li>C3 (<em>GeomAbs_C3</em>) - continuity of all derivatives till the third order.</li>
<li>CN (<em>GeomAbs_CN</em>) - continuity of all derivatives till the N-th order (infinite order of continuity).</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="modeling_data_continuity_surfaces.svg">modeling_data_continuity_surfaces.svg</object>
<div class="caption">
Continuity of Surfaces</div></div>
<p> Against single surface, the connection of two surfaces (see the figure above) defines its continuity in each intersection point only. Smoothness of connection is a minimal value of continuities on the intersection curve.</p>
<h2><a class="anchor" id="occt_modat_4_2b"></a>
Regularity of Shared Edges</h2>
<p>Regularity of an edge is a smoothness of connection of two faces sharing this edge. In other words, regularity is a minimal continuity between connected faces in each point on edge.</p>
<p>Edge's regularity can be set by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep___builder.html#a23487dc27dd71d37ded2de732ccdf4b6">BRep_Builder::Continuity</a></em> method. To get the regularity use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep___tool.html#aca057438ec0876375dc959d397e5f9e7">BRep_Tool::Continuity</a></em> method.</p>
<p>Some algorithms like <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_6">Fillet</a> set regularity of produced edges by their own algorithms. On the other hand, some other algorithms (like <a class="el" href="occt_user_guides__boolean_operations.html">Boolean Operations</a>, <a class="el" href="occt_user_guides__shape_healing.html">Shape Healing</a>, etc.) do not set regularity. If the regularity is needed to be set correctly on a shape, the method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_lib.html#a03ae78ba383db0623f192eb29b44d419">BRepLib::EncodeRegularity</a></em> can be used. It calculates and sets correct values for all edges of the shape.</p>
<p>The regularity flag is extensively used by the following high level algorithms: <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_6_1_2">Chamfer</a>, <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_7_3">Draft Angle</a>, <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_10">Hidden Line Removal</a>, <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_9_2_3">Gluer</a>.</p>
<h2><a class="anchor" id="occt_modat_4_3"></a>
Global Properties of Shapes</h2>
<p>The Global Properties of Shapes component provides algorithms for computing the global properties of a composite geometric system in 3D space, and frameworks to query the computed results.</p>
<p>The global properties computed for a system are :</p><ul>
<li>mass,</li>
<li>mass center,</li>
<li>matrix of inertia,</li>
<li>moment about an axis,</li>
<li>radius of gyration about an axis,</li>
<li>principal properties of inertia such as principal axis, principal moments, and principal radius of gyration.</li>
</ul>
<p>Geometric systems are generally defined as shapes. Depending on the way they are analyzed, these shapes will give properties of:</p>
<ul>
<li>lines induced from the edges of the shape,</li>
<li>surfaces induced from the faces of the shape, or</li>
<li>volumes induced from the solid bounded by the shape.</li>
</ul>
<p>The global properties of several systems may be brought together to give the global properties of the system composed of the sum of all individual systems.</p>
<p>The Global Properties of Shapes component is composed of:</p><ul>
<li>seven functions for computing global properties of a shape: one function for lines, two functions for surfaces and four functions for volumes. The choice of functions depends on input parameters and algorithms used for computation (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_g_prop.html">BRepGProp</a></em> global functions),</li>
<li>a framework for computing global properties for a set of points (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_g_prop___p_g_props.html">GProp_PGProps</a></em>),</li>
<li>a general framework to bring together the global properties retained by several more elementary frameworks, and provide a general programming interface to consult computed global properties.</li>
</ul>
<p>Packages <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_l_prop.html">GeomLProp</a></em> and <em>Geom2dLProp</em> provide algorithms calculating the local properties of curves and surfaces</p>
<p>A curve (for one parameter) has the following local properties:</p><ul>
<li>Point</li>
<li>Derivative</li>
<li>Tangent</li>
<li>Normal</li>
<li>Curvature</li>
<li>Center of curvature.</li>
</ul>
<p>A surface (for two parameters U and V) has the following local properties:</p><ul>
<li>point</li>
<li>derivative for U and V)</li>
<li>tangent line (for U and V)</li>
<li>normal</li>
<li>max curvature</li>
<li>min curvature</li>
<li>main directions of curvature</li>
<li>mean curvature</li>
<li>Gaussian curvature</li>
</ul>
<p>The following methods are available:</p><ul>
<li><em>CLProps</em> &ndash; calculates the local properties of a curve (tangency, curvature,normal);</li>
<li><em>CurAndInf2d</em> &ndash; calculates the maximum and minimum curvatures and the inflection points of 2d curves;</li>
<li><em>SLProps</em> &ndash; calculates the local properties of a surface (tangency, the normal and curvature).</li>
<li><em>Continuity</em> &ndash; calculates regularity at the junction of two curves.</li>
</ul>
<p>Note that the B-spline curve and surface are accepted but they are not cut into pieces of the desired continuity. It is the global continuity, which is seen.</p>
<h2><a class="anchor" id="occt_modat_4_4"></a>
Adaptors for Curves and Surfaces</h2>
<p>Some Open CASCADE Technology general algorithms may work theoretically on numerous types of curves or surfaces.</p>
<p>To do this, they simply get the services required of the analyzed curve or surface through an interface so as to a single API, whatever the type of curve or surface. These interfaces are called adaptors.</p>
<p>For example, <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_adaptor3d___curve.html">Adaptor3d_Curve</a> </em> is the abstract class which provides the required services by an algorithm which uses any 3d curve.</p>
<p><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_adaptor.html">GeomAdaptor</a> </em> package provides interfaces:</p><ul>
<li>On a Geom curve;</li>
<li>On a curve lying on a Geom surface;</li>
<li>On a Geom surface;</li>
</ul>
<p><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_adaptor.html">Geom2dAdaptor</a></em> package provides interfaces :</p><ul>
<li>On a <em>Geom2d</em> curve.</li>
</ul>
<p><em> BRepAdaptor </em> package provides interfaces:</p><ul>
<li>On a Face</li>
<li>On an Edge</li>
</ul>
<p>When you write an algorithm which operates on geometric objects, use <em> Adaptor3d</em> (or <em> Adaptor2d</em>) objects.</p>
<p>As a result, you can use the algorithm with any kind of object, if you provide for this object an interface derived from <em>Adaptor3d</em> or <em>Adaptor2d</em>. These interfaces are easy to use: simply create an adapted curve or surface from a <em>Geom2d</em> curve, and then use this adapted curve as an argument for the algorithm? which requires it.</p>
<h1><a class="anchor" id="occt_modat_5"></a>
Topology</h1>
<p>OCCT Topology allows accessing and manipulating data of objects without dealing with their 2D or 3D representations. Whereas OCCT Geometry provides a description of objects in terms of coordinates or parametric values, Topology describes data structures of objects in parametric space. These descriptions use location in and restriction of parts of this space.</p>
<p>Topological library allows you to build pure topological data structures. Topology defines relationships between simple geometric entities. In this way, you can model complex shapes as assemblies of simpler entities. Due to a built-in non-manifold (or mixed-dimensional) feature, you can build models mixing:</p><ul>
<li>0D entities such as points;</li>
<li>1D entities such as curves;</li>
<li>2D entities such as surfaces;</li>
<li>3D entities such as volumes.</li>
</ul>
<p>You can, for example, represent a single object made of several distinct bodies containing embedded curves and surfaces connected or non-connected to an outer boundary.</p>
<p>Abstract topological data structure describes a basic entity &ndash; a shape, which can be divided into the following component topologies:</p><ul>
<li>Vertex &ndash; a zero-dimensional shape corresponding to a point in geometry;</li>
<li>Edge &ndash; a shape corresponding to a curve, and bound by a vertex at each extremity;</li>
<li>Wire &ndash; a sequence of edges connected by their vertices;</li>
<li>Face &ndash; part of a plane (in 2D geometry) or a surface (in 3D geometry) bounded by a closed wire;</li>
<li>Shell &ndash; a collection of faces connected by some edges of their wire boundaries;</li>
<li>Solid &ndash; a part of 3D space bound by a shell;</li>
<li>Compound solid &ndash; a collection of solids.</li>
</ul>
<p>The wire and the solid can be either infinite or closed.</p>
<p>A face with 3D underlying geometry may also refer to a collection of connected triangles that approximate the underlying surface. The surfaces can be undefined leaving the faces represented by triangles only. If so, the model is purely polyhedral.</p>
<p>Topology defines the relationship between simple geometric entities, which can thus be linked together to represent complex shapes.</p>
<p>Abstract Topology is provided by six packages. The first three packages describe the topological data structure used in Open CASCADE Technology:</p>
<ul>
<li><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a></em> package provides general resources for topology-driven applications. It contains enumerations that are used to describe basic topological notions: topological shape, orientation and state. It also provides methods to manage these enumerations.</li>
<li><em> TopLoc </em>package provides resources to handle 3D local coordinate systems: <em> Datum3D</em>and <em> Location</em>. <em> Datum3D</em> describes an elementary coordinate system, while <em> Location</em> comprises a series of elementary coordinate systems.</li>
<li><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> package describes classes to model and build data structures that are purely topological.</li>
</ul>
<p>Three additional packages provide tools to access and manipulate this abstract topology:</p>
<ul>
<li><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_tools.html">TopTools</a></em> package provides basic tools to use on topological data structures.</li>
<li><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp.html">TopExp</a></em> package provides classes to explore and manipulate the topological data structures described in the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a> package.</li>
<li><em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools.html">BRepTools</a> </em> package provides classes to explore, manipulate, read and write BRep data structures. These more complex data structures combine topological descriptions with additional geometric information, and include rules for evaluating equivalence of different possible representations of the same object, for example, a point.</li>
</ul>
<h2><a class="anchor" id="occt_modat_5_1"></a>
Shape Location</h2>
<p>A local coordinate system can be viewed as either of the following:</p><ul>
<li>A right-handed trihedron with an origin and three orthonormal vectors. The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em> package corresponds to this definition.</li>
<li>A transformation of a +1 determinant, allowing the transformation of coordinates between local and global references frames. This corresponds to the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___trsf.html">gp_Trsf</a></em>.</li>
</ul>
<p><em>TopLoc</em> package distinguishes two notions:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_loc___datum3_d.html">TopLoc_Datum3D</a></em> class provides the elementary reference coordinate, represented by a right-handed orthonormal system of axes or by a right-handed unitary transformation.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_loc___location.html">TopLoc_Location</a></em> class provides the composite reference coordinate made from elementary ones. It is a marker composed of a chain of references to elementary markers. The resulting cumulative transformation is stored in order to avoid recalculating the sum of the transformations for the whole list.</li>
</ul>
<div class="image">
<img src="modeling_data_image005.png" alt="modeling_data_image005.png"/>
<div class="caption">
Structure of TopLoc_Location</div></div>
<p> Two reference coordinates are equal if they are made up of the same elementary coordinates in the same order. There is no numerical comparison. Two coordinates can thus correspond to the same transformation without being equal if they were not built from the same elementary coordinates.</p>
<p>For example, consider three elementary coordinates: R1, R2, R3 The composite coordinates are: C1 = R1 * R2, C2 = R2 * R3 C3 = C1 * R3 C4 = R1 * C2</p>
<p><b>NOTE</b> C3 and C4 are equal because they are both R1 * R2 * R3.</p>
<p>The <em>TopLoc</em> package is chiefly targeted at the topological data structure, but it can be used for other purposes.</p>
<h2>Change of coordinates </h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_loc___datum3_d.html">TopLoc_Datum3D</a></em> class represents a change of elementary coordinates. Such changes must be shared so this class inherits from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em>. The coordinate is represented by a transformation <em>gp_Trsfpackage</em>. This transformation has no scaling factor.</p>
<h2><a class="anchor" id="occt_modat_5_2"></a>
Naming shapes, sub-shapes, their orientation and state</h2>
<p>The <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a></b> package provides general enumerations describing the basic concepts of topology and methods to handle these enumerations. It contains no classes. This package has been separated from the rest of the topology because the notions it contains are sufficiently general to be used by all topological tools. This avoids redefinition of enumerations by remaining independent of modeling resources. The <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a> package defines three notions:</p><ul>
<li><b>Type</b> <em>TopAbs_ShapeEnum</em>;</li>
<li><b>Orientation</b> <em>TopAbs_Orientation</em> ;</li>
<li><b>State</b> <em>StateTopAbs_State</em></li>
</ul>
<h3><a class="anchor" id="occt_modat_5_2_1"></a>
Topological types</h3>
<p><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a> contains the <em>TopAbs_ShapeEnum</em> enumeration,which lists the different topological types:</p><ul>
<li>COMPOUND &ndash; a group of any type of topological objects.</li>
<li>COMPSOLID &ndash; a composite solid is a set of solids connected by their faces. It expands the notions of WIRE and SHELL to solids.</li>
<li>SOLID &ndash; a part of space limited by shells. It is three dimensional.</li>
<li>SHELL &ndash; a set of faces connected by their edges. A shell can be open or closed.</li>
<li>FACE &ndash; in 2D it is a part of a plane; in 3D it is a part of a surface. Its geometry is constrained (trimmed) by contours. It is two dimensional.</li>
<li>WIRE &ndash; a set of edges connected by their vertices. It can be an open or closed contour depending on whether the edges are linked or not.</li>
<li>EDGE &ndash; a topological element corresponding to a restrained curve. An edge is generally limited by vertices. It has one dimension.</li>
<li>VERTEX &ndash; a topological element corresponding to a point. It has zero dimension.</li>
<li>SHAPE &ndash; a generic term covering all of the above.</li>
</ul>
<p>A topological model can be considered as a graph of objects with adjacency relationships. When modeling a part in 2D or 3D space it must belong to one of the categories listed in the ShapeEnum enumeration. The TopAbspackage lists all the objects, which can be found in any model. It cannot be extended but a subset can be used. For example, the notion of solid is useless in 2D.</p>
<p>The terms of the enumeration appear in order from the most complex to the most simple, because objects can contain simpler objects in their description. For example, a face references its wires, edges, and vertices. </p><div class="image">
<img src="modeling_data_image006.png" alt="modeling_data_image006.png"/>
<div class="caption">
ShapeEnum</div></div>
 <h3><a class="anchor" id="occt_modat_5_2_2"></a>
Orientation</h3>
<p>The notion of orientation is represented by the <b>TopAbs_Orientation</b> enumeration. Orientation is a generalized notion of the sense of direction found in various modelers. This is used when a shape limits a geometric domain; and is closely linked to the notion of boundary. The three cases are the following:</p><ul>
<li>Curve limited by a vertex.</li>
<li>Surface limited by an edge.</li>
<li>Space limited by a face.</li>
</ul>
<p>In each case the topological form used as the boundary of a geometric domain of a higher dimension defines two local regions of which one is arbitrarily considered as the <b>default region</b>.</p>
<p>For a curve limited by a vertex the default region is the set of points with parameters greater than the vertex. That is to say it is the part of the curve after the vertex following the natural direction along the curve.</p>
<p>For a surface limited by an edge the default region is on the left of the edge following its natural direction. More precisely it is the region pointed to by the vector product of the normal vector to the surface and the vector tangent to the curve.</p>
<p>For a space limited by a face the default region is found on the negative side of the normal to the surface.</p>
<p>Based on this default region the orientation allows definition of the region to be kept, which is called the <em>interior</em> or <em>material</em>. There are four orientations defining the interior.</p>
<table class="doxtable">
<tr>
<th align="left">Orientation </th><th align="left">Description  </th></tr>
<tr>
<td align="left">FORWARD </td><td align="left">The interior is the default region. </td></tr>
<tr>
<td align="left">REVERSED </td><td align="left">The interior is the region complementary to the default. </td></tr>
<tr>
<td align="left">INTERNAL </td><td align="left">The interior includes both regions. The boundary lies inside the material. For example a surface inside a solid. </td></tr>
<tr>
<td align="left">EXTERNAL </td><td align="left">The interior includes neither region. The boundary lies outside the material. For example an edge in a wire-frame model. </td></tr>
</table>
<div class="image">
<img src="modeling_data_image007.png" alt="modeling_data_image007.png"/>
<div class="caption">
Four Orientations</div></div>
<p> The notion of orientation is a very general one, and it can be used in any context where regions or boundaries appear. Thus, for example, when describing the intersection of an edge and a contour it is possible to describe not only the vertex of intersection but also how the edge crosses the contour considering it as a boundary. The edge would therefore be divided into two regions: exterior and interior and the intersection vertex would be the boundary. Thus an orientation can be associated with an intersection vertex as in the following figure:</p>
<table class="doxtable">
<tr>
<th align="left">Orientation </th><th align="left">Association  </th></tr>
<tr>
<td align="left">FORWARD </td><td align="left">Entering </td></tr>
<tr>
<td align="left">REVERSED </td><td align="left">Exiting </td></tr>
<tr>
<td align="left">INTERNAL </td><td align="left">Touching from inside </td></tr>
<tr>
<td align="left">EXTERNAL </td><td align="left">Touching from outside </td></tr>
</table>
<div class="image">
<img src="modeling_data_image008.png" alt="modeling_data_image008.png"/>
<div class="caption">
Four orientations of intersection vertices</div></div>
<p>Along with the Orientation enumeration the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a></em> package defines four methods:</p>
<h3><a class="anchor" id="occt_modat_5_2_3"></a>
State</h3>
<p>The <b>TopAbs_State</b> enumeration described the position of a vertex or a set of vertices with respect to a region. There are four terms:</p>
<table class="doxtable">
<tr>
<th align="left">Position </th><th align="left">Description  </th></tr>
<tr>
<td align="left">IN </td><td align="left">The point is interior. </td></tr>
<tr>
<td align="left">OUT </td><td align="left">The point is exterior. </td></tr>
<tr>
<td align="left">ON </td><td align="left">The point is on the boundary(within tolerance). </td></tr>
<tr>
<td align="left">UNKNOWN </td><td align="left">The state of the point is indeterminate. </td></tr>
</table>
<p>The UNKNOWN term has been introduced because this enumeration is often used to express the result of a calculation, which can fail. This term can be used when it is impossible to know if a point is inside or outside, which is the case with an open wire or face.</p>
<div class="image">
<img src="modeling_data_image009.png" alt="modeling_data_image009.png"/>
<div class="caption">
The four states</div></div>
<p> The State enumeration can also be used to specify various parts of an object. The following figure shows the parts of an edge intersecting a face.</p>
<div class="image">
<img src="modeling_data_image010.png" alt="modeling_data_image010.png"/>
<div class="caption">
State specifies the parts of an edge intersecting a face</div></div>
 <h2><a class="anchor" id="occt_modat_5_3"></a>
Manipulating shapes and sub-shapes</h2>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> package describes the topological data structure with the following characteristics:</p><ul>
<li>reference to an abstract shape with neither orientation nor location.</li>
<li>Access to the data structure through the tool classes.</li>
</ul>
<p>As stated above, OCCT Topology describes data structures of objects in parametric space. These descriptions use localization in and restriction of parts of this space. The types of shapes, which can be described in these terms, are the vertex, the face and the shape. The vertex is defined in terms of localization in parametric space, and the face and shape, in terms of restriction of this space.</p>
<p>OCCT topological descriptions also allow the simple shapes defined in these terms to be combined into sets. For example, a set of edges forms a wire; a set of faces forms a shell, and a set of solids forms a composite solid (CompSolid in Open CASCADE Technology). You can also combine shapes of either sort into compounds. Finally, you can give a shape an orientation and a location.</p>
<p>Listing shapes in order of complexity from vertex to composite solid leads us to the notion of the data structure as knowledge of how to break a shape down into a set of simpler shapes. This is in fact, the purpose of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> package.</p>
<p>The model of a shape is a shareable data structure because it can be used by other shapes. (An edge can be used by more than one face of a solid). A shareable data structure is handled by reference. When a simple reference is insufficient, two pieces of information are added: an orientation and a local coordinate reference.</p><ul>
<li>An orientation tells how the referenced shape is used in a boundary (<em>Orientation</em> from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a></em>).</li>
<li>A local reference coordinate (<em>Location</em> from <em>TopLoc</em>) allows referencing a shape at a position different from that of its definition.</li>
</ul>
<p>The <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></b> class is the root of all shape descriptions. It contains a list of shapes. Classes inheriting <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></b> can carry the description of a geometric domain if necessary (for example, a geometric point associated with a TVertex). A <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></b> is a description of a shape in its definition frame of reference. This class is manipulated by reference.</p>
<p>The <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></b> class describes a reference to a shape. It contains a reference to an underlying abstract shape, an orientation,and a local reference coordinate. This class is manipulated by value and thus cannot be shared.</p>
<p>The class representing the underlying abstract shape is never referenced directly. The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> class is always used to refer to it.</p>
<p>The information specific to each shape (the geometric support) is always added by inheritance to classes deriving from <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></b>. The following figures show the example of a shell formed from two faces connected by an edge.</p>
<div class="image">
<img src="modeling_data_image011.png" alt="modeling_data_image011.png"/>
<div class="caption">
Structure of a shell formed from two faces</div></div>
 <div class="image">
<img src="modeling_data_image012.png" alt="modeling_data_image012.png"/>
<div class="caption">
Data structure of the above shell</div></div>
<p> In the previous diagram, the shell is described by the underlying shape TS, and the faces by TF1 and TF2. There are seven edges from TE1 to TE7 and six vertices from TV1 to TV6.</p>
<p>The wire TW1 references the edges from TE1 to TE4; TW2 references from TE4 to TE7.</p>
<p>The vertices are referenced by the edges as follows:TE1(TV1,TV4), TE2(TV1,TV2), TE3(TV2,TV3), TE4(TV3,TV4), TE5(TV4,TV5), TE6(T5,TV6),TE7(TV3,TV6).</p>
<p><b>Note</b> that this data structure does not contain any <em>back references</em>. All references go from more complex underlying shapes to less complex ones. The techniques used to access the information are described later. The data structure is as compact as possible. Sub-objects can be shared among different objects.</p>
<p>Two very similar objects, perhaps two versions of the same object, might share identical sub-objects. The usage of local coordinates in the data structure allows the description of a repetitive sub-structure to be shared.</p>
<p>The compact data structure avoids the loss of information associated with copy operations which are usually used in creating a new version of an object or when applying a coordinate change.</p>
<p>The following figure shows a data structure containing two versions of a solid. The second version presents a series of identical holes bored at different positions. The data structure is compact and yet keeps all information on the sub-elements.</p>
<p>The three references from <em>TSh2</em> to the underlying face <em>TFcyl</em> have associated local coordinate systems, which correspond to the successive positions of the hole. </p><div class="image">
<img src="modeling_data_image013.png" alt="modeling_data_image013.png"/>
<div class="caption">
Data structure containing two versions of a solid</div></div>
 <h2>Classes inheriting <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> </h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> is based on class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> and the class defining its underlying shape. This has certain advantages, but the major drawback is that these classes are too general. Different shapes they could represent do not type them (Vertex, Edge, etc.) hence it is impossible to introduce checks to avoid incoherences such as inserting a face in an edge.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> package offers two sets of classes, one set inheriting the underlying shape with neither orientation nor location and the other inheriting <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>, which represent the standard topological shapes enumerated in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_abs.html">TopAbs</a></em> package.</p>
<p>The following classes inherit Shape : <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___vertex.html">TopoDS_Vertex</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___wire.html">TopoDS_Wire</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___face.html">TopoDS_Face</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shell.html">TopoDS_Shell</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___solid.html">TopoDS_Solid</a>,<a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___comp_solid.html">TopoDS_CompSolid</a>,</em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___compound.html">TopoDS_Compound</a></em>. In spite of the similarity of names with those inheriting from <b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></b> there is a profound difference in the way they are used.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> class and the classes, which inherit from it, are the natural means to manipulate topological objects. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em> classes are hidden. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em> describes a class in its original local coordinate system without orientation. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> is a reference to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em> with an orientation and a local reference.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em> class is deferred; <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> class is not. Using <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> class allows manipulation of topological objects without knowing their type. It is a generic form. Purely topological algorithms often use the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> class.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em> class is manipulated by reference; <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> class by value. A <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> is nothing more than a reference enhanced with an orientation and a local coordinate. The sharing of <em>TopoDS_Shapes</em> is meaningless. What is important is the sharing of the underlying <em>TopoDS_TShapes</em>. Assignment or passage in argument does not copy the data structure: this only creates new <em>TopoDS_Shapes</em> which refer to the same <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em>.</p>
<p>Although classes inheriting <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___t_shape.html">TopoDS_TShape</a></em> are used for adding extra information, extra fields should not be added in a class inheriting from <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>. Classes inheriting from <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> serve only to specialize a reference in order to benefit from static type control (carried out by the compiler). For example, a routine that receives a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___face.html">TopoDS_Face</a></em> in argument is more precise for the compiler than the one, which receives a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. It is pointless to derive other classes than those found inTopoDS. All references to a topological data structure are made with the Shape class and its inheritors defined in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em>.</p>
<p>There are no constructors for the classes inheriting from the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> class, otherwise the type control would disappear through <b>implicit casting</b> (a characteristic of C++). The <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a> package provides package methods for <b>casting</b> an object of the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> class in one of these sub-classes, with type verification.</p>
<p>The following example shows a routine receiving an argument of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> type, then putting it into a variable V if it is a vertex or calling the method ProcessEdge if it is an edge.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___vertex_8hxx.html">TopoDS_Vertex.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___edge_8hxx.html">TopoDS_Edge.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___shape_8hxx.html">TopoDS_Shape.hxx</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ProcessEdge(<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a>&amp;); </div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Process(<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; aShape) { </div><div class="line">  <span class="keywordflow">if</span> (aShape.Shapetype() == <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_abs___shape_enum_8hxx.html#a67b8aa38656811eaee45f9df08499667a7eabd4d6205992ed126cc296011a3bb9">TopAbs_VERTEX</a>) { </div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___vertex.html">TopoDS_Vertex</a> V; </div><div class="line">    V = <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#a9c4869066005887bf5406ad417d7c67e">TopoDS::Vertex</a>(aShape); <span class="comment">// Also correct </span></div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___vertex.html">TopoDS_Vertex</a> V2 = aShape; <span class="comment">// Rejected by the compiler </span></div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___vertex.html">TopoDS_Vertex</a> V3 = <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#a9c4869066005887bf5406ad417d7c67e">TopoDS::Vertex</a>(aShape); <span class="comment">// Correct </span></div><div class="line">  } </div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aShape.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#adb1e564b8db9872a241d97883bea184e">ShapeType</a>() == <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_abs___shape_enum_8hxx.html#a67b8aa38656811eaee45f9df08499667a42bf338aa0234146a66f999861c9b928">TopAbs_EDGE</a>){ </div><div class="line">    ProcessEdge(aShape) ; <span class="comment">// This is rejected </span></div><div class="line">    ProcessEdge(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#af9c3719141ea11124e17c18e7de737ed">TopoDS::Edge</a>(aShape)) ; <span class="comment">// Correct </span></div><div class="line">  } </div><div class="line">  <span class="keywordflow">else</span> { </div><div class="line">    cout &lt;&lt;<span class="stringliteral">&quot;Neither a vertex nor an edge ?&quot;</span>; </div><div class="line">    ProcessEdge(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#af9c3719141ea11124e17c18e7de737ed">TopoDS::Edge</a>(aShape)) ; </div><div class="line">    <span class="comment">// OK for compiler but an exception will be raised at run-time </span></div><div class="line">  }</div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_modat_5_4"></a>
Exploration of Topological Data Structures</h2>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp.html">TopExp</a></em> package provides tools for exploring the data structure described with the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> package. Exploring a topological structure means finding all sub-objects of a given type, for example, finding all the faces of a solid.</p>
<p>The <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp.html">TopExp</a> package provides the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a></em> to find all sub-objects of a given type. An explorer is built with:</p><ul>
<li>The shape to be explored.</li>
<li>The type of shapes to be found e.g. VERTEX, EDGE with the exception of SHAPE, which is not allowed.</li>
<li>The type of Shapes to avoid. e.g. SHELL, EDGE. By default, this type is SHAPE. This default value means that there is no restriction on the exploration.</li>
</ul>
<p>The Explorer visits the whole structure in order to find the shapes of the requested type not contained in the type to avoid. The example below shows how to find all faces in the shape <em>S</em>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test() { </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> S; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a> Ex; </div><div class="line">  <span class="keywordflow">for</span> (Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a116937a816c6bbf7b1ba6eaa8873e9f6">Init</a>(S,TopAbs_FACE); Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#ab0756ca99b62fa68c0d7e562b2aafb59">More</a>(); Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a7d9fd9566c072e7dba0b4c7fe5815f19">Next</a>()) { </div><div class="line">    ProcessFace(Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a8f473bcf26da107f2af1af81ee87e5e4">Current</a>()); </div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>Find all the vertices which are not in an edge</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a116937a816c6bbf7b1ba6eaa8873e9f6">Init</a>(S,TopAbs_VERTEX,TopAbs_EDGE); ...) </div></div><!-- fragment --><p>Find all the faces in a SHELL, then all the faces not in a SHELL:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test() { </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a> Ex1, Ex2; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> S; </div><div class="line">  <span class="keywordflow">for</span> (Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a116937a816c6bbf7b1ba6eaa8873e9f6">Init</a>(S,TopAbs_SHELL);Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#ab0756ca99b62fa68c0d7e562b2aafb59">More</a>(); Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a7d9fd9566c072e7dba0b4c7fe5815f19">Next</a>()){ </div><div class="line">    <span class="comment">// visit all shells </span></div><div class="line">    <span class="keywordflow">for</span> (Ex2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a116937a816c6bbf7b1ba6eaa8873e9f6">Init</a>(Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a8f473bcf26da107f2af1af81ee87e5e4">Current</a>(),<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_abs___shape_enum_8hxx.html#a67b8aa38656811eaee45f9df08499667a6085c6950ee7034040ef4b5c9be16f8c">TopAbs_FACE</a>);Ex2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#ab0756ca99b62fa68c0d7e562b2aafb59">More</a>(); </div><div class="line">      Ex2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a7d9fd9566c072e7dba0b4c7fe5815f19">Next</a>()){ </div><div class="line">      <span class="comment">//visit all the faces of the current shell </span></div><div class="line">      ProcessFaceinAshell(Ex2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a8f473bcf26da107f2af1af81ee87e5e4">Current</a>()); </div><div class="line">      ... </div><div class="line">    } </div><div class="line">  } </div><div class="line">  <span class="keywordflow">for</span>(Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a116937a816c6bbf7b1ba6eaa8873e9f6">Init</a>(S,TopAbs_FACE,TopAbs_SHELL);Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#ab0756ca99b62fa68c0d7e562b2aafb59">More</a>(); Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a7d9fd9566c072e7dba0b4c7fe5815f19">Next</a>()){ </div><div class="line">    <span class="comment">// visit all faces not ina shell. </span></div><div class="line">    ProcessFace(Ex1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a8f473bcf26da107f2af1af81ee87e5e4">Current</a>()); </div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The Explorer presumes that objects contain only objects of an equal or inferior type. For example, if searching for faces it does not look at wires, edges, or vertices to see if they contain faces.</p>
<p>The <em>MapShapes</em> method from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp.html">TopExp</a></em> package allows filling a Map. An exploration using the Explorer class can visit an object more than once if it is referenced more than once. For example, an edge of a solid is generally referenced by two faces. To process objects only once, they have to be placed in a Map.</p>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp.html#a0814da11204fe77e9b7d72f0ebcbb4e5">TopExp::MapShapes</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; S, </div><div class="line">            <span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_abs___shape_enum_8hxx.html#a67b8aa38656811eaee45f9df08499667">TopAbs_ShapeEnum</a> T, </div><div class="line">            <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">TopTools_IndexedMapOfShape</a>&amp; M) </div><div class="line">{ </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a> Ex(S,T); </div><div class="line">  <span class="keywordflow">while</span> (Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#ab0756ca99b62fa68c0d7e562b2aafb59">More</a>()) { </div><div class="line">    M.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html#a38ad13a0a661c2f5019d417018030902">Add</a>(Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a8f473bcf26da107f2af1af81ee87e5e4">Current</a>()); </div><div class="line">    Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a7d9fd9566c072e7dba0b4c7fe5815f19">Next</a>(); </div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>In the following example all faces and all edges of an object are drawn in accordance with the following rules:</p><ul>
<li>The faces are represented by a network of <em>NbIso</em> iso-parametric lines with <em>FaceIsoColor</em> color.</li>
<li>The edges are drawn in a color, which indicates the number of faces sharing the edge:<ul>
<li><em>FreeEdgeColor</em> for edges, which do not belong to a face (i.e. wireframe element).</li>
<li><em>BorderEdgeColor</em> for an edge belonging to a single face.</li>
<li><em>SharedEdgeColor</em> for an edge belonging to more than one face.</li>
</ul>
</li>
<li>The methods <em>DrawEdge</em> and <em>DrawFaceIso</em> are also available to display individual edges and faces.</li>
</ul>
<p>The following steps are performed:</p><ol type="1">
<li>Storing the edges in a map and create in parallel an array of integers to count the number of faces sharing the edge. This array is initialized to zero.</li>
<li>Exploring the faces. Each face is drawn.</li>
<li>Exploring the edges and for each of them increment the counter of faces in the array.</li>
<li>From the Map of edges, drawing each edge with the color corresponding to the number of faces.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DrawShape ( <span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; aShape, </div><div class="line"><span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> nbIsos, </div><div class="line"><span class="keyword">const</span> Color FaceIsocolor, </div><div class="line"><span class="keyword">const</span> Color FreeEdgeColor, </div><div class="line"><span class="keyword">const</span> Color BorderEdgeColor, </div><div class="line"><span class="keyword">const</span> Color SharedEdgeColor) </div><div class="line">{ </div><div class="line">  <span class="comment">// Store the edges in aMap. </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">TopTools_IndexedMapOfShape</a> edgemap; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp.html#a0814da11204fe77e9b7d72f0ebcbb4e5">TopExp::MapShapes</a>(aShape,TopAbs_EDGE,edgeMap); </div><div class="line">  <span class="comment">// Create an array set to zero. </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">TColStd_Array1OfInteger</a> faceCount(1,edgeMap.Extent()); </div><div class="line">  faceCount.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html#ab66ddd11c259fb354e0da178a3295832">Init</a> (0); </div><div class="line">  <span class="comment">// Explore the faces. </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a> expFace(aShape,TopAbs_FACE); </div><div class="line">  <span class="keywordflow">while</span> (expFace.More()) { </div><div class="line">    <span class="comment">//Draw the current face. </span></div><div class="line">    DrawFaceIsos(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#aec5c70314df041a30f15e008c4313f81">TopoDS::Face</a>(expFace.Current()),nbIsos,FaceIsoColor); </div><div class="line">    <span class="comment">// Explore the edges ofthe face. </span></div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a> expEdge(expFace.Current(),<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_abs___shape_enum_8hxx.html#a67b8aa38656811eaee45f9df08499667a42bf338aa0234146a66f999861c9b928">TopAbs_EDGE</a>); </div><div class="line">    <span class="keywordflow">while</span> (expEdge.More()) { </div><div class="line">      <span class="comment">//Increment the face count for this edge. </span></div><div class="line">      faceCount(edgemap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html#ab185bca0ee0fc4f99abe2753d71f0d82">FindIndex</a>(expEdge.Current()))++; </div><div class="line">      expEdge.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html#a7d9fd9566c072e7dba0b4c7fe5815f19">Next</a>(); </div><div class="line">    } </div><div class="line">    expFace.Next(); </div><div class="line">  } </div><div class="line">  <span class="comment">//Draw the edges of theMap </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> i; </div><div class="line">  <span class="keywordflow">for</span> (i=1;i&lt;=edgemap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_map.html#af8089854e15993c4a0abcc7b55cb793b">Extent</a>();i++) { </div><div class="line">    <span class="keywordflow">switch</span> (faceCount(i)) { </div><div class="line">      <span class="keywordflow">case</span> 0 : </div><div class="line">      DrawEdge(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#af9c3719141ea11124e17c18e7de737ed">TopoDS::Edge</a>(edgemap(i)),FreeEdgeColor); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">      <span class="keywordflow">case</span> 1 : </div><div class="line">      DrawEdge(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#af9c3719141ea11124e17c18e7de737ed">TopoDS::Edge</a>(edgemap(i)),BorderEdgeColor); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">      default : </div><div class="line">      DrawEdge(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html#af9c3719141ea11124e17c18e7de737ed">TopoDS::Edge</a>(edgemap(i)),SharedEdgeColor); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    }</div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_modat_5_5"></a>
Lists and Maps of Shapes</h2>
<p><b><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_tools.html">TopTools</a></b> package contains tools for exploiting the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em> data structure. It is an instantiation of the tools from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection.html">TCollection</a></em> package with the Shape classes of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s.html">TopoDS</a></em>.</p>
<ul>
<li><em>TopTools_Array1OfShape, HArray1OfShape</em> &ndash; instantiation of the <em>TCollection_Array1</em> and <em>TCollection_HArray1</em> with <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>.</li>
<li><em>TopTools_SequenceOfShape</em> &ndash; instantiation of the <em>TCollection_Sequence</em> with <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>.</li>
<li><em>TopTools_MapOfShape</em> - instantiation of the <em>TCollection_Map</em>. Allows the construction of sets of shapes.</li>
<li><em>TopTools_IndexedMapOfShape</em> - instantiation of the <em>TCollection_IndexedMap</em>. Allows the construction of tables of shapes and other data structures.</li>
</ul>
<p>With a <em>TopTools_Map</em>, a set of references to Shapes can be kept without duplication. The following example counts the size of a data structure as a number of <em>TShapes</em>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___iterator_8hxx.html">TopoDS_Iterator.hxx</a>&gt;</span> </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Size(<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; aShape) </div><div class="line">{ </div><div class="line">  <span class="comment">// This is a recursive method. </span></div><div class="line">  <span class="comment">// The size of a shape is1 + the sizes of the subshapes. </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html">TopoDS_Iterator</a> It; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> size = 1; </div><div class="line">  <span class="keywordflow">for</span> (It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a5cc11f24ebbefe122c5cb790172fe340">Initialize</a>(aShape);It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#aad593efd96d5e80819ffdb646b685ec5">More</a>();It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a8e60b9b6925dfdb0c9bbb6efe33e8ed1">Next</a>()) { </div><div class="line">    size += Size(It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a374797a97e941dc1c1935f8e7f1921c5">Value</a>()); </div><div class="line">  } </div><div class="line">  <span class="keywordflow">return</span> size; </div><div class="line">} </div></div><!-- fragment --><p>This program is incorrect if there is sharing in the data structure.</p>
<p>Thus for a contour of four edges it should count 1 wire + 4 edges +4 vertices with the result 9, but as the vertices are each shared by two edges this program will return 13. One solution is to put all the Shapes in a Map so as to avoid counting them twice, as in the following example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___iterator_8hxx.html">TopoDS_Iterator.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_tools___map_of_shape_8hxx.html">TopTools_MapOfShape.hxx</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MapShapes(<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; aShape, </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">TopTools_MapOfShape</a>&amp; aMap)</div><div class="line">{ </div><div class="line">  <span class="comment">//This is a recursive auxiliary method. It stores all subShapes of aShape in a Map.</span></div><div class="line">  <span class="keywordflow">if</span> (aMap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html#a5c0deb5eae077c6b36021784120c2a4e">Add</a>(aShape)) { </div><div class="line">    <span class="comment">//Add returns True if aShape was not already in the Map. </span></div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html">TopoDS_Iterator</a> It; </div><div class="line">    <span class="keywordflow">for</span> (It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a5cc11f24ebbefe122c5cb790172fe340">Initialize</a>(aShape);It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#aad593efd96d5e80819ffdb646b685ec5">More</a>();It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a8e60b9b6925dfdb0c9bbb6efe33e8ed1">Next</a>()){ </div><div class="line">      MapShapes(It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a374797a97e941dc1c1935f8e7f1921c5">Value</a>(),aMap); </div><div class="line">    } </div><div class="line">  } </div><div class="line">}</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Size(<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; aShape) </div><div class="line">{ </div><div class="line">  <span class="comment">// Store Shapes in a Mapand return the size. </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">TopTools_MapOfShape</a> M; </div><div class="line">  MapShapes(aShape,M); </div><div class="line">  <span class="keywordflow">return</span> M.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_map.html#af8089854e15993c4a0abcc7b55cb793b">Extent</a>();</div><div class="line">}</div></div><!-- fragment --><p><b>Note</b> For more details about Maps, refer to the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection.html">TCollection</a></em> documentation (Foundation Classes Reference Manual).</p>
<p>The following example is more ambitious and writes a program which copies a data structure using an <em>IndexedMap</em>. The copy is an identical structure but it shares nothing with the original. The principal algorithm is as follows:</p><ul>
<li>All Shapes in the structure are put into an <em>IndexedMap</em>.</li>
<li>A table of Shapes is created in parallel with the map to receive the copies.</li>
<li>The structure is copied using the auxiliary recursive function,which copies from the map to the array.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___shape_8hxx.html">TopoDS_Shape.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_topo_d_s___iterator_8hxx.html">TopoDS_Iterator.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_tools___indexed_map_of_shape_8hxx.html">TopTools_IndexedMapOfShape.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_top_tools___array1_of_shape_8hxx.html">TopTools_Array1OfShape.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;TopoDS_Location.hxx&gt;</span> </div><div class="line"></div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> Copy(<span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>&amp; aShape, </div><div class="line"><span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___builder.html">TopoDS_Builder</a>&amp; aBuilder) </div><div class="line">{ </div><div class="line">  <span class="comment">// Copies the wholestructure of aShape using aBuilder. </span></div><div class="line">  <span class="comment">// Stores all thesub-Shapes in an IndexedMap. </span></div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">TopTools_IndexedMapOfShape</a> theMap; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html">TopoDS_Iterator</a> It; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> i; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> S; </div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_loc___location.html">TopLoc_Location</a> Identity; </div><div class="line">  S = aShape; </div><div class="line">  S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>(Identity); </div><div class="line">  S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>(TopAbs_FORWARD); </div><div class="line">  theMap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html#a38ad13a0a661c2f5019d417018030902">Add</a>(S); </div><div class="line">  <span class="keywordflow">for</span> (i=1; i&lt;= theMap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_map.html#af8089854e15993c4a0abcc7b55cb793b">Extent</a>(); i++) { </div><div class="line">    <span class="keywordflow">for</span>(It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a5cc11f24ebbefe122c5cb790172fe340">Initialize</a>(theMap(i)); It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#aad593efd96d5e80819ffdb646b685ec5">More</a>(); It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a8e60b9b6925dfdb0c9bbb6efe33e8ed1">Next</a>()) { </div><div class="line">      S=It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a374797a97e941dc1c1935f8e7f1921c5">Value</a>(); </div><div class="line">      S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>(Identity); </div><div class="line">      S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>(TopAbs_FORWARD); </div><div class="line">      theMap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html#a38ad13a0a661c2f5019d417018030902">Add</a>(S); </div><div class="line">    }</div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>In the above example, the index <em>i</em> is that of the first object not treated in the Map. When <em>i</em> reaches the same size as the Map this means that everything has been treated. The treatment consists in inserting in the Map all the sub-objects, if they are not yet in the Map, they are inserted with an index greater than <em>i</em>.</p>
<p><b>Note</b> that the objects are inserted with a local reference set to the identity and a FORWARD orientation. Only the underlying TShape is of great interest.</p>
<div class="fragment"><div class="line"><span class="comment">//Create an array to store the copies. </span></div><div class="line">TopTools_Array1OfShapetheCopies(1,theMap.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_map.html#af8089854e15993c4a0abcc7b55cb793b">Extent</a>());</div><div class="line"></div><div class="line"><span class="comment">// Use a recursivefunction to copy the first element. </span></div><div class="line"><span class="keywordtype">void</span> AuxiliaryCopy (<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>, </div><div class="line"><span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">TopTools_IndexedMapOfShape</a> &amp;, </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">TopTools_Array1OfShape</a> &amp;, </div><div class="line"><span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___builder.html">TopoDS_Builder</a>&amp;); </div><div class="line"></div><div class="line">AuxiliaryCopy(1,theMap,theCopies,aBuilder); </div><div class="line"></div><div class="line"><span class="comment">// Get the result with thecorrect local reference and orientation. </span></div><div class="line">S = theCopies(1); </div><div class="line">S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>(aShape.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>()); </div><div class="line">S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>(aShape.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>()); </div><div class="line"><span class="keywordflow">return</span> S; </div></div><!-- fragment --><p>Below is the auxiliary function, which copies the element of rank <em>i</em> from the map to the table. This method checks if the object has been copied; if not copied, then an empty copy is performed into the table and the copies of all the sub-elements are inserted by finding their rank in the map.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> AuxiliaryCopy(<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> index, </div><div class="line"><span class="keyword">const</span> TopTools_IndexedMapOfShapes&amp; sources, </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">TopTools_Array1OfShape</a>&amp; copies, </div><div class="line"><span class="keyword">const</span> <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___builder.html">TopoDS_Builder</a>&amp; aBuilder) </div><div class="line">{ </div><div class="line">  <span class="comment">//If the copy is a null Shape the copy is not done. </span></div><div class="line">  <span class="keywordflow">if</span> (copies(index).IsNull()) { </div><div class="line">    copies(index) =sources(index).EmptyCopied(); </div><div class="line">    <span class="comment">//Insert copies of the sub-shapes. </span></div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html">TopoDS_Iterator</a> It; </div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> S; </div><div class="line">    <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_loc___location.html">TopLoc_Location</a> Identity; </div><div class="line">    <span class="keywordflow">for</span>(It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a5cc11f24ebbefe122c5cb790172fe340">Initialize</a>(sources(index)),It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#aad593efd96d5e80819ffdb646b685ec5">More</a>(), It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a8e60b9b6925dfdb0c9bbb6efe33e8ed1">Next</a> ()) {</div><div class="line">      S = It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a374797a97e941dc1c1935f8e7f1921c5">Value</a>(); </div><div class="line">      S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>(Identity); </div><div class="line">      S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>(TopAbs_FORWARD); </div><div class="line">      AuxiliaryCopy(sources.FindIndex(S),sources,copies,aBuilder); </div><div class="line">      S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>(It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a374797a97e941dc1c1935f8e7f1921c5">Value</a>().<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#a46cb7a11fbb8bb212dbf6d3b225bc047">Location</a>());S.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>(It.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___iterator.html#a374797a97e941dc1c1935f8e7f1921c5">Value</a>().<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html#aee4d6575b3c7f585d61d7c6aeeca5eed">Orientation</a>()); aBuilder.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___builder.html#abccd091087310c8ca90293a3ac80d224">Add</a>(copies(index),S);</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="occt_modat_5_5_1"></a>
Wire Explorer</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html">BRepTools_WireExplorer</a></em> class can access edges of a wire in their order of connection.</p>
<p>For example, in the wire in the image we want to recuperate the edges in the order {e1, e2, e3,e4, e5} :</p>
<div class="image">
<img src="modeling_data_image014.png" alt="modeling_data_image014.png"/>
<div class="caption">
A wire composed of 6 edges.</div></div>
<p> <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_exp___explorer.html">TopExp_Explorer</a></em>, however, recuperates the lines in any order.</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___wire.html">TopoDS_Wire</a> W = ...; </div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html">BRepTools_WireExplorer</a> Ex; </div><div class="line"><span class="keywordflow">for</span>(Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html#a515bee9eb9a750ae3d767f24092432c8">Init</a>(W); Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html#a22c22c1a76ad01c5e0d30f686647687c">More</a>(); Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html#a1e61b3600dbb44f81dca00c6ff7c5f1b">Next</a>()) { </div><div class="line">  ProcessTheCurrentEdge(Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html#afc82b867732690e3ff8835cf764515d9">Current</a>()); </div><div class="line">  ProcessTheVertexConnectingTheCurrentEdgeToThePrevious </div><div class="line">  One(Ex.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___wire_explorer.html#aff5e87ffeeee3850f9569932ead9b1b5">CurrentVertex</a>()); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_modat_5_6"></a>
Storage of shapes</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools.html">BRepTools</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bin_tools.html">BinTools</a></em> packages contain methods <em>Read</em> and <em>Write</em> allowing to read and write a Shape to/from a stream or a file. The methods provided by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools.html">BRepTools</a></em> package use ASCII storage format; <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bin_tools.html">BinTools</a></em> package uses binary format. Each of these methods has two arguments:</p><ul>
<li>a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> object to be read/written;</li>
<li>a stream object or a file name to read from/write to.</li>
</ul>
<p>The following sample code reads a shape from ASCII file and writes it to a binary one:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a> aShape;</div><div class="line"><span class="keywordflow">if</span> (<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools.html#a4da4bcc931f14dd467f4210db9824955">BRepTools::Read</a> (aShape, <span class="stringliteral">&quot;source_file.txt&quot;</span>)) {</div><div class="line">  <a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bin_tools.html#adbe9ea8e155d9619c605f370066a6d28">BinTools::Write</a> (aShape, <span class="stringliteral">&quot;result_file.bin&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="occt_modat_6"></a>
Bounding boxes</h1>
<p>Bounding boxes are used in many OCCT algorithms. The most common use is as a filter avoiding check of excess interferences between pairs of shapes (check of interferences between bounding boxes is much simpler then between shapes and if they do not interfere then there is no point in searching interferences between the corresponding shapes). Generally, bounding boxes can be divided into two main types:</p><ul>
<li>axis-aligned bounding box (AABB) is the box whose edges are parallel to the axes of the World Coordinate System (WCS);</li>
<li>oriented BndBox (OBB) is defined in its own coordinate system that can be rotated with respect to the WCS. Indeed, an AABB is a specific case of OBB.<br />
</li>
</ul>
<p>The image below illustrates the example, when using OBB is better than AABB.</p>
<div class="image">
<img src="modeling_data_image015.png" alt="modeling_data_image015.png"/>
<div class="caption">
Illustrating the problem with AABB.</div></div>
<p> AABBs in this picture are interfered. Therefore, many OCCT algorithms will spend much time to interfere the shapes. However, if we check OBBs, which are not interfered, then searching of interferences between the shapes will not be necessary. At that, creation and analysis of OBBs takes significantly more time than the analogical operations with AABB.</p>
<p>Later in this section, the bounding boxes having the smallest surface area will be called <em>optimal</em>.</p>
<p>In OCCT, bounding boxes are defined in <em>Bnd</em> package. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___box.html">Bnd_Box</a></em> class defines AABB, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___o_b_b.html">Bnd_OBB</a></em> class defines OBB. These classes contain the following common methods (this list is not complete; see the documentation about the corresponding class for detailed information):</p>
<ul>
<li><em>IsVoid</em> method indicates whether the bounding box is empty (uninitialized).</li>
<li><em>SetVoid</em> method clears the existing bounding box.</li>
<li><em>Enlarge(...)</em> extends the current bounding box.</li>
<li><em>Add(...)</em> extends the bounding box as necessary to include the object (a point, a shape, etc.) passed as the argument.</li>
<li><em>IsOut(...)</em> checks whether the argument is inside/outside of the current BndBox.</li>
</ul>
<p><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html">BRepBndLib</a> class contains methods for creation of bounding boxes (both AABB and OBB) from the shapes.</p>
<h2><a class="anchor" id="occt_modat_6_1"></a>
Brief description of some algorithms working with OBB</h2>
<h3><a class="anchor" id="occt_modat_6_1_1"></a>
Creation of OBB from set of points</h3>
<p>The algorithm is described in "Fast Computation of Tight Fitting Oriented Bounding Boxes" by Thomas Larsson and Linus Källberg (FastOBBs.pdf). It includes the following steps:</p>
<p><span>1.</span> Choose \( N_{a} (N_{a} \geq 3) \) initial axes.<br />
 <span>2.</span> Project every given point to the every chosen (in item 1) axis. At that, "minimal" and "maximal" points of every axis (i.e. point having minimal and maximal parameter (correspondingly) of the projection to this axis) are chosen. I.e. \( 2*N_{a} \) points will be held and this set can contain equal points. Later (unless otherwise specified) in this algorithm we will work with these \( 2*N_{a} \) points only.<br />
 <span>3.</span> Choose one pair of points among all pairs of "minimal" and "maximal" points of every axis (from item 1), with two furthest points. Let \( p_{0} \) and \( p_{1} \) be the "minimal" and "maximal" point of this pair.<br />
 <span>4.</span> Create an axis \( \mathbf{e_{0}}\left \{ \overrightarrow{p_{0}p_{1}} \right \} \) (i.e. having direction \( \overrightarrow{p_{0}p_{1}} \) ).<br />
 <span>5.</span> Choose the point \( p_{2} \) (from the set defined in item 2) which is in the maximal distance from the infinite line directed along \( \mathbf{e_{0}} \) axis.<br />
</p>
<p>Further, let us consider the triangle \( T_{0}\left \langle p_{0}, p_{1}, p_{2} \right \rangle \) (i.e. having vertices \( p_{0}, p_{1} \) and \( p_{2} \)). Namely:</p>
<p><span>6.</span> Create new axes: \( \mathbf{e_{1}}\left \{ \overrightarrow{p_{1}p_{2}} \right \} \), \( \mathbf{e_{2}}\left \{ \overrightarrow{p_{2}p_{0}} \right \} \), \( \mathbf{n}\left \{ \overrightarrow{\mathbf{e_{0}}} \times \overrightarrow{\mathbf{e_{1}}} \right \} \), \( \mathbf{m_{0}}\left \{ \overrightarrow{\mathbf{e_{0}}} \times \overrightarrow{\mathbf{n}} \right \} \), \( \mathbf{m_{1}}\left \{ \overrightarrow{\mathbf{e_{1}}} \times \overrightarrow{\mathbf{n}} \right \} \), \( \mathbf{m_{2}}\left \{ \overrightarrow{\mathbf{e_{2}}} \times \overrightarrow{\mathbf{n}} \right \} \).<br />
 <span>7.</span> Create OBBs based on the following axis: \( \left \{ \mathbf{e_{0}} \vdots \mathbf{m_{0}} \vdots \mathbf{n} \right \} \), \( \left \{ \mathbf{e_{1}} \vdots \mathbf{m_{1}} \vdots \mathbf{n} \right \} \) and \( \left \{ \mathbf{e_{2}} \vdots \mathbf{m_{2}} \vdots \mathbf{n} \right \} \) . Choose optimal OBB.<br />
 <span>8.</span> Choose the points \( q_{0} \) and \( q_{1} \) (from the set defined in item 2), which are in maximal distance from the plane of the triangle \( T_{0} \) (from both sides of this plane). At that, \( q_{0} \) has minimal coordinate along the axis \( \mathbf{n} \), \( q_{1} \) has a maximal coordinate.<br />
 <span>9.</span> Repeat the step 6...7 for the triangles \( T_{1}\left \langle p_{0}, p_{1}, q_{0} \right \rangle \), \( T_{2}\left \langle p_{1}, p_{2}, q_{0} \right \rangle \), \( T_{3}\left \langle p_{0}, p_{2}, q_{0} \right \rangle \), \( T_{4}\left \langle p_{0}, p_{1}, q_{1} \right \rangle \), \( T_{5}\left \langle p_{1}, p_{2}, q_{1} \right \rangle \), \( T_{6}\left \langle p_{0}, p_{2}, q_{1} \right \rangle \).<br />
 <span>10.</span> Compute the center of OBB and its half dimensions.<br />
 <span>11.</span> Create OBB using the center, axes and half dimensions.<br />
</p>
<h3><a class="anchor" id="occt_modat_6_1_1_opt"></a>
Creation of Optimal OBB from set of points</h3>
<p>For creation of the optimal OBB from set of points the same algorithm as described above is used but with some simplifications in logic and increased computation time. For the optimal OBB it is necessary to check all possible axes which can be created by the extremal points. And since the extremal points are only valid for the initial axes it is necessary to project the whole set of points on each axis. This approach usually provides much tighter OBB but the performance is lower. The complexity of the algorithm is still linear and with use of <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespace_b_v_h.html">BVH</a> for the set of points it is O(N + C*log(N)).</p>
<p>Here is the example of optimal and not optimal OBB for the model using the set of 125K nodes: </p><table align="center">
<tr>
<td><div class="image">
<img src="modeling_data_obb_125K.png" alt="modeling_data_obb_125K.png"/>
<div class="caption">
Not optimal OBB by DiTo-14</div></div>
 </td><td><div class="image">
<img src="modeling_data_opt_obb_125K.png" alt="modeling_data_opt_obb_125K.png"/>
<div class="caption">
Optimal OBB by DiTo-14</div></div>
 </td><td><div class="image">
<img src="modeling_data_pca_obb_125K.png" alt="modeling_data_pca_obb_125K.png"/>
<div class="caption">
Not optimal OBB by PCA</div></div>
  </td></tr>
</table>
<p>Computation of the not optimal OBB in this case took 0.007 sec, optimal - 0.1 sec, which is about 14 times slower. Such performance is comparable to creation of the OBB for this shape by PCA approach (see below) which takes about 0.17 sec.</p>
<p>The computation of optimal OBB is controlled by the same <em>theIsOptimal</em> flag in the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html#aed61fe542529ccd72e7e8fdad61a0bbe">BRepBndLib::AddOBB</a> method as for PCA algorithm.</p>
<p>These algorithms are implemented in the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___o_b_b.html#ad670864b44bf5132fc9e3b5878c3fdeb">Bnd_OBB::ReBuild</a>(...)</em> method.</p>
<h3><a class="anchor" id="occt_modat_6_1_2"></a>
Creation of OBB based on Axes of inertia</h3>
<p>The algorithm contains the following steps:</p><ol type="1">
<li>Calculate three inertia axes, which will be the axes of the OBB.</li>
<li>Transform the source object *(<a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>)* into the local coordinate system based on the axes from item 1.</li>
<li>Create an AABB for the shape obtained in the item 2.</li>
<li>Compute the center of AABB and its half dimensions.</li>
<li>Transform the center into the WCS.</li>
<li>Create OBB using the center, axes and half dimensions.</li>
</ol>
<h3><a class="anchor" id="occt_modat_6_1_3"></a>
Method IsOut for a point</h3>
<ol type="1">
<li>Project the point to each axis.</li>
<li>Check, whether the absolute value of the projection parameter greater than the correspond half-dimension. In this case, <em>IsOut</em> method will return TRUE.</li>
</ol>
<h3><a class="anchor" id="occt_modat_6_1_4"></a>
Method IsOut for another OBB</h3>
<p>According to the <a href="https://www.jkh.me/files/tutorials/Separating%20Axis%20Theorem%20for%20Oriented%20Bounding%20Boxes.pdf">"Separating Axis Theorem for Oriented Bounding Boxes"</a>, it is necessary to check the 15 separating axes: 6 axes of the boxes and 9 are their cross products.<br />
 The algorithm of analyzing axis \( \mathbf{l} \) is following:</p><ol type="1">
<li>Compute the "length" according to the formula: \( L_{j}=\sum_{i=0}^{2}{H_{i}\cdot \left | \overrightarrow{\mathbf{a_{i}}} \cdot \overrightarrow{\mathbf{l}} \right |} \). Here, \( \mathbf{a_{i}} \) is an i-th axis (X-axis, Y-axis, Z-axis) of j-th BndBox (j=1...2). \( H_{i} \) is a half-dimension along i-th axis.</li>
<li>If \( \left |\overrightarrow{C_{1}C_{2}} \cdot \overrightarrow{\mathbf{l}} \right | &gt; L_{1}+L_{2} \) (where \( C_{j} \) is the center of j-th OBB) then the considered OBBs are not interfered in terms of the axis \( \mathbf{l} \).</li>
</ol>
<p>If OBBs are not interfered in terms of at least one axis (of 15) then they are not interfered at all.</p>
<h3><a class="anchor" id="occt_modat_6_1_5"></a>
Method Add for point or another bounding box</h3>
<p>Create a new OBB (see the section <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6_1_1">Creation of OBB from set of points</a>) based on the source point and all vertices of the given bounding boxes.</p>
<h2><a class="anchor" id="occt_modat_6_2"></a>
Add a shape</h2>
<p>Method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html#aed61fe542529ccd72e7e8fdad61a0bbe">BRepBndLib::AddOBB</a>(...)</em> allows creating the bounding box from a complex object *(<a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a>)*. This method uses both algorithms described in the sections <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6_1_1">Creation of OBB from set of points</a> and sections <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6_1_2">Creation of OBB based on Axes of inertia</a>.</p>
<p>The first algorithm is used if the outer shell of the shape can be represented by a set of points contained in it. Namely, only the following elements are the source of set of points:</p>
<ul>
<li>Nodes of triangulation;</li>
<li>Nodes of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_poly___polygon3_d.html">Poly_Polygon3D</a></em>;</li>
<li>Vertices of edges with a linear 3D-curve lying in the planar face;</li>
<li>Vertices of edges with a linear 3D-curve if the source shape does not contain a more complex topological structure (e.g. the source shape is a compound of edges);</li>
<li>Vertices if the source shape does not contain a more complex topological structure (e.g. the source shape is a compound of vertices).</li>
</ul>
<p>If the required set of points cannot be extracted then the algorithm from section <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6_1_2">Creation of OBB based on Axes of inertia</a> is used for OBB creation.</p>
<p>The package <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html">BRepBndLib</a></em> contains methods <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html#a17355b3bd07e39f47b48f658c7f29b41">BRepBndLib::Add</a>(...), <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html#a1c5a09bca57f8145e163c59693a45bbf">BRepBndLib::AddClose</a>(...)</em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_bnd_lib.html#aad43f924ff3d1ff0963005c4c6cdeb90">BRepBndLib::AddOptimal</a>(...)</em> for creation of AABB of a shape. See the reference manual for the detailed information.</p>
<h2><a class="anchor" id="occt_modat_6_3"></a>
Limitations of algorithm for OBB creation.</h2>
<ol type="1">
<li>The algorithm described in the section <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6_1_1">Creation of OBB from set of points</a> works significantly better (finds resulting OBB with less surface area) and faster than the algorithm from the section <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6_1_2">Creation of OBB based on Axes of inertia</a>. Nevertheless, (in general) the result returned by both algorithms is not always optimal (i.e. sometimes another OBB exists with a smaller surface area). Moreover, the first method does not allow computing OBBs of shapes with a complex geometry.</li>
<li>Currently, the algorithm of OBB creation is implemented for objects in 3D space only. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 26 2019 18:39:14 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
