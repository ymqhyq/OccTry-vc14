<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Debugging tools and hints</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_dev_guides__debug.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Debugging tools and hints </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_debug_intro">Introduction</a></li>
<li class="level1"><a href="#occt_debug_macro">Compiler macro to enable extended debug messages</a></li>
<li class="level1"><a href="#occt_debug_exceptions">Calling JIT debugger on exception</a></li>
<li class="level1"><a href="#occt_debug_bop">Self-diagnostics in Boolean operations algorithm</a></li>
<li class="level1"><a href="#occt_debug_call">Functions for calling from debugger</a><ul><li class="level2"><a href="#occt_debug_call_draw">Interacting with DRAW</a></li>
<li class="level2"><a href="#occt_debug_call_brep">Saving and dumping shapes and geometric objects</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_debug_dump_json">Dump OCCT objects into Json</a><ul><li class="level2"><a href="#occt_debug_dump_json_object">Implementation in object</a></li>
<li class="level2"><a href="#occt_debug_dump_json_draw">Using in DRAW</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_debug_vstudio">Using Visual Studio debugger</a><ul><li class="level2"><a href="#occt_debug_vstudio_command">Command window</a></li>
<li class="level2"><a href="#occt_debug_vstudio_watch">Customized display of variables content</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_debug_perf">Performance measurement tools</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_debug_intro"></a>
Introduction</h1>
<p>This manual describes facilities included in OCCT to support debugging, and provides some hints for more efficient debug.</p>
<h1><a class="anchor" id="occt_debug_macro"></a>
Compiler macro to enable extended debug messages</h1>
<p>Many OCCT algorithms can produce extended debug messages, usually printed to cout. These include messages on internal errors and special cases encountered, timing etc. In OCCT versions prior to 6.8.0 most of these messages were activated by compiler macro <em>DEB</em>, enabled by default in debug builds. Since version 6.8.0 this is disabled by default but can be enabled by defining compiler macro <em>OCCT_DEBUG</em>.</p>
<p>To enable this macro on Windows when building with Visual Studio projects, edit file custom.bat and add the line: </p><pre class="fragment">set CSF_DEFINES=OCCT_DEBUG
</pre><p>Some algorithms use specific macros for yet more verbose messages, usually started with OCCT_DEBUG_. These messages can be enabled in the same way, by defining corresponding macro.</p>
<p>Note that some header files are modified when <em>OCCT_DEBUG</em> is enabled, hence binaries built with it enabled are not compatible with client code built without this option; this is not intended for production use.</p>
<h1><a class="anchor" id="occt_debug_exceptions"></a>
Calling JIT debugger on exception</h1>
<p>On Windows platform when using Visual Studio compiler there is a possibility to start the debugger automatically if an exception is caught in a program running OCCT. For this, set environment variable <em>CSF_DEBUG</em> to any value. Note that this feature works only if you enable OCCT exception handler in your application by calling <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_o_s_d.html#ad924a0263c05b6e8f5f80a45ccf6bdc5">OSD::SetSignal()</a></em>.</p>
<h1><a class="anchor" id="occt_debug_bop"></a>
Self-diagnostics in Boolean operations algorithm</h1>
<p>In real-world applications modeling operations are often performed in a long sequence, while the user sees only the final result of the whole sequence. If the final result is wrong, the first debug step is to identify the offending operation to be debugged further. Boolean operation algorithm in OCCT provides a self-diagnostic feature which can help to do that step.</p>
<p>This feature can be activated by defining environment variable <em>CSF_DEBUG_BOP</em>, which should specify an existing writeable directory.</p>
<p>The diagnostic code checks validity of the input arguments and the result of each Boolean operation. When an invalid situation is detected, the report consisting of argument shapes and a DRAW script to reproduce the problematic operation is saved to the directory pointed by <em>CSF_DEBUG_BOP</em>.</p>
<p>Note that this feature does not applicable for UWP build.</p>
<h1><a class="anchor" id="occt_debug_call"></a>
Functions for calling from debugger</h1>
<p>Modern interactive debuggers provide the possibility to execute application code at a program break point. This feature can be used to analyse the temporary objects available only in the context of the debugged code. OCCT provides several global functions that can be used in this way.</p>
<p>Note that all these functions accept pointer to variable as <em>void*</em> to allow calling the function even when debugger does not recognize type equivalence or can not perform necessary type cast automatically. It is responsibility of the developer to provide the correct pointer. In general these functions are not guaranteed to work, thus use them with caution and at your own risk.</p>
<h2><a class="anchor" id="occt_debug_call_draw"></a>
Interacting with DRAW</h2>
<p>Open CASCADE Test Harness or <a class="el" href="occt_user_guides__test_harness.html">DRAW</a> provides an extensive set of tools for inspection and analysis of OCCT shapes and geometric objects and is mostly used as environment for prototyping and debugging OCCT-based algorithms.</p>
<p>In some cases the objects to be inspected are available in DRAW as results of DRAW commands. In other cases, however, it is necessary to inspect intermediate objects created by the debugged algorithm. To support this, DRAW provides a set of commands allowing the developer to store intermediate objects directly from the debugger stopped at some point during the program execution (usually at a breakpoint).</p>
<div class="fragment"><div class="line">const char* Draw_Eval (const char *theCommandStr)</div></div><!-- fragment --><p>Evaluates a DRAW command or script. A command is passed as a string parameter.</p>
<div class="fragment"><div class="line">const char* DBRep_Set (const char* theNameStr, void* theShapePtr)</div></div><!-- fragment --><p>Sets the specified shape as a value of DRAW interpreter variable with the given name.</p><ul>
<li><em>theNameStr</em> &ndash; the DRAW interpreter variable name to set.</li>
<li><em>theShapePtr</em> &ndash; a pointer to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> variable.</li>
</ul>
<div class="fragment"><div class="line">const char* DBRep_SetComp (const char* theNameStr, void* theListPtr)</div></div><!-- fragment --><p>Makes a compound from the specified list of shapes and sets it as a value of DRAW interpreter variable with the given name.</p><ul>
<li><em>theNameStr</em> &ndash; the DRAW interpreter variable name to set.</li>
<li><em>theListPtr</em> &ndash; a pointer to <em>TopTools_ListOfShape</em> variable.</li>
</ul>
<div class="fragment"><div class="line">const char* DrawTrSurf_Set (const char* theNameStr, void* theHandlePtr)</div><div class="line">const char* DrawTrSurf_SetPnt (const char* theNameStr, void* thePntPtr)</div><div class="line">const char* DrawTrSurf_SetPnt2d (const char* theNameStr, void* thePnt2dPtr)</div></div><!-- fragment --><p>Sets the specified geometric object as a value of DRAW interpreter variable with the given name.</p><ul>
<li><em>theNameStr</em> &ndash; the DRAW interpreter variable name to set.</li>
<li><em>theHandlePtr</em> &ndash; a pointer to the geometric variable (Handle to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___geometry.html">Geom_Geometry</a></em> or <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em> or descendant) to be set.</li>
<li><em>thePntPtr</em> &ndash; a pointer to the variable of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a></em> to be set.</li>
<li><em>thePnt2dPtr</em> &ndash; a pointer to the variable of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a></em> to be set.</li>
</ul>
<p>All these functions are defined in <em>TKDraw</em> toolkit and return a string indicating the result of execution.</p>
<h2><a class="anchor" id="occt_debug_call_brep"></a>
Saving and dumping shapes and geometric objects</h2>
<p>The following functions are provided by <em>TKBRep</em> toolkit and can be used from debugger prompt:</p>
<div class="fragment"><div class="line">const char* BRepTools_Write (const char* theFileNameStr, void* theShapePtr)</div></div><!-- fragment --><p>Saves the specified shape to a file with the given name.</p><ul>
<li><em>theFileNameStr</em> &ndash; the name of the file where the shape is saved.</li>
<li><em>theShapePtr</em> &ndash; a pointer to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> variable.</li>
</ul>
<div class="fragment"><div class="line">const char* BRepTools_Dump (void* theShapePtr)</div><div class="line">const char* BRepTools_DumpLoc (void* theShapePtr)</div></div><!-- fragment --><p>Dumps shape or its location to cout.</p><ul>
<li><em>theShapePtr</em> &ndash; a pointer to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> variable.</li>
</ul>
<p>The following function is provided by <em>TKMesh</em> toolkit:</p>
<div class="fragment"><div class="line">const char* BRepMesh_Dump (void* theMeshHandlePtr, const char* theFileNameStr)</div></div><!-- fragment --><p>Stores mesh produced in parametric space to BREP file.</p><ul>
<li><em>theMeshHandlePtr</em> &ndash; a pointer to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(BRepMesh_DataStructureOfDelaun)</a></em> variable.</li>
<li><em>theFileNameStr</em> &ndash; the name of the file where the mesh is stored.</li>
</ul>
<p>The following functions are provided by <em>TKTopTest</em> toolkit:</p>
<div class="fragment"><div class="line">const char* MeshTest_DrawLinks(const char* theNameStr, void* theFaceAttr)</div><div class="line">const char* MeshTest_DrawTriangles(const char* theNameStr, void* theFaceAttr)</div></div><!-- fragment --><p>Sets the edges or triangles from mesh data structure of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(BRepMesh_FaceAttribute)</a></em> as DRAW interpreter variables, assigning a unique name in the form "&lt;theNameStr&gt;_&lt;index&gt;" to each object.</p><ul>
<li><em>theNameStr</em> &ndash; the prefix to use in names of objects.</li>
<li><em>theFaceAttr</em> &ndash; a pointer to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(BRepMesh_FaceAttribute)</a></em> variable.</li>
</ul>
<p>The following additional function is provided by <em>TKGeomBase</em> toolkit:</p>
<div class="fragment"><div class="line">const char* GeomTools_Dump (void* theHandlePtr)</div></div><!-- fragment --><p>Dump geometric object to cout.</p><ul>
<li><em>theHandlePtr</em> &ndash; a pointer to the geometric variable (<em>Handle</em> to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___geometry.html">Geom_Geometry</a></em> or <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em> or descendant) to be set.</li>
</ul>
<h1><a class="anchor" id="occt_debug_dump_json"></a>
Dump OCCT objects into Json</h1>
<p>Many OCCT classes may dump the current state into the stream. This stream contains the information about the class field into the field value/s. It is possible to prepare recursive dump using corresponded macro for class fields. The depth of this recursion is defined by parameter of the dump. The object defines What parameters should be presented in the Dump. The usual way is to dump all object fields.</p>
<h2><a class="anchor" id="occt_debug_dump_json_object"></a>
Implementation in object</h2>
<p>Steps to prepare dump of the object into json:</p>
<ol type="1">
<li>Create method <b>DumpJson</b>. The method should accept the output stream and the depth for the fields dump. Depth, equal to zero means that only fields of this class should be dumped. Default value -1 means that whole tree of dump will be built recursively calling dump of all fields.</li>
<li>Put into the first row of the method <b>OCCT_DUMP_CLASS_BEGIN</b>. This macro creates a local variable, that will open Json structure on start, and close on exit from this method.</li>
<li>Add several macro to store field values.</li>
</ol>
<p>The following macro are defined to cover the object parameters into json format:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Result in json  </th></tr>
<tr>
<td align="left">OCCT_DUMP_FIELD_VALUE_NUMERICAL </td><td align="left">"field": value </td></tr>
<tr>
<td align="left">OCCT_DUMP_FIELD_VALUE_STRING </td><td align="left">"field": "value" </td></tr>
<tr>
<td align="left">OCCT_DUMP_FIELD_VALUE_POINTER </td><td align="left">"field": "pointer address" </td></tr>
<tr>
<td align="left">OCCT_DUMP_FIELD_VALUES_DUMPED </td><td align="left">"field": { result of field-&gt;DumpJson(...) } </td></tr>
<tr>
<td align="left">OCCT_DUMP_FIELD_VALUES_NUMERICAL </td><td align="left">"field": [value_1, ..., value_n] </td></tr>
<tr>
<td align="left">OCCT_DUMP_FIELD_VALUES_STRING </td><td align="left">"field": ["value_1", ..., "value_n"] </td></tr>
<tr>
<td align="left">OCCT_DUMP_BASE_CLASS </td><td align="left">"kind": { result of kind::DumpJson(...) } </td></tr>
</table>
<h2><a class="anchor" id="occt_debug_dump_json_draw"></a>
Using in DRAW</h2>
<p>In DRAW, key '-dumpJson' is used to dump an object. It is implemented in 'vaspect' and 'boundingbox' commands.</p>
<p>Json output for <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___o_b_b.html">Bnd_OBB</a> (using command 'bounding v -obb -dumpJson'):</p>
<div class="fragment"><div class="line">&quot;Bnd_OBB&quot;: {</div><div class="line">   &quot;Center&quot;: {</div><div class="line">      &quot;gp_XYZ&quot;: [1, 2, 3]</div><div class="line">   },</div><div class="line">   &quot;Axes[0]&quot;: {</div><div class="line">       &quot;gp_XYZ:&quot; [1, 0, 0]</div><div class="line">   },</div><div class="line">   &quot;Axes[1]&quot;: {</div><div class="line">       &quot;gp_XYZ:&quot; [0, 1, 0]</div><div class="line">   },</div><div class="line">   &quot;Axes[2]&quot;: {</div><div class="line">       &quot;gp_XYZ:&quot; [0, 0, 1]</div><div class="line">   },</div><div class="line">   &quot;HDims[0]&quot;: 0,</div><div class="line">   &quot;HDims[1]&quot;: 0,</div><div class="line">   &quot;HDims[2]&quot;: 0,</div><div class="line">   &quot;IsAABox&quot;: 1,</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="occt_debug_vstudio"></a>
Using Visual Studio debugger</h1>
<h2><a class="anchor" id="occt_debug_vstudio_command"></a>
Command window</h2>
<p>Visual Studio debugger provides the Command Window (can be activated from menu <b>View / Other Windows / Command Window</b>), which can be used to evaluate variables and expressions interactively in a debug session (see <a href="https://msdn.microsoft.com/en-us/library/c785s0kz.aspx">https://msdn.microsoft.com/en-us/library/c785s0kz.aspx</a>). Note that the Immediate Window can also be used but it has some limitations, e.g. does not support aliases.</p>
<p>When the execution is interrupted by a breakpoint, you can use this window to call the above described functions in context of the currently debugged function. Note that in most cases you will need to specify explicitly context of the function by indicating the name of the DLL where it is defined.</p>
<p>For example, assume that you are debugging a function, where local variable <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> <em>anEdge1</em> is of interest. The following set of commands in the Command window will save this edge to file <em>edge1.brep</em>, then put it to DRAW variable <em>e1</em> and show it maximized in the axonometric DRAW view:</p>
<div class="fragment"><div class="line">&gt;? ({,,TKBRep.dll}BRepTools_Write)(&quot;d:/edge1.brep&quot;,(void*)&amp;anEdge1)</div><div class="line">0x04a2f234 &quot;d:/edge1.brep&quot;</div><div class="line">&gt;? ({,,TKDraw.dll}DBRep_Set)(&quot;e1&quot;,(void*)&amp;anEdge1)</div><div class="line">0x0369eba8 &quot;e1&quot;</div><div class="line">&gt;? ({,,TKDraw.dll}Draw_Eval)(&quot;donly e1; axo; fit&quot;)</div><div class="line">0x029a48f0 &quot;&quot;</div></div><!-- fragment --><p>For convenience it is possible to define aliases to commands in this window, for instance (here "&gt;" is prompt provided by the command window; in the Immediate window this symbol should be entered manually):</p>
<div class="fragment"><div class="line">&gt;alias deval      ? ({,,TKDraw}Draw_Eval)</div><div class="line">&gt;alias dsetshape  ? ({,,TKDraw}DBRep_Set)</div><div class="line">&gt;alias dsetcomp   ? ({,,TKDraw}DBRep_SetComp)</div><div class="line">&gt;alias dsetgeom   ? ({,,TKDraw}DrawTrSurf_Set)</div><div class="line">&gt;alias dsetpnt    ? ({,,TKDraw}DrawTrSurf_SetPnt)</div><div class="line">&gt;alias dsetpnt2d  ? ({,,TKDraw}DrawTrSurf_SetPnt2d)</div><div class="line">&gt;alias saveshape  ? ({,,TKBRep}BRepTools_Write)</div><div class="line">&gt;alias dumpshape  ? ({,,TKBRep}BRepTools_Dump)</div><div class="line">&gt;alias dumploc    ? ({,,TKBRep}BRepTools_DumpLoc)</div><div class="line">&gt;alias dumpmesh   ? ({,,TKMesh}BRepMesh_Dump)</div><div class="line">&gt;alias dumpgeom   ? ({,,TKGeomBase}GeomTools_Dump)</div></div><!-- fragment --><p>Note that aliases are stored in the Visual Studio user's preferences and it is sufficient to define them once on a workstation. With these aliases, the above example can be reproduced easier (note the space symbol after alias name!):</p>
<div class="fragment"><div class="line">&gt;saveshape (&quot;d:/edge1.brep&quot;,(void*)&amp;anEdge1)</div><div class="line">0x04a2f234 &quot;d:/edge1.brep&quot;</div><div class="line">&gt;dsetshape (&quot;e1&quot;,(void*)&amp;anEdge1)</div><div class="line">0x0369eba8 &quot;e1&quot;</div><div class="line">&gt;deval (&quot;donly e1; axo; fit&quot;)</div><div class="line">0x029a48f0 &quot;&quot;</div></div><!-- fragment --><p>Note that there is no guarantee that the call will succeed and will not affect the program execution, thus use this feature at your own risk. In particular, the commands interacting with window system (such as <em>axo</em>, <em>vinit</em>, etc.) are known to cause application crash when the program is built in 64-bit mode. To avoid this, it is recommended to prepare all necessary view windows in advance, and arrange these windows to avoid overlapping with the Visual Studio window, to ensure that they are visible during debug.</p>
<h2><a class="anchor" id="occt_debug_vstudio_watch"></a>
Customized display of variables content</h2>
<p>Visual Studio provides a way to customize display of variables of different types in debugger windows (Watch, Autos, Locals, etc.).</p>
<p>In Visual Studio 2005-2010 the rules for this display are defined in file <em>autoexp.dat</em> located in subfolder <em>Common7\Packages\Debugger</em> of the Visual Studio installation folder (hint: the path to that folder is given in the corresponding environment variable, e.g. <em>VS100COMNTOOLS</em> for vc10). This file contains two sections: <em>AutoExpand</em> and <em>Visualizer</em>. The following rules can be added to these sections to provide more convenient display of some OCCT data types.</p>
<h3>[AutoExpand] section</h3>
<div class="fragment"><div class="line">; Open CASCADE classes</div><div class="line">Standard_Transient=&lt;,t&gt; count=&lt;count,d&gt;</div><div class="line">Handle_Standard_Transient=&lt;entity,x&gt; count=&lt;entity-&gt;count,d&gt; &lt;,t&gt;</div><div class="line">TCollection_AsciiString=&lt;mylength,d&gt; &lt;mystring,s&gt;</div><div class="line">TCollection_HAsciiString=&lt;myString.mylength,d&gt; &lt;myString.mystring,s&gt;</div><div class="line">TCollection_ExtendedString=&lt;mylength,d&gt; &lt;mystring,su&gt;</div><div class="line">TCollection_HExtendedString=&lt;myString.mylength,d&gt; &lt;myString.mystring,su&gt;</div><div class="line">TCollection_BaseSequence=size=&lt;Size,d&gt; curr=&lt;CurrentIndex,d&gt;</div><div class="line">TCollection_BasicMap=size=&lt;mySize,d&gt;</div><div class="line">NCollection_BaseSequence=size=&lt;mySize,d&gt; curr=&lt;myCurrentIndex,d&gt;</div><div class="line">NCollection_BaseList=length=&lt;myLength,d&gt;</div><div class="line">NCollection_BaseMap=size=&lt;mySize,d&gt; buckets=&lt;myNbBuckets&gt;</div><div class="line">NCollection_BaseVector=length=&lt;myLength,d&gt;</div><div class="line">TDF_Label=&lt;myLabelNode,x&gt; tag=&lt;myLabelNode-&gt;myTag&gt;</div><div class="line">TDF_LabelNode=tag=&lt;myTag,d&gt;</div><div class="line">TDocStd_Document=format=&lt;myStorageFormat.mystring,su&gt; count=&lt;count,d&gt; &lt;,t&gt;</div><div class="line">TopoDS_Shape=&lt;myTShape.entity,x&gt; &lt;myOrient&gt;</div><div class="line">gp_XYZ=&lt;x,g&gt;, &lt;y,g&gt;, &lt;z,g&gt;</div><div class="line">gp_Pnt=&lt;coord.x,g&gt;, &lt;coord.y,g&gt;, &lt;coord.z,g&gt;</div><div class="line">gp_Vec=&lt;coord.x,g&gt;, &lt;coord.y,g&gt;, &lt;coord.z,g&gt;</div><div class="line">gp_Dir=&lt;coord.x,g&gt;, &lt;coord.y,g&gt;, &lt;coord.z,g&gt;</div><div class="line">gp_XY=&lt;x,g&gt;, &lt;y,g&gt;</div><div class="line">gp_Pnt2d=&lt;coord.x,g&gt;, &lt;coord.y,g&gt;</div><div class="line">gp_Dir2d=&lt;coord.x,g&gt;, &lt;coord.y,g&gt;</div><div class="line">gp_Vec2d=&lt;coord.x,g&gt;, &lt;coord.y,g&gt;</div><div class="line">gp_Mat2d={&lt;matrix[0][0],g&gt;,&lt;matrix[0][1],g&gt;}, {&lt;matrix[1][0],g&gt;,&lt;matrix[1][1],g&gt;}</div><div class="line">gp_Ax1=loc={&lt;loc.coord.x,g&gt;, &lt;loc.coord.y,g&gt;, &lt;loc.coord.z,g&gt;} vdir={&lt;vdir.coord.x,g&gt;, &lt;vdir.coord.y,g&gt;, &lt;vdir.coord.z,g&gt;}</div></div><!-- fragment --><h3>[Visualizer] section</h3>
<div class="fragment"><div class="line">; Open CASCADE classes</div><div class="line"></div><div class="line">NCollection_Handle&lt;*&gt; {</div><div class="line">  preview ( *((($T0::Ptr*)$e.entity)-&gt;myPtr) )</div><div class="line">  children ( (($T0::Ptr*)$e.entity)-&gt;myPtr )</div><div class="line">}</div><div class="line"></div><div class="line">NCollection_List&lt;*&gt; {</div><div class="line">  preview ( #( &quot;NCollection_List [&quot;, $e.myLength, &quot;]&quot; ) )</div><div class="line">  children ( #list( head: $c.myFirst, next: myNext ) : #(*($T1*)(&amp;$e+1)) )</div><div class="line">}</div><div class="line"></div><div class="line">NCollection_Array1&lt;*&gt; {</div><div class="line">  preview ( #( &quot;NCollection_Array1 [&quot;, $e.myLowerBound, &quot;..&quot;, $e.myUpperBound, &quot;]&quot; ) )</div><div class="line">  children ( #array( expr: $c.myData[$i], size: 1+$c.myUpperBound ) )</div><div class="line">}</div><div class="line"></div><div class="line">math_Vector {</div><div class="line">  preview ( #( &quot;math_Vector [&quot;, $e.LowerIndex, &quot;..&quot;, $e.UpperIndex, &quot;]&quot; ) )</div><div class="line">  children ( #array ( expr: ((double*)($c.Array.Addr))[$i], size: 1+$c.UpperIndex ) )</div><div class="line">}</div><div class="line"></div><div class="line">TColStd_Array1OfReal {</div><div class="line">  preview ( #( &quot;Array1OfReal [&quot;, $e.myLowerBound, &quot;..&quot;, $e.myUpperBound, &quot;]&quot; ) )</div><div class="line">  children ( #array ( expr: ((double*)($c.myStart))[$i], size: 1+$c.myUpperBound ) )</div><div class="line">}</div><div class="line"></div><div class="line">Handle_TColStd_HArray1OfReal {</div><div class="line">  preview ( #( &quot;HArray1OfReal [&quot;,</div><div class="line">               ((TColStd_HArray1OfReal*)$e.entity)-&gt;myArray.myLowerBound, &quot;..&quot;, </div><div class="line">               ((TColStd_HArray1OfReal*)$e.entity)-&gt;myArray.myUpperBound, &quot;] &quot;,</div><div class="line">               [$e.entity,x], &quot; count=&quot;, $e.entity-&gt;count ) )</div><div class="line">  children ( #array ( expr: ((double*)(((TColStd_HArray1OfReal*)$e.entity)-&gt;myArray.myStart))[$i],</div><div class="line">                      size: 1+((TColStd_HArray1OfReal*)$e.entity)-&gt;myArray.myUpperBound ) )</div><div class="line">}</div><div class="line"></div><div class="line">TColStd_Array1OfInteger {</div><div class="line">  preview ( #( &quot;Array1OfInteger [&quot;, $e.myLowerBound, &quot;..&quot;, $e.myUpperBound, &quot;]&quot; ) )</div><div class="line">  children ( #array ( expr: ((int*)($c.myStart))[$i], size: 1+$c.myUpperBound ) )</div><div class="line">}</div><div class="line"></div><div class="line">Handle_TColStd_HArray1OfInteger {</div><div class="line">  preview ( #( &quot;HArray1OfInteger [&quot;,</div><div class="line">               ((TColStd_HArray1OfInteger*)$e.entity)-&gt;myArray.myLowerBound, &quot;..&quot;, </div><div class="line">               ((TColStd_HArray1OfInteger*)$e.entity)-&gt;myArray.myUpperBound, &quot;] &quot;,</div><div class="line">               [$e.entity,x], &quot; count=&quot;, $e.entity-&gt;count ) )</div><div class="line">  children ( #array ( expr: ((int*)(((TColStd_HArray1OfInteger*)$e.entity)-&gt;myArray.myStart))[$i],</div><div class="line">                      size: 1+((TColStd_HArray1OfInteger*)$e.entity)-&gt;myArray.myUpperBound ) )</div><div class="line">}</div><div class="line"></div><div class="line">Handle_TCollection_HExtendedString {</div><div class="line">  preview ( #( &quot;HExtendedString &quot;, [$e.entity,x], &quot; count=&quot;, $e.entity-&gt;count, </div><div class="line">               &quot; &quot;, ((TCollection_HExtendedString*)$e.entity)-&gt;myString ) )</div><div class="line">  children ( #([actual members]: [$e,!] ) )</div><div class="line">}</div><div class="line"></div><div class="line">Handle_TCollection_HAsciiString {</div><div class="line">  preview ( #( &quot;HAsciiString &quot;, [$e.entity,x], &quot; count=&quot;, $e.entity-&gt;count, </div><div class="line">               &quot; &quot;, ((TCollection_HAsciiString*)$e.entity)-&gt;myString ) )</div><div class="line">  children ( #([actual members]: [$e,!], </div><div class="line">             #array( expr: ((TCollection_HAsciiString*)$e.entity)-&gt;myString.mystring[$i], </div><div class="line">                     size: ((TCollection_HAsciiString*)$e.entity)-&gt;myString.mylength) ) )</div><div class="line">}</div></div><!-- fragment --><p>In Visual Studio 2012 and later, visualizers can be put in a separate file in subdirectory <em>Visualizers</em>. See file <em>occt.natvis</em> for example.</p>
<h1><a class="anchor" id="occt_debug_perf"></a>
Performance measurement tools</h1>
<p>It is recommended to use specialized performance analysis tools to profile OCCT and application code. However, when such tools are not available or cannot be used for some reason, tools provided by <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_o_s_d.html">OSD</a> package can be used: low-level C functions and macros defined in <em>OSD_PerfMeter.h</em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_o_s_d___perf_meter.html">OSD_PerfMeter</a></em> class.</p>
<p>This tool maintains an array of 100 global performance counters that can be started and stopped independently. Adding a performance counter to a function of interest allows to get statistics on the number of calls and the total execution time of the function.</p><ul>
<li>In C++ code, this can be achieved by creating local variable <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_o_s_d___perf_meter.html">OSD_PerfMeter</a></em> in each block of code to be measured.</li>
<li>In C or Fortran code, use functions <em>perf_start_meter</em> and <em>perf_stop_meter</em> to start and stop the counter.</li>
</ul>
<p>Note that this instrumentation is intended to be removed when the profiling is completed.</p>
<p>Macros provided in <em>OSD_PerfMeter.h</em> can be used to keep instrumentation code permanently but enable it only when macro <em>PERF_ENABLE_METERS</em> is defined. Each counter has its name shown when the collected statistics are printed.</p>
<p>In DRAW, use command <em>dperf</em> to print all performance statistics.</p>
<p>Note that performance counters are not thread-safe. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 26 2019 18:39:17 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
