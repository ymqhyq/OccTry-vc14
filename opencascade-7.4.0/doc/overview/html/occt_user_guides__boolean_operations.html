<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Boolean Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__boolean_operations.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Boolean Operations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_algorithms_1">Introduction</a></li>
<li class="level1"><a href="#occt_algorithms_2">Overview</a><ul><li class="level2"><a href="#occt_algorithms_2_1">Operators</a><ul><li class="level3"><a href="#occt_algorithms_2_1_1">Boolean operator</a></li>
<li class="level3"><a href="#occt_algorithms_2_1_2">General Fuse operator</a></li>
<li class="level3"><a href="#occt_algorithms_2_1_3">Splitter operator</a></li>
<li class="level3"><a href="#occt_algorithms_2_1_4">Section operator</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_2_2">Parts of algorithms</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_3">Terms and Definitions</a><ul><li class="level2"><a href="#occt_algorithms_3_1">Interferences</a><ul><li class="level3"><a href="#occt_algorithms_3_1_1">Vertex/Vertex interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_2">Vertex/Edge interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_3">Vertex/Face interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_4">Edge/Edge interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_5">Edge/Face interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_6">Face/Face Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_7">Vertex/Solid Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_8">Edge/Soild Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_9">Face/Soild Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_10">Solid/Soild Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_11">Computation Order</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_12">Results</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_3_2">Paves</a></li>
<li class="level2"><a href="#occt_algorithms_3_3">Pave Blocks</a></li>
<li class="level2"><a href="#occt_algorithms_3_4">Shrunk Range</a></li>
<li class="level2"><a href="#occt_algorithms_3_5">Common Blocks</a></li>
<li class="level2"><a href="#occt_algorithms_3_6">FaceInfo</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_4">Data Structure</a><ul><li class="level2"><a href="#occt_algorithms_4_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_4_2">Shapes</a></li>
<li class="level2"><a href="#occt_algorithms_4_3">Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a></li>
<li class="level2"><a href="#occt_algorithms_4_5">Points and Curves</a></li>
<li class="level2"><a href="#occt_algorithms_4_6">FaceInfo</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_root_classes">Root Classes</a><ul><li class="level2"><a href="#occt_algorithms_root_classes_1">Class BOPAlgo_Options</a></li>
<li class="level2"><a href="#occt_algorithms_root_classes_2">Class BOPAlgo_Algo</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_5">Intersection Part</a><ul><li class="level2"><a href="#occt_algorithms_5_1">Initialization</a></li>
<li class="level2"><a href="#occt_algorithms_5_2">Compute Vertex/Vertex Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_3">Compute Vertex/Edge Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_4">Update Pave Blocks</a></li>
<li class="level2"><a href="#occt_algorithms_5_5">Compute Edge/Edge Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_6">Compute Vertex/Face Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_7">Compute Edge/Face Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_8">Build Split Edges</a></li>
<li class="level2"><a href="#occt_algorithms_5_9">Compute Face/Face Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_10">Build Section Edges</a></li>
<li class="level2"><a href="#occt_algorithms_5_11">Build P-Curves</a></li>
<li class="level2"><a href="#occt_algorithms_5_12">Process Degenerated Edges</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_6">General description of the Building Part</a></li>
<li class="level1"><a href="#occt_algorithms_7">General Fuse Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_7_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_7_2">Results</a></li>
<li class="level2"><a href="#occt_algorithms_7_3a">Options</a></li>
<li class="level2"><a href="#occt_algorithms_7_3b">Usage</a></li>
<li class="level2"><a href="#occt_algorithms_7_3">Examples</a><ul><li class="level3"><a href="#occt_algorithms_7_3_1">Case 1: Three edges intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_2">Case 2: Two wires and an edge</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_3">Case 3: An edge intersecting with a face</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_4">Case 4: An edge lying on a face</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_5">Case 5: An edge and a shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_6">Case 6: A wire and a shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_7">Case 7: Three faces</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_8">Case 8: A face and a shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_9">Case 9: A shell and a solid</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_10">Case 10: A compound and a solid</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_7_4">Class BOPAlgo_Builder</a><ul><li class="level3"><a href="#occt_algorithms_7_4_1">Fields</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_2">Initialization</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_3">Build Images for Vertices</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_4">Build Result of Type Vertex</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_5">Build Images for Edges</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_6">Build Result of Type Edge</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_7">Build Images for Wires</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_8">Build Result of Type Wire</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_9">Build Images for Faces</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_10">Build Result of Type Face</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_11">Build Images for Shells</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_12">Build Result of Type Shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_13">Build Images for Solids</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_14">Build Result of Type Solid</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_15">Build Images for Type CompSolid</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_16">Build Result of Type Compsolid</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_17">Build Images for Compounds</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_18">Build Result of Type Compound</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_19">Post-Processing</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_8">Splitter Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_8_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_8_2">Results</a></li>
<li class="level2"><a href="#occt_algorithms_8_3">Usage</a><ul><li class="level3"><a href="#occt_algorithms_8_3_1">API</a></li>
<li class="level3"><a href="#occt_algorithms_8_3_2">DRAW</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_8_4">Examples</a><ul><li class="level3"><a href="#occt_algorithms_8_4_1">Example 1</a></li>
<li class="level3"><a href="#occt_algorithms_8_4_2">Example 2</a></li>
<li class="level3"><a href="#occt_algorithms_8_4_3">Example 3</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_9">Boolean Operations Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_9_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_9_3">Results. General Rules</a></li>
<li class="level2"><a href="#occt_algorithms_9_4">Examples</a><ul><li class="level3"><a href="#occt_algorithms_9_4_1">Case 1: Two Vertices</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_2">Case 2: A Vertex and an Edge</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_3">Case 3: A Vertex and a Face</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_4">Case 4: A Vertex and a Solid</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_5">Case 5: Two edges intersecting at one point</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_6">Case 6: Two edges having a common block</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_7">Case 7: An Edge and a Face intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_8">Case 8: A Face and an Edge that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_9">Case 9: An Edge and a Solid intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_10">Case 10: An Edge and a Solid that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_11">Case 11: Two intersecting faces</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_12">Case 12: Two faces that have a common part</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_13">Case 13: Two faces that have a common edge</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_14">Case 14: Two faces that have a common vertex</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_15">Case 15: A Face and a Solid that have an intersection curve.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_16">Case 16: A Face and a Solid that have overlapping faces.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_17">Case 17: A Face and a Solid that have overlapping edges.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_18">Case 18: A Face and a Solid that have overlapping vertices.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_19">Case 19: Two intersecting Solids.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_20">Case 20: Two Solids that have overlapping faces.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_21">Case 21: Two Solids that have overlapping edges.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_22">Case 22: Two Solids that have overlapping vertices.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_23">Case 23: A Shell and a Wire cut by a Solid.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_24">Case 24: Two Wires that have overlapping edges.</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_9_5">Class BOPAlgo_BOP</a></li>
<li class="level2"><a href="#occt_algorithms_9_6">Building Draft Result</a></li>
<li class="level2"><a href="#occt_algorithms_9_7">Building the Result</a></li>
<li class="level2"><a href="#occt_algorithms_bop_on_opensolids">Boolean operations on open solids</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_10a">Section Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_10a_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_10a_2">Results and general rules</a></li>
<li class="level2"><a href="#occt_algorithms_10a_3">Examples</a><ul><li class="level3"><a href="#occt_algorithms_10a_3_1">Case 1: Two Vertices</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_2">Case 1: Case 2: A Vertex and an Edge</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_3">Case 1: Case 2: A Vertex and a Face</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_4">Case 4: A Vertex and a Solid</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_5">Case 5: Two edges intersecting at one point</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_6">Case 6: Two edges having a common block</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_7">Case 7: An Edge and a Face intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_8">Case 8: A Face and an Edge that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_9">Case 9: An Edge and a Solid intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_10">Case 10: An Edge and a Solid that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_11">Case 11: Two intersecting faces</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_12">Case 12: Two faces that have a common part</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_13">Case 13: Two faces that have overlapping edges</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_14">Case 14: Two faces that have overlapping vertices</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_15">Case 15: A Face and a Solid that have an intersection curve</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_16">Case 16: A Face and a Solid that have overlapping faces.</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_17">Case 17: A Face and a Solid that have overlapping edges.</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_18">Case 18: A Face and a Solid that have overlapping vertices.</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_19">Case 19: Two intersecting Solids</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_20">Case 20: Two Solids that have overlapping faces</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_21">Case 21: Two Solids that have overlapping edges</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_22">Case 22: Two Solids that have overlapping vertices</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_10a_4">Class BOPAlgo_Section</a></li>
<li class="level2"><a href="#occt_algorithms_10a_5">Building the Result</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_10b">Volume Maker Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_10b_1">Usage</a></li>
<li class="level2"><a href="#occt_algorithms_10b_2">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_10c_Cells">Cells Builder algorithm</a><ul><li class="level2"><a href="#occt_algorithms_10c_Cells_1">Usage</a></li>
<li class="level2"><a href="#occt_algorithms_10c_Cells_2">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_10">Algorithm Limitations</a><ul><li class="level2"><a href="#occt_algorithms_10_1">Arguments</a><ul><li class="level3"><a href="#occt_algorithms_10_1_1">Common requirements</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_3">Pure self-interference</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_4">Self-interferences due to tolerances</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_5">Parametric representation</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_6">Using tolerances of vertices to fix gaps</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_11_1">Intersection problems</a><ul><li class="level3"><a href="#occt_algorithms_11_1_1">Pure intersections and common zones</a></li>
<li class="level3"><a href="#occt_algorithms_11_2_2">Tolerances and inaccuracies</a></li>
<li class="level3"><a href="#occt_algorithms_11_2_3">Acquired Self-interferences</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_11a">Advanced Options</a><ul><li class="level2"><a href="#occt_algorithms_11a_1">Fuzzy Boolean Operation</a><ul><li class="level3"><a href="#occt_algorithms_11a_1_1">Examples</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_11a_2">Gluing Operation</a><ul><li class="level3"><a href="#occt_algorithms_11a_2_1">Usage</a></li>
<li class="level3"><a href="#occt_algorithms_11a_2_2">Examples</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_11a_3">Safe processing mode</a><ul><li class="level3"><a href="#occt_algorithms_11a_3_1">Usage</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_11a_4">How to disable check of input solids for inverted status</a><ul><li class="level3"><a href="#occt_algorithms_11a_4_1">Usage</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_11a_5_obb">Usage of Oriented Bounding Boxes</a><ul><li class="level3"><a href="#occt_algorithms_11a_5_obb_1">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_ers">Errors and warnings reporting system</a></li>
<li class="level1"><a href="#occt_algorithms_history">History Information</a><ul><li class="level2"><a href="#occt_algorithms_history_ex">Examples</a><ul><li class="level3"><a href="#occt_algorithms_history_ex_del">Deleted shapes</a></li>
<li class="level3"><a href="#occt_algorithms_history_ex_modif">Modified shapes</a></li>
<li class="level3"><a href="#occt_algorithms_history_gen">Generated shapes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_simplification">BOP result simplification</a><ul><li class="level2"><a href="#occt_algorithms_simplification_examples">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_11b">Usage</a><ul><li class="level2"><a href="#occt_algorithms_11b_1">Package BRepAlgoAPI</a></li>
<li class="level2"><a href="#occt_algorithms_11b_2">Package BOPTest</a><ul><li class="level3"><a href="#occt_algorithms_11b_2_1">Case 1. General Fuse operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_2">Case 2. Splitting operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_3">Case 3. Common operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_4">Case 4. Fuse operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_5">Case 5. Cut operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_6">Case 6. Section operation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_algorithms_1"></a>
Introduction</h1>
<p>This document provides a comprehensive description of the Boolean Operation Algorithm (BOA) as it is implemented in Open CASCADE Technology. The Boolean Component contains:</p>
<ul>
<li>General Fuse Operator (GFA),</li>
<li>Boolean Operator (BOA),</li>
<li>Section Operator (SA),</li>
<li>Splitter Operator (SPA).</li>
</ul>
<p>GFA is the base algorithm for BOA, SPA, SA.</p>
<p>GFA has a history-based architecture designed to allow using OCAF naming functionality. The architecture of GFA is expandable, that allows creating new algorithms basing on it.</p>
<h1><a class="anchor" id="occt_algorithms_2"></a>
Overview</h1>
<h2><a class="anchor" id="occt_algorithms_2_1"></a>
Operators</h2>
<h3><a class="anchor" id="occt_algorithms_2_1_1"></a>
Boolean operator</h3>
<p>The Boolean operator provides the operations (Common, Fuse, Cut) between two groups: <em>Objects</em> and <em>Tools</em>. Each group consists of an arbitrary number of arguments in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>.</p>
<p>The operator can be represented as:</p>
<p><em>R<sub>B</sub>=B<sub>j</sub> (G<sub>1</sub>, G<sub>2</sub>),</em></p>
<p>where:</p><ul>
<li><em>R<sub>B</sub></em> &ndash; result of the operation;</li>
<li><em>B<sub>j</sub></em> &ndash; operation of type <em>j</em> (Common, Fuse, Cut);</li>
<li><em>G<sub>1</sub>={S<sub>11</sub>, S<sub>12</sub> ... S<sub>1n1</sub>}</em> group of arguments (Objects);</li>
<li><em>G<sub>2</sub>={S<sub>21</sub>, S<sub>22</sub> ... S<sub>2n2</sub>}</em> group of arguments (Tools);</li>
<li><em>n<sub>1</sub></em> &ndash; Number of arguments in <em>Objects</em> group;</li>
<li><em>n<sub>2</sub></em> &ndash; Number of arguments in <em>Tools</em> group.</li>
</ul>
<p><b>Note</b> There is an operation <em>Cut21</em>, which is an extension for forward Cut operation, i.e <em>Cut21=Cut(G2, G1)</em>.</p>
<p>For more details see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_9">Boolean Operations Algorithm</a> section.</p>
<h3><a class="anchor" id="occt_algorithms_2_1_2"></a>
General Fuse operator</h3>
<p>The General fuse operator can be applied to an arbitrary number of arguments in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>.</p>
<p>The GFA operator can be represented as:</p>
<p><em>R<sub>GF</sub> = GF (S<sub>1</sub>, S<sub>2</sub> ... S<sub>n</sub>), </em></p>
<p>where</p><ul>
<li><em>R<sub>GF</sub></em> &ndash; result of the operation,</li>
<li><em>S<sub>1</sub>, S<sub>2</sub> ... S<sub>n</sub></em> &ndash; arguments of the operation,</li>
<li><em>n</em> &ndash; number of arguments.</li>
</ul>
<p>The result of the Boolean operator, <em>R<sub>B</sub></em>, can be obtained from <em>R<sub>GF</sub></em>.</p>
<p>For example, for two arguments <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> the result <em>R<sub>GF</sub></em> is</p>
<p><em>R<sub>GF</sub> = GF (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub> + S<sub>p2</sub> + S<sub>p12</sub></em></p>
<div class="image">
<object type="image/svg+xml" data="operations_image001.svg">operations_image001.svg</object>
<div class="caption">
Operators</div></div>
<p> This Figure shows that</p><ul>
<li><em>B<sub>common</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p12</sub>;</em></li>
<li><em>B<sub>cut12</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub>;</em></li>
<li><em>B<sub>cut21</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p2</sub>;</em></li>
<li><em>B<sub>fuse</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub>+S<sub>p2</sub>+S<sub>p12</sub></em></li>
</ul>
<p><em>R<sub>GF</sub>=GF (S<sub>1</sub>, S<sub>2</sub>) = B<sub>fuse</sub> = B<sub>common</sub>+ B<sub>cut12</sub>+ B<sub>cut21</sub>.</em></p>
<p>The fact that <em>R<sub>GF</sub></em> contains the components of <em>R<sub>B</sub></em> allows considering GFA as the general case of BOA. So it is possible to implement BOA as a subclass of GFA.</p>
<p>For more details see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7">General Fuse Algorithm</a> section.</p>
<h3><a class="anchor" id="occt_algorithms_2_1_3"></a>
Splitter operator</h3>
<p>The Splitter operator can be applied to an arbitrary number of arguments in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The arguments are divided into two groups: <em>Objects</em> and <em>Tools</em>. The result of <em>SPA</em> contains all parts that belong to the <em>Objects</em> but does not contain the parts that belong to the <em>Tools</em>.</p>
<p>The <em>SPA</em> operator can be represented as follows:</p>
<p><em>R<sub>SPA</sub>=SPA (G<sub>1</sub>, G<sub>2</sub>),</em> where:</p><ul>
<li><em>R<sub>SPA</sub></em> &ndash; is the result of the operation;</li>
<li><em>G<sub>1</sub>={S<sub>11</sub>, S<sub>12</sub> ... S<sub>1n1</sub>}</em> group of arguments (<em>Objects</em>);</li>
<li><em>G<sub>2</sub>={S<sub>21</sub>, S<sub>22</sub> ... S<sub>2n2</sub>}</em> group of arguments (<em>Tools</em>);</li>
<li><em>n<sub>1</sub></em> &ndash; Number of arguments in <em>Objects</em> group;</li>
<li><em>n<sub>2</sub></em> &ndash; Number of arguments in <em>Tools</em> group.</li>
</ul>
<p>The result <em>R<sub>SPA</sub></em> can be obtained from <em>R<sub>GF</sub></em> .</p>
<p>For example, for two arguments <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> the result <em>R<sub>SPA</sub></em> is</p>
<p><em>R<sub>SPA</sub>=SPA(S<sub>1</sub>,S<sub>2</sub>)=S<sub>p1</sub>+S<sub>p12</sub>.</em></p>
<p>In case when all arguments of the <em>SPA</em> are <em>Objects</em> and there are no <em>Tools</em>, the result of <em>SPA</em> is equivalent to the result of <em>GFA</em>.</p>
<p>For example, when <em>G<sub>1</sub></em> consists of shapes <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> the result of <em>SPA</em> is</p>
<p><em>R<sub>SPA</sub>=SPA(S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub> + S<sub>p2</sub> + S<sub>p12</sub> = GF (S<sub>1</sub>, S<sub>2</sub>)</em></p>
<p>The fact that the <em>R<sub>GF</sub></em> contains the components of <em>R<sub>SPA</sub></em> allows considering <em>GFA</em> as the general case of <em>SPA</em>. Thus, it is possible to implement <em>SPA</em> as a subclass of <em>GFA</em>.</p>
<p>For more details see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_8">Splitter Algorithm</a> section.</p>
<h3><a class="anchor" id="occt_algorithms_2_1_4"></a>
Section operator</h3>
<p>The Section operator <em>SA</em> can be applied to arbitrary number of arguments in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The result of <em>SA</em> contains vertices and edges in accordance with interferences between the arguments The SA operator can be represented as follows: <em>R<sub>SA</sub>=SA(S1, S2… Sn)</em>, where</p><ul>
<li><em>R<sub>SA</sub></em> &ndash; the operation result;</li>
<li><em>S1, S2 ... Sn</em> &ndash; the operation arguments;</li>
<li><em>n</em> &ndash; the number of arguments.</li>
</ul>
<p>For more details see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_10a">Section Algorithm</a> section.</p>
<h2><a class="anchor" id="occt_algorithms_2_2"></a>
Parts of algorithms</h2>
<p>GFA, BOA, SPA and SA have the same Data Structure (DS). The main goal of the Data Structure is to store all necessary information for input data and intermediate results.</p>
<p>The operators consist of two main parts:</p><ul>
<li>Intersection Part (IP). The main goal of IP is to compute the interferences between sub-shapes of arguments. The IP uses DS to retrieve input data and store the results of intersections.</li>
<li>Building Part (BP). The main goal of BP is to build required result of an operation. This part also uses DS to retrieve data and store the results.</li>
</ul>
<p>As it follows from the definition of operator results, the main differences between GFA, BOA, SPA and SA are in the Building Part. The Intersection Part is the same for the algorithms.</p>
<h1><a class="anchor" id="occt_algorithms_3"></a>
Terms and Definitions</h1>
<p>This chapter provides the background terms and definitions that are necessary to understand how the algorithms work.</p>
<h2><a class="anchor" id="occt_algorithms_3_1"></a>
Interferences</h2>
<p>There are two groups of interferences.</p>
<p>At first, each shape having a boundary representation (vertex, edge, face) has an internal value of geometrical tolerance. The shapes interfere with each other in terms of their tolerances. The shapes that have a boundary representation interfere when there is a part of 3D space where the distance between the underlying geometry of shapes is less or equal to the sum of tolerances of the shapes. Three types of shapes: vertex, edge and face &ndash; produce six types of <b>BRep interferences:</b></p><ul>
<li>Vertex/Vertex,</li>
<li>Vertex/Edge,</li>
<li>Vertex/Face,</li>
<li>Edge/Edge,</li>
<li>Edge/Face and</li>
<li>Face/Face.</li>
</ul>
<p>At second, there are interferences that occur between a solid <em>Z1</em> and a shape <em>S2</em> when <em>Z1</em> and <em>S2</em> have no BRep interferences but <em>S2</em> is completely inside of <em>Z1</em>. These interferences are <b>Non-BRep interferences</b>. There are four possible cases:</p><ul>
<li>Vertex/Solid,</li>
<li>Edge/Solid,</li>
<li>Face/Solid and</li>
<li>Solid/Solid.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_1"></a>
Vertex/Vertex interference</h3>
<p>For two vertices <em>Vi</em> and <em>Vj</em>, the distance between their corresponding 3D points is less than the sum of their tolerances <em>Tol(Vi)</em> and <em>Tol(Vj)</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image002.svg">operations_image002.svg</object>
<div class="caption">
Vertex/vertex interference</div></div>
<p> The result is a new vertex <em>Vn</em> with 3D point <em>Pn</em> and tolerance value <em>Tol(Vn)</em>.</p>
<p>The coordinates of <em>Pn</em> and the value <em>Tol(Vn)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the source vertices <em>(V1, V2)</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_2"></a>
Vertex/Edge interference</h3>
<p>For a vertex <em>Vi</em> and an edge <em>Ej</em>, the distance <em>D</em> between 3D point of the vertex and its projection on the 3D curve of edge <em>Ej</em> is less or equal than sum of tolerances of vertex <em>Tol(Vi)</em> and edge <em>Tol(Ej)</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image003.svg">operations_image003.svg</object>
<div class="caption">
Vertex/edge interference</div></div>
<p> The result is vertex <em>Vi</em> with the corresponding tolerance value <em>Tol(Vi)=Max(Tol(Vi), D+Tol(Ej))</em>, where <em>D = distance (Pi, PPi)</em>;</p>
<p>and parameter <em>t<sub>i</sub></em> of the projected point <em>PPi</em> on 3D curve <em>Cj</em> of edge <em>Ej</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_3"></a>
Vertex/Face interference</h3>
<p>For a vertex <em>Vi</em> and a face <em>Fj</em> the distance <em>D</em> between 3D point of the vertex and its projection on the surface of the face is less or equal than sum of tolerances of the vertex <em>Tol(Vi)</em> and the face <em>Tol(Fj)</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image004.svg">operations_image004.svg</object>
<div class="caption">
Vertex/face interference</div></div>
<p> The result is vertex <em>Vi</em> with the corresponding tolerance value <em>Tol(Vi)=Max(Tol(Vi), D+Tol(Fj))</em>, where <em>D = distance (Pi, PPi)</em></p>
<p>and parameters <em>u<sub>i</sub>, v<sub>i</sub></em> of the projected point <em>PPi</em> on surface <em>Sj</em> of face <em>Fj</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_4"></a>
Edge/Edge interference</h3>
<p>For two edges <em>Ei</em> and <em>Ej</em> (with the corresponding 3D curves <em>Ci</em> and <em>Cj</em>) there are some places where the distance between the curves is less than (or equal to) sum of tolerances of the edges.</p>
<p>Let us examine two cases:</p>
<p>In the first case two edges have one or several common parts of 3D curves in terms of tolerance.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image005.svg">operations_image005.svg</object>
<div class="caption">
Edge/edge interference: common parts</div></div>
<p> The results are:</p><ul>
<li>Parametric range <em>[t<sub>i1</sub>, t<sub>i2</sub> ]</em> for 3D curve <em>Ci</em> of edge <em>Ei</em>.</li>
<li>Parametric range <em>[t<sub>j1</sub>, t<sub>j2</sub> ]</em> for 3D curve <em>Cj</em> of edge <em>Ej</em>.</li>
</ul>
<p>In the second case two edges have one or several common points in terms of tolerance.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image006.svg">operations_image006.svg</object>
<div class="caption">
Edge/edge interference: common points</div></div>
<p> The result is a new vertex <em>Vn</em> with 3D point <em>Pn</em> and tolerance value <em>Tol(Vn)</em>.</p>
<p>The coordinates of <em>Pn</em> and the value <em>Tol(Vn)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the corresponding nearest points <em>Pi</em>, <em>Pj</em> of 3D curves <em>Ci</em>, <em>Cj</em> of source edges <em>Ei</em>, <em>Ej</em>.</p>
<ul>
<li>Parameter <em>t<sub>i</sub></em> of <em>Pi</em> for the 3D curve <em>Ci</em>.</li>
<li>Parameter <em>t<sub>j</sub></em> of <em>Pj</em> for the 3D curve <em>Cj</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_5"></a>
Edge/Face interference</h3>
<p>For an edge <em>Ei</em> (with the corresponding 3D curve <em>Ci</em>) and a face <em>Fj</em> (with the corresponding 3D surface <em>Sj</em>) there are some places in 3D space, where the distance between <em>Ci</em> and surface <em>Sj</em> is less than (or equal to) the sum of tolerances of edge <em>Ei</em> and face <em>Fj</em>.</p>
<p>Let us examine two cases:</p>
<p>In the first case Edge <em>Ei</em> and Face <em>Fj</em> have one or several common parts in terms of tolerance.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image007.svg">operations_image007.svg</object>
<div class="caption">
Edge/face interference: common parts</div></div>
<p> The result is a parametric range <em>[t<sub>i1</sub>, t<sub>i2</sub>]</em> for the 3D curve <em>Ci</em> of the edge <em>Ei</em>.</p>
<p>In the second case Edge <em>Ei</em> and Face <em>Fj</em> have one or several common points in terms of tolerance.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image008.svg">operations_image008.svg</object>
<div class="caption">
Edge/face interference: common points</div></div>
<p> The result is a new vertex <em>Vn</em> with 3D point <em>Pn</em> and tolerance value <em>Tol(Vn)</em>.</p>
<p>The coordinates of <em>Pn</em> and the value <em>Tol(Vn)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the corresponding nearest points <em>Pi</em>, <em>Pj</em> of 3D curve <em>Ci</em> and surface <em>Sj</em> of source edges <em>Ei</em>, <em>Fj</em>.</p>
<ul>
<li>Parameter <em>t<sub>i</sub></em> of <em>Pi</em> for the 3D curve <em>Ci</em>.</li>
<li>Parameters <em>u<sub>i</sub></em> and <em>v<sub>i</sub></em> of the projected point <em>PPi</em> on the surface <em>Sj</em> of the face <em>Fj</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_6"></a>
Face/Face Interference</h3>
<p>For a face <em>Fi</em> and a face <em>Fj</em> (with the corresponding surfaces <em>Si</em> and <em>Sj</em>) there are some places in 3D space, where the distance between the surfaces is less than (or equal to) sum of tolerances of the faces.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image009.svg">operations_image009.svg</object>
<div class="caption">
Face/face interference: common curves</div></div>
<p> In the first case the result contains intersection curves <em>C<sub>ijk</sub> (k = 0, 1, 2…k<sub>N</sub>,</em> where <em>k<sub>N</sub></em> is the number of intersection curves with corresponding values of tolerances <em>Tol(C<sub>ijk</sub>)</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image010.svg">operations_image010.svg</object>
<div class="caption">
Face/face interference: common points</div></div>
<p> In the second case Face <em>Fi</em> and face <em>Fj</em> have one or several new vertices <em>V<sub>ijm</sub></em>, where <em>m=0,1,2, ... mN, mN </em> is the number of intersection points.</p>
<p>The coordinates of a 3D point <em>P<sub>ijm</sub></em> and the value <em>Tol(V<sub>ijm</sub>)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the corresponding nearest points <em>Pi</em>, <em>Pj</em> of the surface <em>Si</em>, <em>Sj</em> of source shapes <em>Fi</em>, <em>Fj</em>.</p>
<ul>
<li>Parameters <em>u<sub>j</sub></em>, <em>v<sub>j</sub></em> belong to point <em>PPj</em> projected on surface <em>Sj</em> of face <em>Fj</em>.</li>
<li>Parameters <em>u<sub>i</sub></em> and <em>v<sub>i</sub></em> belong to point <em>PPi</em> projected on surface <em>Si</em> of face <em>Fi</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_7"></a>
Vertex/Solid Interference</h3>
<p>For a vertex <em>Vi</em> and a solid <em>Zj</em> there is Vertex/Solid interference if the vertex <em>Vi</em> has no BRep interferences with any sub-shape of <em>Zj</em> and <em>Vi</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image060.png" alt="operations_image060.png"/>
<div class="caption">
Vertex/Solid Interference</div></div>
 <h3><a class="anchor" id="occt_algorithms_3_1_8"></a>
Edge/Soild Interference</h3>
<p>For an edge <em>Ei</em> and a solid <em>Zj</em> there is Edge/Solid interference if the edge <em>Ei</em> and its sub-shapes have no BRep interferences with any sub-shape of <em>Zj</em> and <em>Ei</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image061.png" alt="operations_image061.png"/>
<div class="caption">
Edge/Solid Interference</div></div>
 <h3><a class="anchor" id="occt_algorithms_3_1_9"></a>
Face/Soild Interference</h3>
<p>For a face <em>Fi</em> and a solid <em>Zj</em> there is Face/Solid interference if the face <em>Fi</em> and its sub-shapes have no BRep interferences with any sub-shape of <em>Zj</em> and <em>Fi</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image062.png" alt="operations_image062.png"/>
<div class="caption">
Face/Solid Interference</div></div>
 <h3><a class="anchor" id="occt_algorithms_3_1_10"></a>
Solid/Soild Interference</h3>
<p>For a solid <em>Zi</em> and a solid <em>Zj</em> there is Solid/Solid interference if the solid <em>Zi</em> and its sub-shapes have no BRep interferences with any sub-shape of <em>Zj</em> and <em>Zi</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image063.png" alt="operations_image063.png"/>
<div class="caption">
Solid/Solid Interference</div></div>
<h3><a class="anchor" id="occt_algorithms_3_1_11"></a>
Computation Order</h3>
<p>The interferences between shapes are computed on the basis of increasing of the dimension value of the shape in the following order:</p><ul>
<li>Vertex/Vertex,</li>
<li>Vertex/Edge,</li>
<li>Edge/Edge,</li>
<li>Vertex/Face,</li>
<li>Edge/Face,</li>
<li>Face/Face,</li>
<li>Vertex/Solid,</li>
<li>Edge/Solid,</li>
<li>Face/Solid,</li>
<li>Solid/Solid.</li>
</ul>
<p>This order allows avoiding the computation of redundant interferences between upper-level shapes <em>Si</em> and <em>Sj</em> when there are interferences between lower sub-shapes <em>Sik</em> and <em>Sjm</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_12"></a>
Results</h3>
<ul>
<li>The result of the interference is a shape that can be either interfered shape itself (or its part) or a new shape.</li>
<li>The result of the interference is a shape with the dimension value that is less or equal to the minimal dimension value of interfered shapes. For example, the result of Vertex/Edge interference is a vertex, but not an edge.</li>
<li>The result of the interference splits the source shapes on the parts each time as it can do that.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_3_2"></a>
Paves</h2>
<p>The result of interferences of the type Vertex/Edge, Edge/Edge and Edge/Face in most cases is a vertex (new or old) lying on an edge.</p>
<p>The result of interferences of the type Face/Face in most cases is intersection curves, which go through some vertices lying on the faces.</p>
<p>The position of vertex <em>Vi</em> on curve <em>C</em> can be defined by a value of parameter <em>t<sub>i</sub></em> of the 3D point of the vertex on the curve. Pave <em>PVi</em> on curve <em>C</em> is a structure containing the vertex <em>Vi</em> and correspondent value of the parameter <em>t<sub>i</sub></em> of the 3D point of the vertex on the curve. Curve <em>C</em> can be a 3D or a 2D curve.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image011.svg">operations_image011.svg</object>
<div class="caption">
Paves</div></div>
<p> Two paves <em>PV1</em> and <em>PV2</em> on the same curve <em>C</em> can be compared using the parameter value</p><div class="fragment"><div class="line">PV1 &gt; PV2 if t1 &gt; t2 </div></div><!-- fragment --><p>The usage of paves allows binding of the vertex to the curve (or any structure that contains a curve: edge, intersection curve).</p>
<h2><a class="anchor" id="occt_algorithms_3_3"></a>
Pave Blocks</h2>
<p>A set of paves <em>PVi (i=1, 2...nPV)</em>, where <em>nPV</em> is the number of paves] of curve <em>C</em> can be sorted in the increasing order using the value of parameter <em>t</em> on curve <em>C</em>.</p>
<p>A pave block <em>PBi</em> is a part of the object (edge, intersection curve) between neighboring paves.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image012.svg">operations_image012.svg</object>
<div class="caption">
Pave Blocks</div></div>
<p> Any finite source edge <em>E</em> has at least one pave block that contains two paves <em>PVb</em> and <em>PVe</em>:</p><ul>
<li>Pave <em>PVb</em> corresponds to the vertex <em>Vb</em> with minimal parameter <em>t<sub>b</sub></em> on the curve of the edge.</li>
<li>Pave <em>PVe</em> corresponds to the vertex <em>Ve</em> with maximal parameter <em>t<sub>e</sub></em> on the curve of the edge.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_3_4"></a>
Shrunk Range</h2>
<p>Pave block <em>PV</em> of curve <em>C</em> is bounded by vertices <em>V1</em> and <em>V2</em> with tolerance values <em>Tol(V1)</em> and <em>Tol(V2)</em>. Curve <em>C</em> has its own tolerance value <em>Tol(C)</em>:</p><ul>
<li>In case of edge, the tolerance value is the tolerance of the edge.</li>
<li>In case of intersection curve, the tolerance value is obtained from an intersection algorithm.</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="operations_image013.svg">operations_image013.svg</object>
<div class="caption">
Shrunk Range</div></div>
<p> The theoretical parametric range of the pave block is <em>[t1C, t2C]</em>.</p>
<p>The positions of the vertices <em>V1</em> and <em>V2</em> of the pave block can be different. The positions are determined by the following conditions: </p><div class="fragment"><div class="line">Distance (P1, P1c) is equal or less than Tol(V1) + Tol(C)</div><div class="line">Distance (P2, P2c) is equal or less than Tol(V2) + Tol(C)</div></div><!-- fragment --><p> The Figure shows that each tolerance sphere of a vertex can reduce the parametric range of the pave block to a range <em>[t1S, t2S]</em>. The range <em>[t1S, t2S]</em> is the shrunk range of the pave block.</p>
<p>The shrunk range of the pave block is the part of 3D curve that can interfere with other shapes.</p>
<h2><a class="anchor" id="occt_algorithms_3_5"></a>
Common Blocks</h2>
<p>The interferences of the type Edge/Edge, Edge/Face produce results as common parts.</p>
<p>In case of Edge/Edge interference the common parts are pave blocks that have different base edges.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image014.svg">operations_image014.svg</object>
<div class="caption">
Common Blocks: Edge/Edge interference</div></div>
<p> If the pave blocks <em>PB<sub>1</sub>, PB<sub>2</sub>…PB<sub>NbPB</sub></em> , where <em>NbPB</em> is the number of pave blocks have the same bounding vertices and geometrically coincide, the pave blocks form common block <em>CB</em>.</p>
<p>In case of Edge/Face interference the common parts are pave blocks lying on a face(s).</p>
<div class="image">
<object type="image/svg+xml" data="operations_image015.svg">operations_image015.svg</object>
<div class="caption">
Common Blocks: Edge/Face interference</div></div>
<p> If the pave blocks <em>PBi</em> geometrically coincide with a face <em>Fj</em>, the pave blocks form common block <em>CB</em>.</p>
<p>In general case a common block <em>CB</em> contains:</p><ul>
<li>Pave blocks <em>PBi (i=0,1,2, 3… NbPB)</em>.</li>
<li>A set of faces <em>Fj (j=0,1... NbF), NbF</em> &ndash; number of faces.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_3_6"></a>
FaceInfo</h2>
<p>The structure <em>FaceInfo</em> contains the following information:</p><ul>
<li>Pave blocks that have state <b>In</b> for the face;</li>
<li>Vertices that have state <b>In</b> for the face;</li>
<li>Pave blocks that have state <b>On</b> for the face;</li>
<li>Vertices that have state <b>On</b> for the face;</li>
<li>Pave blocks built up from intersection curves for the face;</li>
<li>Vertices built up from intersection points for the face.</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="operations_image016.svg">operations_image016.svg</object>
<div class="caption">
Face Info</div></div>
<p> In the figure, for face <em>F1</em>:</p><ul>
<li>Pave blocks that have state <b>In</b> for the face: <em>PB<sub>in1</sub></em>.</li>
<li>Vertices that have state <b>In</b> for the face: <em>V<sub>in1</sub></em>.</li>
<li>Pave blocks that have state <b>On</b> for the face: <em>PB<sub>on11</sub></em>, <em>PB<sub>on12</sub></em>, <em>PB<sub>on2</sub></em>, <em>PB<sub>on31</sub></em>, <em>PB<sub>on32</sub></em>, <em>PB<sub>on4</sub></em>.</li>
<li>Vertices that have state <b>On</b> for the face: <em>V1, V2, V3, V4, V5, V6</em>.</li>
<li>Pave blocks built up from intersection curves for the face: <em>PB<sub>sc1</sub></em>.</li>
<li>Vertices built up from intersection points for the face: none</li>
</ul>
<h1><a class="anchor" id="occt_algorithms_4"></a>
Data Structure</h1>
<p>Data Structure (DS) is used to:</p><ul>
<li>Store information about input data and intermediate results;</li>
<li>Provide the access to the information;</li>
<li>Provide the links between the chunks of information.</li>
</ul>
<p>This information includes:</p><ul>
<li>Arguments;</li>
<li>Shapes;</li>
<li>Interferences;</li>
<li>Pave Blocks;</li>
<li>Common Blocks.</li>
</ul>
<p>Data Structure is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a></em>.</p>
<h2><a class="anchor" id="occt_algorithms_4_1"></a>
Arguments</h2>
<p>The arguments are shapes (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>):</p><ul>
<li>Number of arguments is unlimited.</li>
<li>Each argument is a valid shape (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>).</li>
<li>Each argument can be of one of the following types (see the Table):</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Type </th><th align="left">Index of Type  </th></tr>
<tr>
<td align="left">1 </td><td align="left">COMPOUND </td><td align="left">0 </td></tr>
<tr>
<td align="left">2 </td><td align="left">COMPSOLID </td><td align="left">1 </td></tr>
<tr>
<td align="left">3 </td><td align="left">SOLID </td><td align="left">2 </td></tr>
<tr>
<td align="left">4 </td><td align="left">SHELL </td><td align="left">3 </td></tr>
<tr>
<td align="left">5 </td><td align="left">FACE </td><td align="left">4 </td></tr>
<tr>
<td align="left">6 </td><td align="left">WIRE </td><td align="left">5 </td></tr>
<tr>
<td align="left">7 </td><td align="left">EDGE </td><td align="left">6 </td></tr>
<tr>
<td align="left">8 </td><td align="left">VERTEX </td><td align="left">7 </td></tr>
</table>
<ul>
<li>The argument of type <em>0 (COMPOUND)</em> can include any number of shapes of an arbitrary type (0, 1…7).</li>
<li>The argument should not be self-interfered, i.e. all sub-shapes of the argument that have geometrical coincidence through any topological entities (vertices, edges, faces) must share these entities.</li>
<li>There are no restrictions on the type of underlying geometry of the shapes. The faces or edges of arguments <em>S<sub>i</sub></em> can have underlying geometry of any type supported by Open CASCADE Technology modeling algorithms (in terms of <em>GeomAbs_CurveType</em> and <em>GeomAbs_SurfaceType</em>).</li>
<li>The faces or edges of the arguments should have underlying geometry with continuity that is not less than C1.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_4_2"></a>
Shapes</h2>
<p>The information about Shapes is stored in structure <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em>. The objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> are stored in the container of array type. The array allows getting the access to the information by an index (DS index). The structure <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> has the following contents:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em>myShape</em> </td><td align="left">Shape itself </td></tr>
<tr>
<td align="left"><em>myType</em> </td><td align="left">Type of shape </td></tr>
<tr>
<td align="left"><em>myBox</em> </td><td align="left">3D bounding box of the shape </td></tr>
<tr>
<td align="left"><em>mySubShapes</em> </td><td align="left">List of DS indices of sub-shapes </td></tr>
<tr>
<td align="left"><em>myReference</em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for some auxiliary information </td></tr>
<tr>
<td align="left"><em>myFlag</em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for some auxiliary information </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_4_3"></a>
Interferences</h2>
<p>The information about interferences is stored in the instances of classes that are inherited from class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf.html">BOPDS_Interf</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf.html">BOPDS_Interf</a></em> </td><td align="left">Root class for interference </td></tr>
<tr>
<td align="left"><em>Index1</em> </td><td align="left">DS index of the shape 1 </td></tr>
<tr>
<td align="left"><em>Index2</em> </td><td align="left">DS index of the shape 2 </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_v.html">BOPDS_InterfVV</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Vertex interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_e.html">BOPDS_InterfVE</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Edge interference </td></tr>
<tr>
<td align="left"><em>myParam</em> </td><td align="left">The value of parameter of the point of the vertex on the curve of the edge </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_f.html">BOPDS_InterfVF</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Face interference </td></tr>
<tr>
<td align="left"><em>myU, myV</em> </td><td align="left">The value of parameters of the point of the vertex on the surface of the face </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_e_e.html">BOPDS_InterfEE</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Edge/Edge interference </td></tr>
<tr>
<td align="left"><em>myCommonPart</em> </td><td align="left">Common part (in terms of <em>IntTools_CommonPart</em> ) </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_e_f.html">BOPDS_InterfEF</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Edge/Face interference </td></tr>
<tr>
<td align="left"><em>myCommonPart</em> </td><td align="left">Common part (in terms of <em>IntTools_CommonPart</em> ) </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_f_f.html">BOPDS_InterfFF</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Face/Face interference </td></tr>
<tr>
<td align="left"><em>myTolR3D, myTolR2D</em> </td><td align="left">The value of tolerances of curves (points) reached in 3D and 2D </td></tr>
<tr>
<td align="left"><em>myCurves</em> </td><td align="left">Intersection Curves (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___curve.html">BOPDS_Curve</a></em>) </td></tr>
<tr>
<td align="left"><em>myPoints</em> </td><td align="left">Intersection Points (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___point.html">BOPDS_Point</a></em>) </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_z.html">BOPDS_InterfVZ</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Solid interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_e_z.html">BOPDS_InterfEZ</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Edge/Solid interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_f_z.html">BOPDS_InterfFZ</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Face/Solid interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_z_z.html">BOPDS_InterfZZ</a></em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Solid/Solid interference </td></tr>
</table>
<p>The Figure shows inheritance diagram for <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf.html">BOPDS_Interf</a></em> classes.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image017.svg">operations_image017.svg</object>
<div class="caption">
BOPDS_Interf classes</div></div>
<h2><a class="anchor" id="occt_algorithms_4_4"></a>
Pave, PaveBlock and CommonBlock</h2>
<p>The information about the pave is stored in objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myIndex</em> </td><td align="left">DS index of the vertex </td></tr>
<tr>
<td align="left"><em>myParam</em> </td><td align="left">Value of the parameter of the 3D point of vertex on curve. </td></tr>
</table>
<p>The information about pave blocks is stored in objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myEdge</em> </td><td align="left">DS index of the edge produced from the pave block </td></tr>
<tr>
<td align="left"><em>myOriginalEdge</em> </td><td align="left">DS index of the source edge </td></tr>
<tr>
<td align="left"><em>myPave1</em> </td><td align="left">Pave 1 (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>) </td></tr>
<tr>
<td align="left"><em>myPave2</em> </td><td align="left">Pave 2 (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>) </td></tr>
<tr>
<td align="left"><em>myExtPaves</em> </td><td align="left">The list of paves (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>) that is used to store paves lying inside the pave block during intersection process </td></tr>
<tr>
<td align="left"><em>myCommonBlock</em> </td><td align="left">The reference to common block (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___common_block.html">BOPDS_CommonBlock</a></em>) if the pave block is a common block </td></tr>
<tr>
<td align="left"><em>myShrunkData</em> </td><td align="left">The shrunk range of the pave block </td></tr>
</table>
<ul>
<li>To be bound to an edge (or intersection curve) the structures of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a></em> are stored in one container of list type <em>(BOPDS_ListOfPaveBlock)</em>.</li>
<li>In case of edge, all the lists of pave blocks above are stored in one container of array type. The array allows getting the access to the information by index of the list of pave blocks for the edge. This index (if exists) is stored in the field <em>myReference</em>.</li>
</ul>
<p>The information about common block is stored in objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___common_block.html">BOPDS_CommonBlock</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___common_block.html">BOPDS_CommonBlock</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myPaveBlocks</em> </td><td align="left">The list of pave blocks that are common in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_5">Common Blocks</a> </td></tr>
<tr>
<td align="left"><em>myFaces</em> </td><td align="left">The list of DS indices of the faces, on which the pave blocks lie. </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_4_5"></a>
Points and Curves</h2>
<p>The information about intersection point is stored in objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___point.html">BOPDS_Point</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___point.html">BOPDS_Point</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myPnt</em> </td><td align="left">3D point </td></tr>
<tr>
<td align="left"><em>myPnt2D1</em> </td><td align="left">2D point on the face1 </td></tr>
<tr>
<td align="left"><em>myPnt2D2</em> </td><td align="left">2D point on the face2 </td></tr>
</table>
<p>The information about intersection curve is stored in objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___curve.html">BOPDS_Curve</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___curve.html">BOPDS_Curve</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myCurve</em> </td><td align="left">The intersection curve (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___curve.html">IntTools_Curve</a></em> ) </td></tr>
<tr>
<td align="left"><em>myPaveBlocks</em> </td><td align="left">The list of pave blocks that belong to the curve </td></tr>
<tr>
<td align="left"><em>myBox</em> </td><td align="left">The bounding box of the curve (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___box.html">Bnd_Box</a></em> ) </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_4_6"></a>
FaceInfo</h2>
<p>The information about <em>FaceInfo</em> is stored in a structure <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em>. The structure <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em> has the following contents.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myPaveBlocksIn</em> </td><td align="left">Pave blocks that have state In for the face </td></tr>
<tr>
<td align="left"><em>myVerticesIn</em> </td><td align="left">Vertices that have state In for the face </td></tr>
<tr>
<td align="left"><em>myPaveBlocksOn</em> </td><td align="left">Pave blocks that have state On for the face </td></tr>
<tr>
<td align="left"><em>myVerticesOn</em> </td><td align="left">Vertices that have state On for the face </td></tr>
<tr>
<td align="left"><em>myPaveBlocksSc</em> </td><td align="left">Pave blocks built up from intersection curves for the face </td></tr>
<tr>
<td align="left"><em>myVerticesSc</em> </td><td align="left">Vertices built up from intersection points for the face + </td></tr>
</table>
<p>The objects of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em> are stored in one container of array type. The array allows getting the access to the information by index. This index (if exists) is stored in the field <em>myReference</em>.</p>
<h1><a class="anchor" id="occt_algorithms_root_classes"></a>
Root Classes</h1>
<h2><a class="anchor" id="occt_algorithms_root_classes_1"></a>
Class BOPAlgo_Options</h2>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___options.html">BOPAlgo_Options</a></em> provides the following options for the algorithms:</p><ul>
<li>Set the appropriate memory allocator;</li>
<li>Check the presence of the Errors and Warnings;</li>
<li>Turn on/off the parallel processing;</li>
<li>Set the additional tolerance for the operation;</li>
<li>Break the operations by user request;</li>
<li>Usage of Oriented Bounding boxes in the operation.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_root_classes_2"></a>
Class BOPAlgo_Algo</h2>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___algo.html">BOPAlgo_Algo</a></em> provides the base interface for all algorithms:</p><ul>
<li>Perform the operation;</li>
<li>Check the input data;</li>
<li>Check the result.</li>
</ul>
<h1><a class="anchor" id="occt_algorithms_5"></a>
Intersection Part</h1>
<p>Intersection Part (IP) is used to</p><ul>
<li>Initialize the Data Structure;</li>
<li>Compute interferences between the arguments (or their sub-shapes);</li>
<li>Compute same domain vertices, edges;</li>
<li>Build split edges;</li>
<li>Build section edges;</li>
<li>Build p-curves;</li>
<li>Store all obtained information in DS.</li>
</ul>
<p>IP is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>.</p>
<div class="image">
<img src="operations_image064.png" alt="operations_image064.png"/>
<div class="caption">
Diagram for Class BOPAlgo_PaveFiller</div></div>
<p> The description provided in the next paragraphs is coherent with the implementation of the method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a66f2b0461686e1439fc962ce593f8f1b">BOPAlgo_PaveFiller::Perform()</a></em>.</p>
<h2><a class="anchor" id="occt_algorithms_5_1"></a>
Initialization</h2>
<p>The input data for the step is the Arguments. The description of initialization step is shown in the Table.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialization the array of shapes (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_2">Shapes</a>). Filling the array of shapes. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ab521270d2f6a40f2f07df312a2f4a2d3">BOPDS_DS::Init()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Initialization the array pave blocks (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock, CommonBlock</a>) </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ab521270d2f6a40f2f07df312a2f4a2d3">BOPDS_DS::Init()</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Initialization of intersection Iterator. The intersection Iterator is the object that computes intersections between sub-shapes of the arguments in terms of bounding boxes. The intersection Iterator provides approximate number of the interferences for given type (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1">Interferences</a>) </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Initialization of intersection Context. The intersection Context is an object that contains geometrical and topological toolkit (classifiers, projectors, etc). The intersection Context is used to cache the tools to increase the algorithm performance. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___context.html">IntTools_Context</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_2"></a>
Compute Vertex/Vertex Interferences</h2>
<p>The input data for this step is the DS after the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_5_1">Initialization</a>. The description of this step is shown in the table :</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Vertex/Vertex interferences. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a95775245febed762df2be259dbafd780">BOPAlgo_PaveFiller::PerformVV()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nVi, nVj)k, k=0, 1…nk,</em> where <em>nVi</em> and <em>nVj</em> are DS indices of vertices <em>Vi</em> and <em>Vj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute the connexity chains of interfered vertices <em>nV1C, nV2C… nVnC)k, C=0, 1…nCs</em>, where <em>nCs</em> is the number of the connexity chains </td><td align="left"><em>BOPAlgo_Tools::MakeBlocksCnx()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Build new vertices from the chains <em>VNc. C=0, 1…nCs.</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a95775245febed762df2be259dbafd780">BOPAlgo_PaveFiller::PerformVV()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Append new vertices in DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ade9d7e48618c8abcf9f5af5038b3ed41">BOPDS_DS::Append()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Append same domain vertices in DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a4d807c65203d618e28ae4a8984357fb5">BOPDS_DS::AddShapeSD()</a></em> </td></tr>
<tr>
<td align="left">7 </td><td align="left">Append Vertex/Vertex interferences in DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a100dc8432785953e65c40faa4b8535ef">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<ul>
<li>The pairs of interfered vertices are: <em>(nV11, nV12), (nV11, nV13), (nV12, nV13), (nV13, nV15), (nV13, nV14), (nV14, nV15), (nV21, nV22), (nV21, nV23), (nV22, nV23);</em></li>
<li>These pairs produce two chains: <em>(nV11, nV12, nV13, nV14, nV15)</em> and <em>(nV21, nV22, nV23);</em></li>
<li>Each chain is used to create a new vertex, <em>VN1</em> and <em>VN2</em>, correspondingly.</li>
</ul>
<p>The example of connexity chains of interfered vertices is given in the image:</p>
<div class="image">
<object type="image/svg+xml" data="operations_image018.svg">operations_image018.svg</object>
<div class="caption">
Connexity chains of interfered vertices</div></div>
<h2><a class="anchor" id="occt_algorithms_5_3"></a>
Compute Vertex/Edge Interferences</h2>
<p>The input data for this step is the DS after computing Vertex/Vertex interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Vertex/Edge interferences </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a63ed697a5245779f3bc9d47d272b4dff">BOPAlgo_PaveFiller::PerformVE()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nVi, nEj)k k=0, 1…nk,</em> where <em>nVi</em> is DS index of vertex <em>Vi</em>, <em>nEj</em> is DS index of edge <em>Ej</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute paves. See <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_2">Vertex/Edge Interference</a> </td><td align="left"><em>BOPInt_Context::ComputeVE()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Initialize pave blocks for the edges <em>Ej</em> involved in the interference </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: ChangePaveBlocks()</em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Append the paves into the pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a>:: AppendExtPave()</em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Append Vertex/Edge interferences in DS </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a100dc8432785953e65c40faa4b8535ef">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_4"></a>
Update Pave Blocks</h2>
<p>The input data for this step is the DS after computing Vertex/Edge Interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Each pave block PB containing internal paves is split by internal paves into new pave blocks <em>PBN1, PBN2… PBNn</em>. PB is replaced by new pave blocks <em>PBN1, PBN2… PBNn</em> in the DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdatePaveBlocks()</em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_5"></a>
Compute Edge/Edge Interferences</h2>
<p>The input data for this step is the DS after updating Pave Blocks.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Edge/Edge interferences </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a90d5d76118f0bf78dda22e36940d999d">BOPAlgo_PaveFiller::PerformEE()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nEi, nEj)k, k=0, 1…nk,</em> where <em>nEi</em> is DS index of the edge <em>Ei</em>, <em>nEj</em> is DS index of the edge <em>Ej</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Initialize pave blocks for the edges involved in the interference, if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: ChangePaveBlocks()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Access to the pave blocks of interfered shapes: <em>(PBi1, PBi2…PBiNi)</em> for edge <em>Ei</em> and <em>(PBj1, PBj2…PBjNj)</em> for edge <em>Ej</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a90d5d76118f0bf78dda22e36940d999d">BOPAlgo_PaveFiller::PerformEE()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Compute shrunk data for pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>, if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#abbe351dbd04cf236c2ac9577bf9a8935">BOPAlgo_PaveFiller::FillShrunkData()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Compute Edge/Edge interference for pave blocks <em>PBix</em> and <em>PBiy</em>. The result of the computation is a set of objects of type <em>IntTools_CommonPart</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___edge_edge.html">IntTools_EdgeEdge</a></em> </td></tr>
<tr>
<td align="left">7.1 </td><td align="left">For each <em>CommonPart</em> of type <em>VERTEX:</em> Create new vertices <em>VNi (i =1, 2…,NbVN),</em> where <em>NbVN</em> is the number of new vertices. Intersect the vertices <em>VNi</em> using the steps Initialization and compute Vertex/Vertex interferences as follows: a) create a new object <em>PFn</em> of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> with its own DS; b) use new vertices <em>VNi (i=1, 2…,NbVN), NbVN</em> as arguments (in terms of <em>TopoDs_Shape</em>) of <em>PFn</em>; c) invoke method <em>Perform()</em> for <em>PFn</em>. The resulting vertices <em>VNXi (i=1, 2…,NbVNX)</em>, where <em>NbVNX</em> is the number of vertices, are obtained via mapping between <em>VNi</em> and the results of <em>PVn</em>. </td><td align="left"><em>BOPTools_Tools::MakeNewVertex()</em> </td></tr>
<tr>
<td align="left">7.2 </td><td align="left">For each <em>CommonPart</em> of type <em>EDGE:</em> Compute the coinciding connexity chains of pave blocks <em>(PB1C, PB2C… PNnC)k, C=0, 1…nCs,</em> where <em>nCs</em> is the number of the connexity chains. Create common blocks <em>(CBc. C=0, 1…nCs)</em> from the chains. Attach the common blocks to the pave blocks. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#ad2b376f72b7e5a0fbe217035c4fe5397">BOPAlgo_Tools::PerformCommonBlocks()</a></em> </td></tr>
<tr>
<td align="left">8 </td><td align="left">Post-processing. Append the paves of <em>VNXi</em> into the corresponding pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a>:: AppendExtPave()</em> </td></tr>
<tr>
<td align="left">9 </td><td align="left">Split common blocks CBc by the paves. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdateCommonBlock()</em> </td></tr>
<tr>
<td align="left">10 </td><td align="left">Append Edge/Edge interferences in the DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a100dc8432785953e65c40faa4b8535ef">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<p>The example of coinciding chains of pave blocks is given in the image:</p>
<div class="image">
<img src="operations_image019.png" alt="operations_image019.png"/>
<div class="caption">
Coinciding chains of pave blocks</div></div>
<ul>
<li>The pairs of coincided pave blocks are: <em>(PB11, PB12), (PB11, PB13), (PB12, PB13), (PB21, PB22), (PB21, PB23), (PB22, PB23).</em></li>
<li>The pairs produce two chains: <em>(PB11, PB12, PB13)</em> and <em>(PB21, PB22, PB23).</em></li>
</ul>
<h2><a class="anchor" id="occt_algorithms_5_6"></a>
Compute Vertex/Face Interferences</h2>
<p>The input data for this step is the DS after computing Edge/Edge interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Vertex/Face interferences </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a0049cfb42c99121aea8210aca7b56d4a">BOPAlgo_PaveFiller::PerformVF()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nVi, nFj)k, k=0, 1…nk,</em> where <em>nVi</em> is DS index of the vertex <em>Vi</em>, <em>nFj</em> is DS index of the edge <em>Fj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute interference See <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_3">Vertex/Face Interference</a> </td><td align="left"><em>BOPInt_Context::ComputeVF()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Append Vertex/Face interferences in the DS </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a100dc8432785953e65c40faa4b8535ef">BOPDS_DS::AddInterf()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Repeat steps 2-4 for each new vertex <em>VNXi (i=1, 2…,NbVNX),</em> where <em>NbVNX</em> is the number of vertices. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a0b7b989548e66b8652e0722b174cbfc2">BOPAlgo_PaveFiller::TreatVerticesEE()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_7"></a>
Compute Edge/Face Interferences</h2>
<p>The input data for this step is the DS after computing Vertex/Face Interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Edge/Face interferences </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5b4b627143139e1919913b4e4c529c65">BOPAlgo_PaveFiller::PerformEF()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nEi, nFj)k, k=0, 1…nk,</em> where <em>nEi</em> is DS index of edge <em>Ei</em>, <em>nFj</em> is DS index of face <em>Fj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Initialize pave blocks for the edges involved in the interference, if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a9c95db5ed7debabb761f2fa3051bfbd8">BOPDS_DS::ChangePaveBlocks()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Access to the pave blocks of interfered edge <em>(PBi1, PBi2…PBiNi)</em> for edge <em>Ei</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5b4b627143139e1919913b4e4c529c65">BOPAlgo_PaveFiller::PerformEF()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Compute shrunk data for pave blocks (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>) if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#abbe351dbd04cf236c2ac9577bf9a8935">BOPAlgo_PaveFiller::FillShrunkData()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Compute Edge/Face interference for pave block <em>PBix</em>, and face <em>nFj</em>. The result of the computation is a set of objects of type <em>IntTools_CommonPart</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___edge_face.html">IntTools_EdgeFace</a></em> </td></tr>
<tr>
<td align="left">7.1 </td><td align="left">For each <em>CommonPart</em> of type <em>VERTEX:</em> Create new vertices <em>VNi (i=1, 2…,NbVN),</em> where <em>NbVN</em> is the number of new vertices. Merge vertices <em>VNi</em> as follows: a) create new object <em>PFn</em> of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> with its own DS; b) use new vertices <em>VNi (i=1, 2…,NbVN), NbVN</em> as arguments (in terms of <em>TopoDs_Shape</em>) of <em>PFn</em>; c) invoke method <em>Perform()</em> for <em>PFn</em>. The resulting vertices <em>VNXi (i=1, 2…,NbVNX)</em>, where <em>NbVNX</em> is the number of vertices, are obtained via mapping between <em>VNi</em> and the results of <em>PVn</em>. </td><td align="left"><em>BOPTools_Tools::MakeNewVertex()</em> and <em>BOPAlgo_PaveFiller::PerformVertices1()</em> </td></tr>
<tr>
<td align="left">7.2 </td><td align="left">For each <em>CommonPart</em> of type <em>EDGE:</em> Create common blocks <em>(CBc. C=0, 1…nCs)</em> from pave blocks that lie on the faces. Attach the common blocks to the pave blocks. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#ad2b376f72b7e5a0fbe217035c4fe5397">BOPAlgo_Tools::PerformCommonBlocks()</a></em> </td></tr>
<tr>
<td align="left">8 </td><td align="left">Post-processing. Append the paves of <em>VNXi</em> into the corresponding pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a>:: AppendExtPave()</em> </td></tr>
<tr>
<td align="left">9 </td><td align="left">Split pave blocks and common blocks <em>CBc</em> by the paves. </td><td align="left"><em>BOPAlgo_PaveFiller::PerformVertices1()</em>, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdatePaveBlock()</em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdateCommonBlock()</em> </td></tr>
<tr>
<td align="left">10 </td><td align="left">Append Edge/Face interferences in the DS </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a100dc8432785953e65c40faa4b8535ef">BOPDS_DS::AddInterf()</a></em> </td></tr>
<tr>
<td align="left">11 </td><td align="left">Update <em>FaceInfo</em> for all faces having EF common parts. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdateFaceInfoIn()</em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_8"></a>
Build Split Edges</h2>
<p>The input data for this step is the DS after computing Edge/Face Interferences.</p>
<p>For each pave block <em>PB</em> take the following steps:</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Get the real pave block <em>PBR</em>, which is equal to <em>PB</em> if <em>PB</em> is not a common block and to <em>PB<sub>1</sub></em> if <em>PB</em> is a common block. <em>PB<sub>1</sub></em> is the first pave block in the pave blocks list of the common block. See <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ab9015dbaf4de8632ac8bb9b019f0b53c">BOPAlgo_PaveFiller::MakeSplitEdges()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Build the split edge <em>Esp</em> using the information from <em>DS</em> and <em>PBR</em>. </td><td align="left"><em>BOPTools_Tools::MakeSplitEdge()</em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> contents for Esp </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ab9015dbaf4de8632ac8bb9b019f0b53c">BOPAlgo_PaveFiller::MakeSplitEdges()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Append <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> contents to the DS </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ade9d7e48618c8abcf9f5af5038b3ed41">BOPDS_DS::Append()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_9"></a>
Compute Face/Face Interferences</h2>
<p>The input data for this step is DS after building Split Edges.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Face/Face interferences </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5a78c6c9eb221d7364688a5a4e9e41c4">BOPAlgo_PaveFiller::PerformFF()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nFi, nFj)k, k=0, 1…nk,</em> where <em>nFi</em> is DS index of edge <em>Fi</em>, <em>nFj</em> is DS index of face <em>Fj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute Face/Face interference </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___face_face.html">IntTools_FaceFace</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Append Face/Face interferences in the DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a100dc8432785953e65c40faa4b8535ef">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_10"></a>
Build Section Edges</h2>
<p>The input data for this step is the DS after computing Face/Face interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For each Face/Face interference <em>nFi, nFj</em>, retrieve <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_6">FaceInfo</a>. Create draft vertices from intersection points <em>VPk (k=1, 2…, NbVP)</em>, where <em>NbVP</em> is the number of new vertices, and the draft vertex <em>VPk</em> is created from an intersection point if <em>VPk ≠ Vm (m = 0, 1, 2… NbVm)</em>, where <em>Vm</em> is an existing vertex for the faces <em>nFi</em> and <em>nF,j</em> (<em>On</em> or <em>In</em> in terms of <em>TopoDs_Shape</em>), <em>NbVm</em> is the number of vertices existing on faces <em>nFi</em> and <em>nF,j</em> and ≠ &ndash; means non-coincidence in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_1">Vertex/Vertex interference</a>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ae437042368bb06c5270e2c42be349dc4">BOPAlgo_PaveFiller::MakeBlocks()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For each intersection curve <em>Cijk</em> </td><td align="left"></td></tr>
<tr>
<td align="left">2.1 </td><td align="left">Create paves PVc for the curve using existing vertices, i.e. vertices On or In (in terms of <em>FaceInfo</em>) for faces <em>nFi</em> and <em>nFj</em>. Append the paves <em>PVc</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#afdd7234c854b0d9899d2755aca8e7e6a">BOPAlgo_PaveFiller::PutPaveOnCurve()</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html#a14fa0ff8476e4bab63a57bbbc14200ce">BOPDS_PaveBlock::AppendExtPave()</a></em> </td></tr>
<tr>
<td align="left">2.2 </td><td align="left">Create technological vertices <em>Vt</em>, which are the bounding points of an intersection curve (with the value of tolerance <em>Tol(Cijk)</em>). Each vertex <em>Vt</em> with parameter <em>Tt</em> on curve <em>Cijk</em> forms pave <em>PVt</em> on curve <em>Cijk</em>. Append technological paves. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a7ed1dd57c371f68b5eda6fbc01b6c658">BOPAlgo_PaveFiller::PutBoundPaveOnCurve()</a></em> </td></tr>
<tr>
<td align="left">2.3 </td><td align="left">Create pave blocks <em>PBk</em> for the curve using paves <em>(k=1, 2…, NbPB)</em>, where <em>NbPB</em> is the number of pave blocks </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ae437042368bb06c5270e2c42be349dc4">BOPAlgo_PaveFiller::MakeBlocks()</a></em> </td></tr>
<tr>
<td align="left">2.4 </td><td align="left">Build draft section edges <em>ESk</em> using the pave blocks <em>(k=1, 2…, NbES)</em>, where <em>NbES</em> is the number of draft section edges The draft section edge is created from a pave block <em>PBk</em> if <em>PBk</em> has state <em>In</em> or <em>On</em> for both faces <em>nFi</em> and <em>nF,j</em> and <em>PBk ≠ PBm (m=0, 1, 2… NbPBm)</em>, where <em>PBm</em> is an existing pave block for faces <em>nFi</em> and <em>nF,j</em> (<em>On</em> or <em>In</em> in terms of <em>FaceInfo</em>), <em>NbVm</em> is the number of existing pave blocks for faces <em>nFi</em> and <em>nF,j</em> and ≠ &ndash; means non-coincidence (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_3">Vertex/Face interference</a>). </td><td align="left"><em>BOPTools_Tools::MakeEdge()</em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Intersect the draft vertices <em>VPk (k=1, 2…, NbVP)</em> and the draft section edges <em>ESk (k=1, 2…, NbES)</em>. For this: a) create new object <em>PFn</em> of type <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> with its own DS; b) use vertices <em>VPk</em> and edges <em>ESk</em> as arguments (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_1">Arguments</a>) of <em>PFn</em>; c) invoke method <em>Perform()</em> for <em>PFn</em>. Resulting vertices <em>VPXk (k=1, 2… NbVPX)</em> and edges <em>ESXk (k=1, 2… NbESX)</em> are obtained via mapping between <em>VPk, ESk</em> and the results of <em>PVn</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5e779e971391efd65cc551f5b5da1a89">BOPAlgo_PaveFiller::PostTreatFF()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Update face info (sections about pave blocks and vertices) </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5a78c6c9eb221d7364688a5a4e9e41c4">BOPAlgo_PaveFiller::PerformFF()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_11"></a>
Build P-Curves</h2>
<p>The input data for this step is the DS after building section edges.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For each Face/Face interference <em>nFi</em> and <em>nFj</em> build p-Curves on <em>nFi</em> and <em>nFj</em> for each section edge <em>ESXk</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a7266445de539b14948858de09164d4cc">BOPAlgo_PaveFiller::MakePCurves()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For each pave block that is common for faces <em>nFi</em> and <em>nFj</em> build p-Curves on <em>nFi</em> and <em>nFj</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a7266445de539b14948858de09164d4cc">BOPAlgo_PaveFiller::MakePCurves()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_12"></a>
Process Degenerated Edges</h2>
<p>The input data for this step is the DS after building P-curves.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left"></td><td align="left">For each degenerated edge <em>ED</em> having vertex <em>VD</em> </td><td align="left"><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#acd3898a140a2d24f4e46d7cdda808080">BOPAlgo_PaveFiller::ProcessDE()</a> </td></tr>
<tr>
<td align="left">1 </td><td align="left">Find pave blocks <em>PBi (i=1,2… NbPB)</em>, where <em>NbPB</em> is the number of pave blocks, that go through vertex <em>VD</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#acd188295f84cd75343734591171ebfce">BOPAlgo_PaveFiller::FindPaveBlocks()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Compute paves for the degenerated edge <em>ED</em> using a 2D curve of <em>ED</em> and a 2D curve of <em>PBi</em>. Form pave blocks <em>PBDi (i=1,2… NbPBD)</em>, where <em>NbPBD</em> is the number of the pave blocks for the degenerated edge <em>ED</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a71e42c2f47f024ca885ae09151645ba5">BOPAlgo_PaveFiller::FillPaves()</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Build split edges <em>ESDi (i=1,2…NbESD)</em>, where <em>ESD</em> is the number of split edges, using the pave blocks <em>PBDi</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a>:: MakeSplitEdge()</em> </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_6"></a>
General description of the Building Part</h1>
<p>Building Part (BP) is used to</p><ul>
<li>Build the result of the operation</li>
<li>Provide history information (in terms of <em>::Generated(), ::Modified()</em> and <em>::IsDeleted()</em>) BP uses the DS prepared by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> described at chapter 5 as input data. BP is implemented in the following classes:</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> &ndash; for the General Fuse operator (GFA).</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> &ndash; for the Boolean Operation operator (BOA).</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a></em> &ndash; for the Section operator (SA).</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___maker_volume.html">BOPAlgo_MakerVolume</a></em> &ndash; for the Volume Maker operator.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___splitter.html">BOPAlgo_Splitter</a></em> &ndash; for the Splitter operator.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___cells_builder.html">BOPAlgo_CellsBuilder</a></em> &ndash; for the Cells Builder operator.</li>
</ul>
<div class="image">
<img src="operations_image020.png" alt="operations_image020.png"/>
<div class="caption">
Diagram for BP classes</div></div>
<p> The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_shape.html">BOPAlgo_BuilderShape</a></em> provides the interface for algorithms that have:</p><ul>
<li>A Shape as the result;</li>
<li>History information (in terms of <em>::Generated(), ::Modified()</em> and <em>::IsDeleted()).</em></li>
</ul>
<h1><a class="anchor" id="occt_algorithms_7"></a>
General Fuse Algorithm</h1>
<h2><a class="anchor" id="occt_algorithms_7_1"></a>
Arguments</h2>
<p>The arguments of the algorithm are shapes (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>). The main requirements for the arguments are described in <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4">Data Structure</a> chapter.</p>
<h2><a class="anchor" id="occt_algorithms_7_2"></a>
Results</h2>
<p>During the operation argument <em>Si</em> can be split into several parts <em>Si1, Si2… Si1NbSp</em>, where <em>NbSp</em> is the number of parts. The set <em>(Si1, Si2… Si1NbSp)</em> is an image of argument <em>Si</em>.</p><ul>
<li>The result of the General Fuse operation is a compound. Each sub-shape of the compound corresponds to the certain argument shape S1, S2…Sn and has shared sub-shapes in accordance with interferences between the arguments.</li>
<li>For the arguments of the type EDGE, FACE, SOLID the result contains split parts of the argument.</li>
<li>For the arguments of the type WIRE, SHELL, COMPSOLID, COMPOUND the result contains the image of the shape of the corresponding type (i.e. WIRE, SHELL, COMPSOLID or COMPOUND). The types of resulting shapes depend on the type of the corresponding argument participating in the operation. See the table below:</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Type of argument </th><th align="left">Type of resulting shape </th><th align="left">Comments  </th></tr>
<tr>
<td align="left">1 </td><td align="left">COMPOUND </td><td align="left">COMPOUND </td><td align="left">The resulting COMPOUND is built from images of sub-shapes of type COMPOUND COMPSOLID, SHELL, WIRE and VERTEX. Sets of split sub-shapes of type SOLID, FACE, EDGE. </td></tr>
<tr>
<td align="left">2 </td><td align="left">COMPSOLID </td><td align="left">COMPSOLID </td><td align="left">The resulting COMPSOLID is built from split SOLIDs. </td></tr>
<tr>
<td align="left">3 </td><td align="left">SOLID </td><td align="left">Set of split SOLIDs </td><td align="left"></td></tr>
<tr>
<td align="left">4 </td><td align="left">SHELL </td><td align="left">SHELL </td><td align="left">The resulting SHELL is built from split FACEs </td></tr>
<tr>
<td align="left">5 </td><td align="left">FACE </td><td align="left">Set of split FACEs </td><td align="left"></td></tr>
<tr>
<td align="left">6 </td><td align="left">WIRE </td><td align="left">WIRE </td><td align="left">The resulting WIRE is built from split EDGEs </td></tr>
<tr>
<td align="left">7 </td><td align="left">EDGE </td><td align="left">Set of split EDGEs </td><td align="left"></td></tr>
<tr>
<td align="left">8 </td><td align="left">VERTEX </td><td align="left">VERTEX </td><td align="left"></td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_7_3a"></a>
Options</h2>
<p>The General Fuse algorithm has a set of options, which allow speeding-up the operation and improving the quality of the result:</p><ul>
<li>Parallel processing option allows running the algorithm in parallel mode;</li>
<li>Fuzzy option allows setting the additional tolerance for the operation;</li>
<li>Safe input shapes option allows preventing modification of the input shapes;</li>
<li>Gluing option allows speeding-up the intersection of the arguments;</li>
<li>Possibility to disable the check for the inverted solids among input shapes;</li>
<li>Usage of Oriented Bounding Boxes in the operation;</li>
<li>History support.</li>
</ul>
<p>For more detailed information on these options, see the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_11a">Advanced options</a> section.</p>
<h2><a class="anchor" id="occt_algorithms_7_3b"></a>
Usage</h2>
<p>The following example illustrates how to use the GF algorithm:</p>
<h4>Usage of the GF algorithm on C++ level</h4>
<div class="fragment"><div class="line">BOPAlgo_Builder aBuilder;</div><div class="line">// Setting arguments</div><div class="line">TopTools_ListOfShape aLSObjects = …; // Objects</div><div class="line">aBuilder.SetArguments(aLSObjects);</div><div class="line"></div><div class="line">// Setting options for GF</div><div class="line"></div><div class="line">// Set parallel processing mode (default is false)</div><div class="line">Standard_Boolean bRunParallel = Standard_True;</div><div class="line">aBuilder.SetRunParallel(bRunParallel);</div><div class="line"></div><div class="line">// Set Fuzzy value (default is Precision::Confusion())</div><div class="line">Standard_Real aFuzzyValue = 1.e-5;</div><div class="line">aBuilder.SetFuzzyValue(aFuzzyValue);</div><div class="line"></div><div class="line">// Set safe processing mode (default is false)</div><div class="line">Standard_Boolean bSafeMode = Standard_True;</div><div class="line">aBuilder.SetNonDestructive(bSafeMode);</div><div class="line"></div><div class="line">// Set Gluing mode for coinciding arguments (default is off)</div><div class="line">BOPAlgo_GlueEnum aGlue = BOPAlgo_GlueShift;</div><div class="line">aBuilder.SetGlue(aGlue);</div><div class="line"></div><div class="line">// Disabling/Enabling the check for inverted solids (default is true)</div><div class="line">Standard Boolean bCheckInverted = Standard_False;</div><div class="line">aBuilder.SetCheckInverted(bCheckInverted);</div><div class="line"></div><div class="line">// Set OBB usage (default is false)</div><div class="line">Standard_Boolean bUseOBB = Standard_True;</div><div class="line">aBuilder.SetUseOBB(buseobb);</div><div class="line"></div><div class="line">// Perform the operation</div><div class="line">aBuilder.Perform();</div><div class="line"></div><div class="line">// Check for the errors</div><div class="line">if (aBuilder.HasErrors())</div><div class="line">{</div><div class="line">  return;</div><div class="line">}</div><div class="line"></div><div class="line">// Check for the warnings</div><div class="line">if (aBuilder.HasWarnings())</div><div class="line">{</div><div class="line">  // treatment of the warnings</div><div class="line">  ...</div><div class="line">}</div><div class="line"></div><div class="line">// result of the operation</div><div class="line">const TopoDS_Shape&amp; aResult = aBuilder.Shape();</div></div><!-- fragment --><h4>Usage of the GF algorithm on Tcl level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 3 4 5 10 10 10 </div><div class="line">box b3 5 6 7 10 10 10 </div><div class="line"></div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line"></div><div class="line"># set the arguments</div><div class="line">baddobjects b1 b2 b3</div><div class="line"></div><div class="line"># setting options for GF</div><div class="line"></div><div class="line"># set parallel processing mode (default is 0)</div><div class="line">brunparallel 1</div><div class="line"></div><div class="line"># set Fuzzy value</div><div class="line">bfuzzyvalue 1.e-5</div><div class="line"></div><div class="line"># set safe processing mode (default is 0)</div><div class="line">bnondestructive 1</div><div class="line"></div><div class="line"># set gluing mode (default is 0)</div><div class="line">bglue 1</div><div class="line"></div><div class="line"># set check for inverted (default is 1)</div><div class="line">bcheckinverted 0</div><div class="line"></div><div class="line"># set obb usage (default is 0)</div><div class="line">buseobb 1</div><div class="line"></div><div class="line"># perform intersection</div><div class="line">bfillds</div><div class="line"></div><div class="line"># perform GF operaton</div><div class="line">bbuild result</div></div><!-- fragment --><h2><a class="anchor" id="occt_algorithms_7_3"></a>
Examples</h2>
<p>Have a look at the examples to better understand the definitions.</p>
<h3><a class="anchor" id="occt_algorithms_7_3_1"></a>
Case 1: Three edges intersecting at a point</h3>
<p>Let us consider three edges: <em>E1, E2</em> and <em>E3</em> that intersect in one 3D point.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image021.svg">operations_image021.svg</object>
<div class="caption">
Three Intersecting Edges</div></div>
<p> The result of the GFA operation is a compound containing 6 new edges: <em>E11, E12, E21, E22, E31</em>, and <em>E32</em>. These edges have one shared vertex <em>Vn1</em>.</p>
<p>In this case:</p><ul>
<li>The argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>).</li>
<li>The argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>).</li>
<li>The argument edge <em>E3</em> has resulting split edges <em>E31</em> and <em>E32</em> (image of <em>E3</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_2"></a>
Case 2: Two wires and an edge</h3>
<p>Let us consider two wires <em>W1 (Ew11, Ew12, Ew13)</em> and <em>W2 (Ew21, Ew22, Ew23)</em> and edge <em>E1</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image022.svg">operations_image022.svg</object>
<div class="caption">
Two wires and an edge</div></div>
<p> The result of the GF operation is a compound consisting of 2 wires: <em>Wn1 (Ew11, En1, En2, En3, Ew13)</em> and <em>Wn2 (Ew21, En2, En3, En4, Ew23)</em> and two edges: <em>E11</em> and <em>E12</em>.</p>
<p>In this case :</p><ul>
<li>The argument <em>W1</em> has image <em>Wn1</em>.</li>
<li>The argument <em>W2</em> has image <em>Wn2</em>.</li>
<li>The argument edge <em>E1</em> has split edges <em>E11</em> and <em>E12</em>. (image of <em>E1</em>). The edges <em>En1, En2, En3, En4</em> and vertex <em>Vn1</em> are new shapes created during the operation. Edge <em>Ew12</em> has split edges <em>En1, En2</em> and <em>En3</em> and edge <em>Ew22</em> has split edges <em>En2, En3</em> and <em>En4</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_3"></a>
Case 3: An edge intersecting with a face</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>:</p>
<div class="image">
<object type="image/svg+xml" data="operations_image023.svg">operations_image023.svg</object>
<div class="caption">
An edge intersecting with a face</div></div>
<p> The result of the GF operation is a compound consisting of 3 shapes:</p><ul>
<li>Split edge parts <em>E11</em> and <em>E12</em> (image of <em>E1</em>).</li>
<li>New face <em>F21</em> with internal edge <em>E12</em> (image of <em>F2</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_4"></a>
Case 4: An edge lying on a face</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>:</p>
<div class="image">
<object type="image/svg+xml" data="operations_image024.svg">operations_image024.svg</object>
<div class="caption">
An edge lying on a face</div></div>
<p> The result of the GF operation is a compound consisting of 5 shapes:</p><ul>
<li>Split edge parts <em>E11, E12</em> and <em>E13</em> (image of <em>E1</em>).</li>
<li>Split face parts <em>F21</em> and <em>F22</em> (image of <em>F2</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_5"></a>
Case 5: An edge and a shell</h3>
<p>Let us consider edge <em>E1</em> and shell <em>Sh2</em> that consists of 2 faces: <em>F21</em> and <em>F22</em></p>
<div class="image">
<object type="image/svg+xml" data="operations_image025.svg">operations_image025.svg</object>
<div class="caption">
An edge and a shell</div></div>
<p> The result of the GF operation is a compound consisting of 5 shapes:</p><ul>
<li>Split edge parts <em>E11, E12 , E13</em> and <em>E14</em> (image of <em>E1</em>).</li>
<li>Image shell <em>Sh21</em> (that contains split face parts <em>F211, F212, F221</em> and <em>F222</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_6"></a>
Case 6: A wire and a shell</h3>
<p>Let us consider wire <em>W1 (E1, E2, E3, E4)</em> and shell <em>Sh2 (F21, F22)</em>. </p><div class="image">
<object type="image/svg+xml" data="operations_image026.svg">operations_image026.svg</object>
<div class="caption">
A wire and a shell</div></div>
<p> The result of the GF operation is a compound consisting of 2 shapes:</p>
<ul>
<li>Image wire <em>W11</em> that consists of split edge parts from wire <em>W1: E11, E12, E13</em> and <em>E14</em>.</li>
<li>Image shell <em>Sh21</em> that contains split face parts: <em>F211, F212, F213, F221, F222</em> and <em>F223</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_7"></a>
Case 7: Three faces</h3>
<p>Let us consider 3 faces: <em>F1, F2</em> and <em>F3</em>. </p><div class="image">
<img src="operations_image027.png" alt="operations_image027.png"/>
<div class="caption">
Three faces</div></div>
<p> The result of the GF operation is a compound consisting of 7 shapes:</p><ul>
<li>Split face parts: <em>Fn1, Fn2, Fn3, Fn4, Fn5, Fn6</em> and <em>Fn7</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_8"></a>
Case 8: A face and a shell</h3>
<p>Let us consider shell <em>Sh1 (F11, F12, F13)</em> and face <em>F2</em>. </p><div class="image">
<img src="operations_image028.png" alt="operations_image028.png"/>
<div class="caption">
A face and a shell</div></div>
<p> The result of the GF operation is a compound consisting of 4 shapes:</p><ul>
<li>Image shell <em>Sh11</em> that consists of split face parts from shell <em>Sh1: Fn1, Fn2, Fn3, Fn4, Fn5</em> and <em>Fn6</em>.</li>
<li>Split parts of face <em>F2: Fn3, Fn6</em> and <em>Fn7</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_9"></a>
Case 9: A shell and a solid</h3>
<p>Let us consider shell <em>Sh1 (F11, F12…F16)</em> and solid <em>So2</em>. </p><div class="image">
<img src="operations_image029.png" alt="operations_image029.png"/>
<div class="caption">
A shell and a solid: arguments</div></div>
<p> The result of the GF operation is a compound consisting of 2 shapes:</p><ul>
<li>Image shell <em>Sh11</em> consisting of split face parts of <em>Sh1: Fn1, Fn2 ... Fn8.</em></li>
<li>Solid <em>So21</em> with internal shell. (image of <em>So2</em>). <div class="image">
<img src="operations_image030.png" alt="operations_image030.png"/>
<div class="caption">
A shell and a solid: results</div></div>
 </li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_10"></a>
Case 10: A compound and a solid</h3>
<p>Let us consider compound <em>Cm1</em> consisting of 2 solids <em>So11</em> and <em>So12</em>) and solid <em>So2</em>. </p><div class="image">
<img src="operations_image031.png" alt="operations_image031.png"/>
<div class="caption">
A compound and a solid: arguments</div></div>
<p> The result of the GF operation is a compound consisting of 4 shapes:</p><ul>
<li>Image compound <em>Cm11</em> consisting of split solid parts from <em>So11</em> and <em>So12 (Sn1, Sn2, Sn3, Sn4)</em>.</li>
<li>Split parts of solid <em>So2 (Sn2, Sn3, Sn5)</em>.</li>
</ul>
<div class="image">
<img src="operations_image032.png" alt="operations_image032.png"/>
<div class="caption">
A compound and a solid: results</div></div>
 <h2><a class="anchor" id="occt_algorithms_7_4"></a>
Class BOPAlgo_Builder</h2>
<p>GFA is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_1"></a>
Fields</h3>
<p>The main fields of the class are described in the Table:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em>myPaveFiller</em> </td><td align="left">Pointer to the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> object </td></tr>
<tr>
<td align="left"><em>myDS</em> </td><td align="left">Pointer to the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a></em> object </td></tr>
<tr>
<td align="left"><em>myContext</em> </td><td align="left">Pointer to the intersection Context </td></tr>
<tr>
<td align="left"><em>myImages</em> </td><td align="left">The Map between the source shape and its images </td></tr>
<tr>
<td align="left"><em>myShapesSD</em> </td><td align="left">The Map between the source shape (or split part of source shape) and the shape (or part of shape) that will be used in result due to same domain property. </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_2"></a>
Initialization</h3>
<p>The input data for this step is a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> object (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_5">Intersection</a>) at the state after <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_5_12">Processing of degenerated edges</a> with the corresponding DS.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Check the readiness of the DS and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a367b325c4291426a548b6241e12ffa72">BOPAlgo_Builder::CheckData()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Build an empty result of type Compound. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ad05584aee958fac60be8f4b46c52b9c6">BOPAlgo_Builder::Prepare()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_3"></a>
Build Images for Vertices</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after Initialization.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Fill <em>myShapesSD</em> by SD vertices using the information from the DS. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a610c88dc6d7e6d033f33d666c225cd6e">BOPAlgo_Builder::FillImagesVertices()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_4"></a>
Build Result of Type Vertex</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building images for vertices and <em>Type</em>, which is the shape type (<em>TopAbs_VERTEX</em>).</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For the arguments of type <em>Type</em>. If there is an image for the argument: add the image to the result. If there is no image for the argument: add the argument to the result. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a35e7b66b12c814dc8ba59cd5ea020cae">BOPAlgo_Builder::BuildResult()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_5"></a>
Build Images for Edges</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a> object</em> after building result of type vertex.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For all pave blocks in the DS. Fill <em>myImages</em> for the original edge <em>E</em> by split edges <em>ESPi</em> from pave blocks. In case of common blocks on edges, use edge <em>ESPSDj</em> that corresponds to the leading pave block and fill <em>myShapesSD</em> by the pairs <em>ESPi/ESPSDj</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a6032601163af5e2effd59a4e6987fc40">BOPAlgo_Builder::FillImagesEdges()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_6"></a>
Build Result of Type Edge</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type <em>Edge</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_7"></a>
Build Images for Wires</h3>
<p>The input data for this step is:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type <em>Edge</em>;</li>
<li>Original Shape &ndash; Wire</li>
<li><em>Type</em> &ndash; the shape type <em>(TopAbs_WIRE).</em></li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For all arguments of the type <em>Type</em>. Create a container C of the type <em>Type</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ac36f1bd699637355305a62a0d4d0cf0f">BOPAlgo_Builder::FillImagesContainers()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Add to C the images or non-split parts of the <em>Original Shape</em>, taking into account its orientation. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ac36f1bd699637355305a62a0d4d0cf0f">BOPAlgo_Builder::FillImagesContainers()</a></em> <em>BOPTools_Tools::IsSplitToReverse()</em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Fill <em>myImages</em> for the <em>Original Shape</em> by the information above. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ac36f1bd699637355305a62a0d4d0cf0f">BOPAlgo_Builder::FillImagesContainers()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_8"></a>
Build Result of Type Wire</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a> but for the type <em>Wire</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_9"></a>
Build Images for Faces</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type <em>Wire</em>.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Build Split Faces for all interfered DS shapes <em>Fi</em> of type <em>FACE</em>. </td><td align="left"></td></tr>
<tr>
<td align="left">1.1 </td><td align="left">Collect all edges or their images of <em>Fi(ESPij)</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.2 </td><td align="left">Impart to ESPij the orientation to be coherent with the original one. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.3 </td><td align="left">Collect all section edges <em>SEk</em> for <em>Fi</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.4 </td><td align="left">Build split faces for <em>Fi (Fi1, Fi2…FiNbSp)</em>, where <em>NbSp</em> is the number of split parts (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_2">Building faces from a set of edges</a> for more details). </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_face.html">BOPAlgo_BuilderFace</a></em> </td></tr>
<tr>
<td align="left">1.5 </td><td align="left">Impart to <em>(Fi1, Fi2…FiNbSp)</em> the orientation coherent with the original face <em>Fi</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.6 </td><td align="left">Fill the map mySplits with <em>Fi/(Fi1, Fi2…FiNbSp)</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Fill Same Domain faces </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces</a></em> </td></tr>
<tr>
<td align="left">2.1 </td><td align="left">Find and collect in the contents of <em>mySplits</em> the pairs of same domain split faces <em>(Fij, Fkl)m</em>, where <em>m</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces</a></em> <em>BOPTools_Tools::AreFacesSameDomain()</em> </td></tr>
<tr>
<td align="left">2.2 </td><td align="left">Compute the connexity chains 1) of same domain faces <em>(F1C, F2C… FnC)k, C=0, 1…nCs,</em> where <em>nCs</em> is the number of connexity chains. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
<tr>
<td align="left">2.3 </td><td align="left">Fill <em>myShapesSD</em> using the chains <em>(F1C, F2C… FnC)k</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
<tr>
<td align="left">2.4 </td><td align="left">Add internal vertices to split faces. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
<tr>
<td align="left">2.5 </td><td align="left">Fill <em>myImages</em> using <em>myShapesSD</em> and <em>mySplits</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
</table>
<p>The example of chains of same domain faces is given in the image:</p>
<div class="image">
<object type="image/svg+xml" data="operations_image033.svg">operations_image033.svg</object>
<div class="caption">
Chains of same domain faces</div></div>
<ul>
<li>The pairs of same domain faces are: <em>(F11, F21), (F22, F31), (F41, F51) , (F41, F6)</em> and <em>(F51, F6)</em>.</li>
<li>The pairs produce the three chains: <em>(F11, F21), (F22, F31)</em> and <em>(F41, F51, F6)</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_4_10"></a>
Build Result of Type Face</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a> but for the type <em>Face</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_11"></a>
Build Images for Shells</h3>
<p>The input data for this step is:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type face;</li>
<li><em>Original Shape</em> &ndash; a Shell;</li>
<li><em>Type</em> &ndash; the type of the shape <em>(TopAbs_SHELL)</em>.</li>
</ul>
<p>The procedure is the same as for building images for wires.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_12"></a>
Build Result of Type Shell</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a> but for the type <em>Shell</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_13"></a>
Build Images for Solids</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type <em>Shell</em>.</p>
<p>The following procedure is executed for all interfered DS shapes <em>Si</em> of type <em>SOLID</em>.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Collect all images or non-split parts for all faces <em>(FSPij)</em> that have 3D state <em>In Si</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a259f6382a19fc281bd5c315b0d6388c3">BOPAlgo_Builder::FillIn3DParts</a> ()</em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Collect all images or non-split parts for all faces of <em>Si</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a4a63b28d805b4076e5c29c798995bf33">BOPAlgo_Builder::BuildSplitSolids()</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Build split solids for <em>Si -&gt; (Si1, Si2…SiNbSp)</em>, where <em>NbSp</em> is the number of split parts (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_2">Building faces from a set of edges</a> for more details) </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_solid.html">BOPAlgo_BuilderSolid</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Fill the map Same Domain solids <em>myShapesSD</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a4a63b28d805b4076e5c29c798995bf33">BOPAlgo_Builder::BuildSplitSolids()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Fill the map <em>myImages</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a4a63b28d805b4076e5c29c798995bf33">BOPAlgo_Builder::BuildSplitSolids()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Add internal vertices to split solids </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a7b2ef635a9f9c95222c7cae0e6b17ed4">BOPAlgo_Builder::FillInternalShapes()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_14"></a>
Build Result of Type Solid</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type Solid.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_15"></a>
Build Images for Type CompSolid</h3>
<p>The input data for this step is:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type solid;</li>
<li><em>Original Shape</em> &ndash; a Compsolid;</li>
<li><em>Type</em> &ndash; the type of the shape <em>(TopAbs_COMPSOLID)</em>.</li>
</ul>
<p>The procedure is the same as for building images for wires.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_16"></a>
Build Result of Type Compsolid</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type Compsolid.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_17"></a>
Build Images for Compounds</h3>
<p>The input data for this step is as follows:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building results of type <em>compsolid</em>;</li>
<li><em>Original Shape</em> &ndash; a Compound;</li>
<li><em>Type</em> &ndash; the type of the shape <em>(TopAbs_COMPOUND)</em>.</li>
</ul>
<p>The procedure is the same as for building images for wires.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_18"></a>
Build Result of Type Compound</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type Compound.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_19"></a>
Post-Processing</h3>
<p>The purpose of the step is to correct tolerances of the result to provide its validity in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a>.</em></p>
<p>The input data for this step is a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type compound.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Correct tolerances of vertices on curves </td><td align="left"><em>BOPTools_Tools::CorrectPointOnCurve()</em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Correct tolerances of edges on faces </td><td align="left"><em>BOPTools_Tools::CorrectCurveOnSurface()</em> </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_8"></a>
Splitter Algorithm</h1>
<p>The Splitter algorithm allows splitting a group of arbitrary shapes by another group of arbitrary shapes.<br />
 It is based on the General Fuse algorithm, thus all options of the General Fuse (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_3a">GF Options</a>) are also available in this algorithm.</p>
<h2><a class="anchor" id="occt_algorithms_8_1"></a>
Arguments</h2>
<ul>
<li>The arguments of the Splitter algorithm are divided into two groups - <em>Objects</em> (shapes that will be split) and <em>Tools</em> (shapes, by which the <em>Objects</em> will be split);</li>
<li>The requirements for the arguments (both for <em>Objects</em> and <em>Tools</em>) are the same as for the General Fuse algorithm - there can be any number of arguments of any type in each group, but each argument should be valid and not self-interfered.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_8_2"></a>
Results</h2>
<ul>
<li>The result of Splitter algorithm contains only the split parts of the shapes included into the group of <em>Objects</em>;</li>
<li>The split parts of the shapes included only into the group of <em>Tools</em> are excluded from the result;</li>
<li>If there are no shapes in the group of <em>Tools</em> the result of the operation will be equivalent to the result of General Fuse operation;</li>
<li>The shapes can be split by other shapes from the same group (if these shapes are interfering).</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_8_3"></a>
Usage</h2>
<h3><a class="anchor" id="occt_algorithms_8_3_1"></a>
API</h3>
<p>On the low level the Splitter algorithm is implemented in class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___splitter.html">BOPAlgo_Splitter</a></em>. The usage of this algorithm looks as follows: </p><div class="fragment"><div class="line">BOPAlgo_Splitter aSplitter;</div><div class="line">// Setting arguments and tools</div><div class="line">TopTools_ListOfShape aLSObjects = …; // Objects</div><div class="line">TopTools_ListOfShape aLSTools = …; // Tools</div><div class="line">aSplitter.SetArguments(aLSObjects);</div><div class="line">aSplitter.SetTools(aLSTools);</div><div class="line"></div><div class="line">// Set options for the algorithm</div><div class="line">// setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line"></div><div class="line">// Perform the operation</div><div class="line">aSplitter.Perform();</div><div class="line">if (aSplitter.HasErrors()) { //check error status</div><div class="line">  return;</div><div class="line">}</div><div class="line">//</div><div class="line">const TopoDS_Shape&amp; aResult = aSplitter.Shape(); // result of the operation</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_8_3_2"></a>
DRAW</h3>
<p>The command <em>bsplit</em> implements the Splitter algorithm in DRAW. Similarly to the <em>bbuild</em> command for the General Fuse algorithm, the <em>bsplit</em> command should be used after the Pave Filler is filled. </p><div class="fragment"><div class="line"># s1 s2 s3 - objects</div><div class="line"># t1 t2 t3 - tools</div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line">baddobjects s1 s2 s3</div><div class="line">baddtools t1 t2 t3</div><div class="line">bfillds</div><div class="line">bsplit result</div></div><!-- fragment --><h2><a class="anchor" id="occt_algorithms_8_4"></a>
Examples</h2>
<h3><a class="anchor" id="occt_algorithms_8_4_1"></a>
Example 1</h3>
<p>Splitting a face by the set of edges:</p>
<div class="fragment"><div class="line"># draw script for reproducing</div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line"></div><div class="line">set height 20</div><div class="line">cylinder cyl 0 0 0 0 0 1 10</div><div class="line">mkface f cyl 0 2*pi -$height $height</div><div class="line">baddobjects f</div><div class="line"></div><div class="line"># create tool edges</div><div class="line">compound edges</div><div class="line"></div><div class="line">set nb_uedges 10</div><div class="line">set pi2 [dval 2*pi]</div><div class="line">set ustep [expr $pi2/$nb_uedges]</div><div class="line">for {set i 0} {$i &lt;= $pi2} {set i [expr $i + $ustep]} {</div><div class="line">  uiso c cyl $i</div><div class="line">  mkedge e c -25 25</div><div class="line">  add e edges</div><div class="line">}</div><div class="line"></div><div class="line">set nb_vedges 10</div><div class="line">set vstep [expr 2*$height/$nb_vedges]</div><div class="line">for {set i -20} {$i &lt;= 20} {set i [expr $i + $vstep]} {</div><div class="line">  viso c cyl $i</div><div class="line">  mkedge e c</div><div class="line">  add e edges</div><div class="line">}</div><div class="line">baddctools edges</div><div class="line"></div><div class="line">bfillds</div><div class="line">bsplit result</div></div><!-- fragment --><table align="center">
<tr>
<td><div class="image">
<img src="bsplit_image001.png" alt="bsplit_image001.png"/>
<div class="caption">
Arguments</div></div>
 </td><td><div class="image">
<img src="bsplit_image002.png" alt="bsplit_image002.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_8_4_2"></a>
Example 2</h3>
<p>Splitting a plate by the set of cylinders:</p>
<div class="fragment"><div class="line"># draw script for reproducing:</div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line"></div><div class="line">box plate 100 100 1</div><div class="line">baddobjects plate</div><div class="line"></div><div class="line">pcylinder p 1 11</div><div class="line">compound cylinders</div><div class="line">for {set i 0} {$i &lt; 101} {incr i 5} {</div><div class="line">  for {set j 0} {$j &lt; 101} {incr j 5} {</div><div class="line">    copy p p1;</div><div class="line">    ttranslate p1 $i $j -5;</div><div class="line">    add p1 cylinders</div><div class="line">  }</div><div class="line">}</div><div class="line">baddtools cylinders</div><div class="line"></div><div class="line">bfillds</div><div class="line">bsplit result</div></div><!-- fragment --><table align="center">
<tr>
<td><div class="image">
<img src="bsplit_image003.png" alt="bsplit_image003.png"/>
<div class="caption">
Arguments</div></div>
 </td><td><div class="image">
<img src="bsplit_image004.png" alt="bsplit_image004.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_8_4_3"></a>
Example 3</h3>
<p>Splitting shell hull by the planes: </p><table align="center">
<tr>
<td><div class="image">
<img src="bsplit_image005.png" alt="bsplit_image005.png"/>
<div class="caption">
Arguments</div></div>
 </td><td><div class="image">
<img src="bsplit_image006.png" alt="bsplit_image006.png"/>
<div class="caption">
Results</div></div>
  </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_9"></a>
Boolean Operations Algorithm</h1>
<h2><a class="anchor" id="occt_algorithms_9_1"></a>
Arguments</h2>
<ul>
<li>The arguments of BOA are shapes in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The main requirements for the arguments are described in the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4">Data Structure</a></li>
<li>There are two groups of arguments in BOA:<ul>
<li>Objects <em>(S1=S11, S12, ...)</em>;</li>
<li>Tools <em>(S2=S21, S22, ...)</em>.</li>
</ul>
</li>
<li>The following table contains the values of dimension for different types of arguments:</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Type of Argument </th><th align="left">Index of Type </th><th align="left">Dimension  </th></tr>
<tr>
<td align="left">1 </td><td align="left">COMPOUND </td><td align="left">0 </td><td align="left">One of 0, 1, 2, 3 </td></tr>
<tr>
<td align="left">2 </td><td align="left">COMPSOLID </td><td align="left">1 </td><td align="left">3 </td></tr>
<tr>
<td align="left">3 </td><td align="left">SOLID </td><td align="left">2 </td><td align="left">3 </td></tr>
<tr>
<td align="left">4 </td><td align="left">SHELL </td><td align="left">3 </td><td align="left">2 </td></tr>
<tr>
<td align="left">5 </td><td align="left">FACE </td><td align="left">4 </td><td align="left">2 </td></tr>
<tr>
<td align="left">6 </td><td align="left">WIRE </td><td align="left">5 </td><td align="left">1 </td></tr>
<tr>
<td align="left">7 </td><td align="left">EDGE </td><td align="left">6 </td><td align="left">1 </td></tr>
<tr>
<td align="left">8 </td><td align="left">VERTEX </td><td align="left">7 </td><td align="left">0 </td></tr>
</table>
<ul>
<li>For Boolean operation Fuse all arguments should have equal dimensions.</li>
<li>For Boolean operation Cut the minimal dimension of <em>S2</em> should not be less than the maximal dimension of <em>S1</em>.</li>
<li>For Boolean operation Common the arguments can have any dimension.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_9_3"></a>
Results. General Rules</h2>
<ul>
<li>The result of the Boolean operation is a compound (if defined). Each sub-shape of the compound has shared sub-shapes in accordance with interferences between the arguments.</li>
<li>The content of the result depends on the type of the operation (Common, Fuse, Cut12, Cut21) and the dimensions of the arguments.</li>
<li>The result of the operation Fuse is defined for arguments <em>S1</em> and <em>S2</em> that have the same dimension value : <em>Dim(S1)=Dim(S2)</em>. If the arguments have different dimension values the result of the operation Fuse is not defined. The dimension of the result is equal to the dimension of the arguments. For example, it is impossible to fuse an edge and a face.</li>
<li>The result of the operation Fuse for arguments <em>S1</em> and <em>S2</em> contains the parts of arguments that have states <b>OUT</b> relative to the opposite arguments.</li>
<li>The result of the operation Fuse for arguments <em>S1</em> and <em>S2</em> having dimension value 3 (Solids) is refined by removing all possible internal faces to provide minimal number of solids.</li>
<li>The result of the operation Common for arguments <em>S1</em> and <em>S2</em> is defined for all values of the dimensions of the arguments. The result can contain shapes of different dimensions, but the minimal dimension of the result will be equal to the minimal dimension of the arguments. For example, the result of the operation Common between edges cannot be a vertex.</li>
<li>The result of the operation Common for the arguments <em>S1</em> and <em>S2</em> contains the parts of the argument that have states <b>IN</b> and <b>ON</b> relative to the opposite argument.</li>
<li>The result of the operation Cut is defined for arguments <em>S1</em> and <em>S2</em> that have values of dimensions <em>Dim(S2)</em> that should not be less than <em>Dim(S1)</em>. The result can contain shapes of different dimensions, but the minimal dimension of the result will be equal to the minimal dimension of the objects <em>Dim(S1)</em>. The result of the operation <em>Cut12</em> is not defined for other cases. For example, it is impossible to cut an edge from a solid, because a solid without an edge is not defined.</li>
<li>The result of the operation <em>Cut12</em> for arguments <em>S1</em> and <em>S2</em> contains the parts of argument <em>S1</em> that have state <b>OUT</b> relative to the opposite argument <em>S2</em>.</li>
<li>The result of the operation <em>Cut21</em> for arguments <em>S1</em> and <em>S2</em> contains the parts of argument <em>S2</em> that have state <b>OUT</b> relative to the opposite argument <em>S1</em>.</li>
<li>For the arguments of collection type (WIRE, SHELL, COMPSOLID) the type will be passed in the result. For example, the result of Common operation between Shell and Wire will be a compound containing Wire.</li>
<li>For the arguments of collection type (WIRE, SHELL, COMPSOLID) containing overlapping parts the overlapping parts passed into result will be repeated for each container from the input shapes containing such parts. The containers completely included in other containers will be avoided in the result.</li>
<li>For the arguments of collection type (WIRE, SHELL, COMPSOLID) the containers included into result will have the same orientation as the original containers from arguments. In case of duplication its orientation will be defined by the orientation of the first container in arguments. Each container included into result will have coherent orientation of its sub-shapes.</li>
<li>The result of the operation Fuse for the arguments of collection type (WIRE, SHELL) will consist of the shapes of the same collection type. The overlapping parts (EDGES/FACES) will be shared among containers, but duplicating containers will be avoided in the result. For example, the result of Fuse operation between two fully coinciding wires will be one wire, but the result of Fuse operation between two partially coinciding wires will be two wires sharing coinciding edges.</li>
<li>The result of the operation Fuse for the arguments of type COMPSOLID will consist of the compound containing COMPSOLIDs created from connexity blocks of fused solids.</li>
<li>The result of the operation Common for the arguments of collection type (WIRE, SHELL, COMPSOLID) will consist of the unique containers containing the overlapping parts. For example, the result of Common operation between two fully overlapping wires will be one wire containing all splits of edges. The number of wires in the result of Common operation between two partially overlapping wires will be equal to the number of connexity blocks of overlapping edges.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_9_4"></a>
Examples</h2>
<h3><a class="anchor" id="occt_algorithms_9_4_1"></a>
Case 1: Two Vertices</h3>
<p>Let us consider two interfering vertices <em>V1</em> and <em>V2</em>:</p>
<div class="image">
<object type="image/svg+xml" data="boolean_image001.svg">boolean_image001.svg</object>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is the compound that contains new vertex <em>V</em>.</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="boolean_image002.svg">boolean_image002.svg</object>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing new vertex <em>V</em>.</li>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is an empty compound.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_2"></a>
Case 2: A Vertex and an Edge</h3>
<p>Let us consider vertex <em>V1</em> and the edge <em>E2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image004.png" alt="boolean_image004.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is result is not defined because the dimension of the vertex (0) is not equal to the dimension of the edge (1).</li>
<li>The result of <em>Common</em> operation is a compound containing vertex <em>V<sub>1</sub></em> as the argument <em>V<sub>1</sub></em> has a common part with edge <em>E2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image005.png" alt="boolean_image005.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the vertex (0) is less than the dimension of the edge (1).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_3"></a>
Case 3: A Vertex and a Face</h3>
<p>Let us consider vertex <em>V1</em> and face <em>F2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image006.png" alt="boolean_image006.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the vertex (0) is not equal to the dimension of the face (2).</li>
<li>The result of <em>Common</em> operation is a compound containing vertex <em>V<sub>1</sub></em> as the argument <em>V<sub>1</sub></em> has a common part with face <em>F2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image007.png" alt="boolean_image007.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the vertex (0) is less than the dimension of the face (2).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_4"></a>
Case 4: A Vertex and a Solid</h3>
<p>Let us consider vertex <em>V1</em> and solid <em>S2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image008.png" alt="boolean_image008.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the vertex (0) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing vertex <em>V<sub>1</sub></em> as the argument <em>V<sub>1</sub></em> has a common part with solid <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image009.png" alt="boolean_image009.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the vertex (0) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_5"></a>
Case 5: Two edges intersecting at one point</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em> that intersect in a 3D point:</p>
<div class="image">
<object type="image/svg+xml" data="boolean_image010.svg">boolean_image010.svg</object>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments i.e. 4 new edges <em>E11, E12, E21</em>, and <em>E22</em>. These edges have one shared vertex <em>Vn1</em>. In this case:<ul>
<li>argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>);</li>
<li>argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>).</li>
</ul>
</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="boolean_image011.svg">boolean_image011.svg</object>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between the edges (vertex) is less than the dimension of the arguments (1).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split parts of the argument <em>E1</em>, i.e. 2 new edges <em>E11</em> and <em>E12</em>. These edges have one shared vertex <em>Vn1</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>).</p>
<div class="image">
<object type="image/svg+xml" data="boolean_image012.svg">boolean_image012.svg</object>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>E2</em>, i.e. 2 new edges <em>E21</em> and <em>E12</em>. These edges have one shared vertex <em>Vn1</em>.</li>
</ul>
<p>In this case the argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>).</p>
<div class="image">
<object type="image/svg+xml" data="boolean_image013.svg">boolean_image013.svg</object>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_6"></a>
Case 6: Two edges having a common block</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em> that have a common block:</p>
<div class="image">
<object type="image/svg+xml" data="boolean_image014.svg">boolean_image014.svg</object>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments i.e. 3 new edges <em>E11</em>, <em>E12</em> and <em>E22</em>. These edges have two shared vertices. In this case:<ul>
<li>argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>);</li>
<li>argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>);</li>
<li>edge <em>E12</em> is common for the images of <em>E1</em> and <em>E2</em>.</li>
</ul>
</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="boolean_image015.svg">boolean_image015.svg</object>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing split parts of arguments i.e. 1 new edge <em>E12</em>. In this case edge <em>E12</em> is common for the images of <em>E1</em> and <em>E2</em>. The common part between the edges (edge) has the same dimension (1) as the dimension of the arguments (1).</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="boolean_image016.svg">boolean_image016.svg</object>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing a split part of argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="boolean_image017.svg">boolean_image017.svg</object>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing a split part of argument <em>E2</em>, i.e. new edge <em>E22</em>.</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="boolean_image018.svg">boolean_image018.svg</object>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_7"></a>
Case 7: An Edge and a Face intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em> that intersect at a 3D point:</p>
<div class="image">
<img src="boolean_image019.png" alt="boolean_image019.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the face (2).</li>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between the edge and face (vertex) is less than the dimension of the arguments (1).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split parts of the argument <em>E1</em>, i.e. 2 new edges <em>E11</em> and <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has no common parts with the face <em>F2</em> so the whole image of <em>E1</em> is in the result.</p>
<div class="image">
<img src="boolean_image020.png" alt="boolean_image020.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the face (2).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_8"></a>
Case 8: A Face and an Edge that have a common block</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em> that have a common block:</p>
<div class="image">
<img src="boolean_image021.png" alt="boolean_image021.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the face (2).</li>
<li>The result of <em>Common</em> operation is a compound containing a split part of the argument <em>E1</em>, i.e. new edge <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with face <em>F2</em> so the corresponding part of the image of <em>E1</em> is in the result. The yellow square is not a part of the result. It only shows the place of <em>F2</em>.</p>
<div class="image">
<img src="boolean_image022.png" alt="boolean_image022.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with face <em>F2</em> so the corresponding part is not included into the result. The yellow square is not a part of the result. It only shows the place of F2.</p>
<div class="image">
<img src="boolean_image023.png" alt="boolean_image023.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the face (2).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_9"></a>
Case 9: An Edge and a Solid intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and solid <em>S2</em> that intersect at a point:</p>
<div class="image">
<img src="boolean_image024.png" alt="boolean_image024.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing a split part of the argument <em>E1</em>, i.e. new edge <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part of the image of <em>E1</em> is in the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image025.png" alt="boolean_image025.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image071.png" alt="boolean_image071.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_10"></a>
Case 10: An Edge and a Solid that have a common block</h3>
<p>Let us consider edge <em>E1</em> and solid <em>S2</em> that have a common block:</p>
<div class="image">
<img src="boolean_image072.png" alt="boolean_image072.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing a split part of the argument <em>E1</em>, i.e. new edge <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part of the image of <em>E1</em> is in the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image073.png" alt="boolean_image073.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image026.png" alt="boolean_image026.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_11"></a>
Case 11: Two intersecting faces</h3>
<p>Let us consider two intersecting faces <em>F1</em> and <em>F2</em>:</p>
<div class="image">
<img src="boolean_image027.png" alt="boolean_image027.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments i.e. 2 new faces <em>F11</em> and <em>F21</em>. These faces have one shared edge <em>En1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image028.png" alt="boolean_image028.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>F2</em> (edge) is less than the dimension of arguments (2).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image029.png" alt="boolean_image029.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image030.png" alt="boolean_image030.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_12"></a>
Case 12: Two faces that have a common part</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common part:</p>
<div class="image">
<img src="boolean_image031.png" alt="boolean_image031.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments, i.e. 3 new faces: <em>F11</em>, <em>F12</em> and <em>F22</em>. These faces are shared through edges In this case:<ul>
<li>the argument edge <em>F1</em> has resulting split faces <em>F11</em> and <em>F12</em> (image of <em>F1</em>)</li>
<li>the argument face <em>F2</em> has resulting split faces <em>F12</em> and <em>F22</em> (image of <em>F2</em>)</li>
<li>the face <em>F12</em> is common for the images of <em>F1</em> and <em>F2</em>.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="boolean_image032.png" alt="boolean_image032.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing split parts of arguments i.e. 1 new face <em>F12</em>. In this case: face <em>F12</em> is common for the images of <em>F1</em> and <em>F2</em>. The common part between the faces (face) has the same dimension (2) as the dimension of the arguments (2).</li>
</ul>
<div class="image">
<img src="boolean_image033.png" alt="boolean_image033.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image034.png" alt="boolean_image034.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image035.png" alt="boolean_image035.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_13"></a>
Case 13: Two faces that have a common edge</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common edge:</p>
<div class="image">
<img src="boolean_image036.png" alt="boolean_image036.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments, i.e. 2 new faces: <em>F11</em> and <em>F21</em>. These faces have one shared edge <em>En1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image037.png" alt="boolean_image037.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>F2</em> (edge)is less than the dimension of the arguments (2)</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>. The vertices are shown just to clarify the fact that the edges are spitted.</li>
</ul>
<div class="image">
<img src="boolean_image038.png" alt="boolean_image038.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>. The vertices are shown just to clarify the fact that the edges are spitted.</li>
</ul>
<div class="image">
<img src="boolean_image039.png" alt="boolean_image039.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_14"></a>
Case 14: Two faces that have a common vertex</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common vertex:</p>
<div class="image">
<img src="boolean_image040.png" alt="boolean_image040.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments, i.e. 2 new faces: <em>F11</em> and <em>F21</em>. These faces have one shared vertex <em>Vn1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image041.png" alt="boolean_image041.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between <em>F1</em> and <em>F2</em> (vertex) is less than the dimension of the arguments (2)</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image042.png" alt="boolean_image042.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image043.png" alt="boolean_image043.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_15"></a>
Case 15: A Face and a Solid that have an intersection curve.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have an intersection curve:</p>
<div class="image">
<img src="boolean_image044.png" alt="boolean_image044.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing split part of the argument <em>F1</em>. In this case the argument face <em>F1</em> has a common part with solid <em>S2</em>, so the corresponding part of the image of <em>F1</em> is in the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image045.png" alt="boolean_image045.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image046.png" alt="boolean_image046.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_16"></a>
Case 16: A Face and a Solid that have overlapping faces.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have overlapping faces:</p>
<div class="image">
<img src="boolean_image047.png" alt="boolean_image047.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing split part of the argument <em>F1</em>. In this case the argument face <em>F1</em> has a common part with solid <em>S2</em>, so the corresponding part of the image of <em>F1</em> is included in the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image048.png" alt="boolean_image048.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image049.png" alt="boolean_image049.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_17"></a>
Case 17: A Face and a Solid that have overlapping edges.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have overlapping edges:</p>
<div class="image">
<img src="boolean_image050.png" alt="boolean_image050.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>S2</em> (edge) is less than the lower dimension of the arguments (2).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image051.png" alt="boolean_image051.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_18"></a>
Case 18: A Face and a Solid that have overlapping vertices.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image052.png" alt="boolean_image052.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>S2</em> (vertex) is less than the lower dimension of the arguments (2).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image053.png" alt="boolean_image053.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_19"></a>
Case 19: Two intersecting Solids.</h3>
<p>Let us consider two intersecting solids <em>S1</em> and <em>S2</em>:</p>
<div class="image">
<img src="boolean_image054.png" alt="boolean_image054.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments <em>S11, S12</em> and <em>S22</em> <em>(Cut12, Common, Cut21)</em>. All inner webs are removed, so the result is one new solid <em>R</em>.</li>
</ul>
<div class="image">
<img src="boolean_image055.png" alt="boolean_image055.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing split parts of arguments i.e. one new solid <em>S12</em>. In this case solid <em>S12</em> is common for the images of <em>S1</em> and <em>S2</em>. The common part between the solids (solid) has the same dimension (3) as the dimension of the arguments (3). The yellow contour is not a part of the result. It only shows the place of <em>S1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image056.png" alt="boolean_image056.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>, i.e. 1 new solid <em>S11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image057.png" alt="boolean_image057.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>, i.e. 1 new solid <em>S21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image058.png" alt="boolean_image058.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_20"></a>
Case 20: Two Solids that have overlapping faces.</h3>
<p>Let us consider two solids <em>S1</em> and <em>S2</em> that have a common part on face:</p>
<div class="image">
<img src="boolean_image059.png" alt="boolean_image059.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments <em>S11, S12</em> and <em>S22</em> <em>(Cut12, Common, Cut21)</em>. All inner webs are removed, so the result is one new solid <em>R</em>.</li>
</ul>
<div class="image">
<img src="boolean_image060.png" alt="boolean_image060.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (2) of the common part between <em>S1</em> and <em>S2</em> (face) is less than the lower dimension of the arguments (3).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>, i.e. 1 new solid <em>S11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image061.png" alt="boolean_image061.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>, i.e. 1 new solid <em>S21</em>. <div class="image">
<img src="boolean_image062.png" alt="boolean_image062.png"/>
</div>
</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_21"></a>
Case 21: Two Solids that have overlapping edges.</h3>
<p>Let us consider two solids <em>S1</em> and <em>S2</em> that have overlapping edges:</p>
<div class="image">
<img src="boolean_image063.png" alt="boolean_image063.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments i.e. 2 new solids <em>S11</em> and <em>S21</em>. These solids have one shared edge <em>En1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image064.png" alt="boolean_image064.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>S1</em> and <em>S2</em> (edge) is less than the lower dimension of the arguments (3).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>. In this case argument <em>S1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image065.png" alt="boolean_image065.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>. In this case argument <em>S2</em> has a common part with solid <em>S1</em> so the corresponding part is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image066.png" alt="boolean_image066.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_22"></a>
Case 22: Two Solids that have overlapping vertices.</h3>
<p>Let us consider two solids <em>S1</em> and <em>S2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image067.png" alt="boolean_image067.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments i.e. 2 new solids <em>S11</em> and <em>S21</em>. These solids share <em>Vn1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image068.png" alt="boolean_image068.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between <em>S1</em> and <em>S2</em> (vertex) is less than the lower dimension of the arguments (3).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image069.png" alt="boolean_image069.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image070.png" alt="boolean_image070.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_9_4_23"></a>
Case 23: A Shell and a Wire cut by a Solid.</h3>
<p>Let us consider Shell <em>Sh</em> and Wire <em>W</em> as the objects and Solid <em>S</em> as the tool:</p>
<div class="image">
<img src="boolean_image136.png" alt="boolean_image136.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined as the dimension of the arguments is not the same.</li>
<li>The result of <em>Common</em> operation is a compound containing the parts of the initial Shell and Wire common for the Solid. The new Shell and Wire are created from the objects.</li>
</ul>
<div class="image">
<img src="boolean_image137.png" alt="boolean_image137.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing new Shell and Wire split from the arguments <em>Sh</em> and <em>W</em>. In this case they have a common part with solid <em>S</em> so the corresponding part is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image138.png" alt="boolean_image138.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined as the objects have a lower dimension than the tool.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_24"></a>
Case 24: Two Wires that have overlapping edges.</h3>
<p>Let us consider two Wires that have overlapping edges, <em>W1</em> is the object and <em>W2</em> is the tool:</p>
<div class="image">
<img src="boolean_image139.png" alt="boolean_image139.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing two Wires, which share an overlapping edge. The new Wires are created from the objects:</li>
</ul>
<div class="image">
<img src="boolean_image140.png" alt="boolean_image140.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing one Wire consisting of an overlapping edge. The new Wire is created from the objects:</li>
</ul>
<div class="image">
<img src="boolean_image141.png" alt="boolean_image141.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing a wire split from object <em>W1</em>. Its common part with <em>W2</em> is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image142.png" alt="boolean_image142.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing a wire split from <em>W2</em>. Its common part with <em>W1</em> is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image143.png" alt="boolean_image143.png"/>
</div>
<h2><a class="anchor" id="occt_algorithms_9_5"></a>
Class BOPAlgo_BOP</h2>
<p>BOA is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em>. The main fields of this class are described in the Table:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em>myOperation</em> </td><td align="left">The type of the Boolean operation (Common, Fuse, Cut) </td></tr>
<tr>
<td align="left"><em>myTools</em> </td><td align="left">The tools </td></tr>
<tr>
<td align="left"><em>myDims[2]</em> </td><td align="left">The values of the dimensions of the arguments </td></tr>
<tr>
<td align="left"><em>myRC</em> </td><td align="left">The draft result (shape) </td></tr>
</table>
<p>The main steps of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> are the same as of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4">BOPAlgo_Builder</a> except for some aspects described in the next paragraphs.</p>
<h2><a class="anchor" id="occt_algorithms_9_6"></a>
Building Draft Result</h2>
<p>The input data for this step is as follows:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> object after building result of type <em>Compound</em>;</li>
<li><em>Type</em> of the Boolean operation.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For the Boolean operation <em>Fuse</em> add to <em>myRC</em> all images of arguments. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a3001239a29dfb6095e1144e81fff3216">BOPAlgo_BOP::BuildRC()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For the Boolean operation <em>Common</em> or <em>Cut</em> add to <em>myRC</em> all images of argument <em>S1</em> that are <em>Common</em> for the Common operation and are <em>Not Common</em> for the Cut operation </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a3001239a29dfb6095e1144e81fff3216">BOPAlgo_BOP::BuildRC()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_9_7"></a>
Building the Result</h2>
<p>The input data for this step is as follows:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> object the state after building draft result.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For the Type of the Boolean operation Common, Cut with any dimension and operation Fuse with <em>myDim[0] &lt; 3</em> </td><td align="left"></td></tr>
<tr>
<td align="left">1.1 </td><td align="left">Find containers (WIRE, SHELL, COMPSOLID) in the arguments </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a>:: BuildShape()</em> </td></tr>
<tr>
<td align="left">1.2 </td><td align="left">Make connexity blocks from splits of each container that are in <em>myRC</em> </td><td align="left"><em>BOPTools_Tools::MakeConnexityBlocks()</em> </td></tr>
<tr>
<td align="left">1.3 </td><td align="left">Build the result from shapes made from the connexity blocks </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a>:: BuildShape()</em> </td></tr>
<tr>
<td align="left">1.4 </td><td align="left">Add the remaining shapes from <em>myRC</em> to the result </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a>:: BuildShape()</em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For the Type of the Boolean operation Fuse with <em>myDim[0] = 3</em> </td><td align="left"></td></tr>
<tr>
<td align="left">2.1 </td><td align="left">Find internal faces <em>(FWi)</em> in <em>myRC</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a2aef6284660d5e8b5c4a94505090d806">BOPAlgo_BOP::BuildSolid()</a></em> </td></tr>
<tr>
<td align="left">2.2 </td><td align="left">Collect all faces of <em>myRC</em> except for internal faces <em>(FWi) -&gt; SFS</em> </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a2aef6284660d5e8b5c4a94505090d806">BOPAlgo_BOP::BuildSolid</a> ()</em> </td></tr>
<tr>
<td align="left">2.3 </td><td align="left">Build solids <em>(SDi)</em> from <em>SFS</em>. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_solid.html">BOPAlgo_BuilderSolid</a></em> </td></tr>
<tr>
<td align="left">2.4 </td><td align="left">Add the solids <em>(SDi)</em> to the result </td><td align="left"></td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_bop_on_opensolids"></a>
Boolean operations on open solids</h2>
<p>The Boolean operations on open solids are tricky enough that the standard approach of Boolean operations for building the result, based on the splits of solids does not work. It happens because the algorithm for splitting solids (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_solid.html">BOPAlgo_BuilderSolid</a></em>) always tries to create the closed loops (shells) and make solids from them. But if the input solid is not closed, what can be expected from its splits? For performing Boolean Operations on open solids another approach is used, which does not rely on the splits of the solids to be correct, but tries to select the splits of faces, which are necessary for the given type of operation. The point here is that the type of Boolean operation clearly defines the states for the faces to be taken into result:</p><ul>
<li>For <b>COMMON</b> operation all the faces from the arguments located inside any solid of the opposite group must be taken;</li>
<li>For <b>FUSE</b> operation all the faces from the arguments located outside of all solids of the opposite group must be taken;</li>
<li>For <b>CUT</b> operation all the faces from the Objects located outside of all solids of the Tools and all faces from the Tools located inside any solid of the Objects must be taken;</li>
<li>For <b>CUT21</b> operation all the faces from the Objects located inside any solid of the Tools and all faces from the Tools located outside of all solids of the Objects must be taken. From the selected faces the result solids are built. Please note, that the result may contain as normal (closed) solids as the open ones.</li>
</ul>
<p>Even with this approach, the correct result of Boolean operation on open solids cannot be always guaranteed. This is explained by non-manifold nature of open solids: in some cases classification of a face depends on the point of the face chosen for classification.</p>
<h1><a class="anchor" id="occt_algorithms_10a"></a>
Section Algorithm</h1>
<h2><a class="anchor" id="occt_algorithms_10a_1"></a>
Arguments</h2>
<p>The arguments of BOA are shapes in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The main requirements for the arguments are described in the Algorithms.</p>
<h2><a class="anchor" id="occt_algorithms_10a_2"></a>
Results and general rules</h2>
<ul>
<li>The result of Section operation is a compound. Each sub-shape of the compound has shared sub-shapes in accordance with interferences between the arguments.</li>
<li>The result of Section operation contains shapes that have dimension that is less then 2 i.e. vertices and edges.</li>
<li>The result of Section operation contains standalone vertices if these vertices do not belong to the edges of the result.</li>
<li>The result of Section operation contains vertices and edges of the arguments (or images of the arguments) that belong to at least two arguments (or two images of the arguments).</li>
<li>The result of Section operation contains Section vertices and edges obtained from Face/Face interferences.</li>
<li>The result of Section operation contains vertices that are the result of interferences between vertices and faces.</li>
<li>The result of Section operation contains edges that are the result of interferences between edges and faces (Common Blocks),</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_10a_3"></a>
Examples</h2>
<h3><a class="anchor" id="occt_algorithms_10a_3_1"></a>
Case 1: Two Vertices</h3>
<p>Let us consider two interfering vertices: <em>V1</em> and <em>V2</em>.</p>
<div class="image">
<img src="boolean_image080.png" alt="boolean_image080.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>V</em>.</p>
<div class="image">
<img src="boolean_image081.png" alt="boolean_image081.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_2"></a>
Case 1: Case 2: A Vertex and an Edge</h3>
<p>Let us consider vertex <em>V1</em> and the edge <em>E2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image082.png" alt="boolean_image082.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains vertex <em>V1</em>.</p>
<div class="image">
<img src="boolean_image083.png" alt="boolean_image083.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_3"></a>
Case 1: Case 2: A Vertex and a Face</h3>
<p>Let us consider vertex <em>V1</em> and face <em>F2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image084.png" alt="boolean_image084.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains vertex <em>V1</em>.</p>
<div class="image">
<img src="boolean_image085.png" alt="boolean_image085.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_4"></a>
Case 4: A Vertex and a Solid</h3>
<p>Let us consider vertex <em>V1</em> and solid <em>Z2</em>. The vertex <em>V1</em> is inside the solid <em>Z2</em>.</p>
<div class="image">
<img src="boolean_image086.png" alt="boolean_image086.png"/>
</div>
<p> The result of <em>Section</em> operation is an empty compound.</p>
<h3><a class="anchor" id="occt_algorithms_10a_3_5"></a>
Case 5: Two edges intersecting at one point</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image087.png" alt="boolean_image087.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image088.png" alt="boolean_image088.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_6"></a>
Case 6: Two edges having a common block</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em>, that have a common block:</p>
<div class="image">
<img src="boolean_image089.png" alt="boolean_image089.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image090.png" alt="boolean_image090.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_7"></a>
Case 7: An Edge and a Face intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>, that intersect at a 3D point:</p>
<div class="image">
<img src="boolean_image091.png" alt="boolean_image091.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image092.png" alt="boolean_image092.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_8"></a>
Case 8: A Face and an Edge that have a common block</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>, that have a common block:</p>
<div class="image">
<img src="boolean_image093.png" alt="boolean_image093.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image094.png" alt="boolean_image094.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_9"></a>
Case 9: An Edge and a Solid intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and solid <em>Z2</em>, that intersect at a point:</p>
<div class="image">
<img src="boolean_image095.png" alt="boolean_image095.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image096.png" alt="boolean_image096.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_10"></a>
Case 10: An Edge and a Solid that have a common block</h3>
<p>Let us consider edge <em>E1</em> and solid <em>Z2</em>, that have a common block at a face:</p>
<div class="image">
<img src="boolean_image097.png" alt="boolean_image097.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image098.png" alt="boolean_image098.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_11"></a>
Case 11: Two intersecting faces</h3>
<p>Let us consider two intersecting faces <em>F1</em> and <em>F2</em>:</p>
<div class="image">
<img src="boolean_image099.png" alt="boolean_image099.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image100.png" alt="boolean_image100.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_12"></a>
Case 12: Two faces that have a common part</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common part:</p>
<div class="image">
<img src="boolean_image133.png" alt="boolean_image133.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains 4 new edges.</p>
<div class="image">
<img src="boolean_image134.png" alt="boolean_image134.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_13"></a>
Case 13: Two faces that have overlapping edges</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a overlapping edges:</p>
<div class="image">
<img src="boolean_image101.png" alt="boolean_image101.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image102.png" alt="boolean_image102.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_14"></a>
Case 14: Two faces that have overlapping vertices</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image103.png" alt="boolean_image103.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image104.png" alt="boolean_image104.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_15"></a>
Case 15: A Face and a Solid that have an intersection curve</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have an intersection curve:</p>
<div class="image">
<img src="boolean_image105.png" alt="boolean_image105.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains new edges.</p>
<div class="image">
<img src="boolean_image106.png" alt="boolean_image106.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_16"></a>
Case 16: A Face and a Solid that have overlapping faces.</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have overlapping faces:</p>
<div class="image">
<img src="boolean_image107.png" alt="boolean_image107.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains new edges</p>
<div class="image">
<img src="boolean_image108.png" alt="boolean_image108.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_17"></a>
Case 17: A Face and a Solid that have overlapping edges.</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have a common part on edge:</p>
<div class="image">
<img src="boolean_image109.png" alt="boolean_image109.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image110.png" alt="boolean_image110.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_18"></a>
Case 18: A Face and a Solid that have overlapping vertices.</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image111.png" alt="boolean_image111.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image112.png" alt="boolean_image112.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_19"></a>
Case 19: Two intersecting Solids</h3>
<p>Let us consider two intersecting solids <em>Z1</em> and <em>Z2</em>: </p><div class="image">
<img src="boolean_image113.png" alt="boolean_image113.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains new edges. </p><div class="image">
<img src="boolean_image114.png" alt="boolean_image114.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_20"></a>
Case 20: Two Solids that have overlapping faces</h3>
<p>Let us consider two solids <em>Z1</em> and <em>Z2</em> that have a common part on face: </p><div class="image">
<img src="boolean_image115.png" alt="boolean_image115.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains new edges. </p><div class="image">
<img src="boolean_image116.png" alt="boolean_image116.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_21"></a>
Case 21: Two Solids that have overlapping edges</h3>
<p>Let us consider two solids <em>Z1</em> and <em>Z2</em> that have overlapping edges: </p><div class="image">
<img src="boolean_image117.png" alt="boolean_image117.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>. </p><div class="image">
<img src="boolean_image118.png" alt="boolean_image118.png"/>
</div>
 <h3><a class="anchor" id="occt_algorithms_10a_3_22"></a>
Case 22: Two Solids that have overlapping vertices</h3>
<p>Let us consider two solids <em>Z1</em> and <em>Z2</em> that have overlapping vertices: </p><div class="image">
<img src="boolean_image119.png" alt="boolean_image119.png"/>
</div>
<p> The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>. </p><div class="image">
<img src="boolean_image120.png" alt="boolean_image120.png"/>
</div>
 <h2><a class="anchor" id="occt_algorithms_10a_4"></a>
Class BOPAlgo_Section</h2>
<p>SA is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a></em>. The class has no specific fields. The main steps of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a></em> are the same as of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> except for the following steps:</p>
<ul>
<li>Build Images for Wires;</li>
<li>Build Result of Type Wire;</li>
<li>Build Images for Faces;</li>
<li>Build Result of Type Face;</li>
<li>Build Images for Shells;</li>
<li>Build Result of Type Shell;</li>
<li>Build Images for Solids;</li>
<li>Build Result of Type Solid;</li>
<li>Build Images for Type CompSolid;</li>
<li>Build Result of Type CompSolid;</li>
<li>Build Images for Compounds; Some aspects of building the result are described in the next paragraph</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_10a_5"></a>
Building the Result</h2>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Build the result of the operation using all information contained in <em>FaceInfo</em>, Common Block, Shared entities of the arguments, etc. </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a>:: BuildSection()</em> </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_10b"></a>
Volume Maker Algorithm</h1>
<p>The Volume Maker algorithm has been designed for building the elementary volumes (solids) from a set of connected, intersecting, or nested shapes. The algorithm can also be useful for splitting solids into parts, or constructing new solid(s) from set of intersecting or connected faces or shells. The algorithm creates only closed solids. In general case the result solids are non-manifold: fragments of the input shapes (wires, faces) located inside the solids are added as internal sub-shapes to these solids. But the algorithm allows preventing the addition of the internal for solids parts into result. In this case the result solids will be manifold and not contain any internal parts. However, this option does not prevent from the occurrence of the internal edges or vertices in the faces.<br />
 Non-closed faces, free wires etc. located outside of any solid are always excluded from the result.</p>
<p>The Volume Maker algorithm is implemented in the class <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___maker_volume.html">BOPAlgo_MakerVolume</a>. It is based on the General Fuse (GF) algorithm. All the options of the GF algorithm (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_3a">GF Options</a>) are also available in this algorithm.</p>
<p>The requirements for the arguments are the same as for the arguments of GF algorithm - they could be of any type, but each argument should be valid and not self-interfered.</p>
<p>The algorithm allows disabling the calculation of intersections among the arguments. In this case the algorithm will run much faster, but the user should guarantee that the arguments do not interfere with each other, otherwise the result will be invalid (e.g. contain unexpected parts) or empty. This option is useful e.g. for building a solid from the faces of one shell or from the shapes that have already been intersected.</p>
<h2><a class="anchor" id="occt_algorithms_10b_1"></a>
Usage</h2>
<h4>C++ Level</h4>
<p>The usage of the algorithm on the API level: </p><div class="fragment"><div class="line">BOPAlgo_MakerVolume aMV;</div><div class="line">// Set the arguments</div><div class="line">TopTools_ListOfShape aLS = …; // arguments</div><div class="line">aMV.SetArguments(aLS);</div><div class="line"></div><div class="line">// Set options for the algorithm</div><div class="line">// setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">// Additional option of the algorithm</div><div class="line">Standard_Boolean bAvoidInternalShapes = Standard_False; // Set to True to exclude from the result any shapes internal to the solids</div><div class="line">aMV.SetAvoidInternalShapes(bAvoidInternalShapes);</div><div class="line"></div><div class="line">// Perform the operation</div><div class="line">aMV.Perform();</div><div class="line">if (aMV.HasErrors()) { //check error status</div><div class="line">  return;</div><div class="line">}</div><div class="line">//</div><div class="line">const TopoDS_Shape&amp; aResult = aMV.Shape(); // result of the operation</div></div><!-- fragment --><h4>Tcl Level</h4>
<p>To use the algorithm in <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> the command mkvolume has been implemented. The usage of this command is following: </p><div class="fragment"><div class="line">Usage: mkvolume r b1 b2 ... [-c] [-ni] [-ai]</div><div class="line">Options:</div><div class="line">-c - use this option to have input compounds considered as set of separate arguments (allows passing multiple arguments as one compound);</div><div class="line">-ni - use this option to disable the intersection of the arguments;</div><div class="line">-ai - use this option to avoid internal for solids shapes in the result.</div></div><!-- fragment --><h2><a class="anchor" id="occt_algorithms_10b_2"></a>
Examples</h2>
<h4>Example 1</h4>
<p>Creation of 9832 solids from sphere and set of 63 planes:</p>
<table align="center">
<tr>
<td><div class="image">
<img src="mkvolume_image001.png" alt="mkvolume_image001.png"/>
<div class="caption">
Arguments</div></div>
 </td><td><div class="image">
<img src="mkvolume_image002.png" alt="mkvolume_image002.png"/>
<div class="caption">
Results</div></div>
  </td></tr>
</table>
<h4>Example 2</h4>
<p>Creating compartments on a ship defined by hull shell and a set of planes. The ship is divided on compartments by five transverse bulkheads and a deck – six compartments are created:</p>
<table align="center">
<tr>
<td><div class="image">
<img src="mkvolume_image003.png" alt="mkvolume_image003.png"/>
<div class="caption">
Arguments</div></div>
 </td><td><div class="image">
<img src="mkvolume_image004.png" alt="mkvolume_image004.png"/>
<div class="caption">
Results</div></div>
  </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_10c_Cells"></a>
Cells Builder algorithm</h1>
<p>The Cells Builder algorithm is an extension of the General Fuse algorithm. The result of General Fuse algorithm contains all split parts of the arguments. The Cells Builder algorithm provides means to specify if any given split part of the arguments (referred to as Cell) can be taken or avoided in the result.</p>
<p>The possibility of selecting any Cell allows combining any possible result and gives the Cells Builder algorithm a very wide sphere of application - from building the result of any Boolean operation to building the result of any application-specific operation.</p>
<p>The algorithm builds Cells only once and then just reuses them for combining the result. This gives this algorithm the performance advantage over Boolean operations, which always rebuild the splits to obtain the desirable result.</p>
<p>Thus, the Cells Builder algorithm can be especially useful for simulating Boolean expressions, i.e. a sequence of Boolean operations on the same arguments. Instead of performing many Boolean operations it allows getting the final result in a single operation. The Cells Builder will also be beneficial to obtain the results of different Boolean operations on the same arguments - Cut and Common, for example.</p>
<p>The Cells Builder algorithm also provides the possibility to remove any internal boundaries between splits of the same type, i.e. to fuse any same-dimensional parts added into the result and to keep any other parts as separate. This possibility is implemented through the Cells material approach: to remove the boundary between two Cells, both Cells should be assigned with the same material ID. However, if the same material ID has been assigned to the Cells of different dimension, the removal of the internal boundaries for that material will not be performed. Currently, such case is considered a limitation for the algorithm.</p>
<p>The algorithm can also create containers from the connected Cells added into result - WIRES from Edges, SHELLS from Faces and COMPSOLIDS from Solids.</p>
<h2><a class="anchor" id="occt_algorithms_10c_Cells_1"></a>
Usage</h2>
<p>The algorithm has been implemented in the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___cells_builder.html">BOPAlgo_CellsBuilder</a></em> class.</p>
<p>Cells Builder is based on the General Fuse algorithm. Thus all options of the General Fuse algorithm (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_3a">GF Options</a>) are also available in this algorithm.</p>
<p>The requirements for the input shapes are the same as for General Fuse - each argument should be valid in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___argument_analyzer.html">BOPAlgo_ArgumentAnalyzer</a></em>.</p>
<p>The result of the algorithm is a compound containing the selected parts of the basic type (VERTEX, EDGE, FACE or SOLID). The default result is an empty compound. It is possible to add any Cell by using the methods <em>AddToRessult()</em> and <em>AddAllToResult()</em>. It is also possible to remove any part from the result by using methods <em>RemoveFromResult()</em> and <em>RemoveAllFromResult()</em>. The method <em>RemoveAllFromResult()</em> is also suitable for clearing the result.</p>
<p>The Cells that should be added/removed to/from the result are defined through the input shapes containing the parts that should be taken *(ShapesToTake)* and the ones containing parts that should be avoided (ShapesToAvoid). To be taken into the result the part must be IN all shapes from <em>ShapesToTake</em> and OUT of all shapes from <em>ShapesToAvoid</em>.</p>
<p>To remove Internal boundaries, it is necessary to set the same material to the Cells, between which the boundaries should be removed, and call the method <em>RemoveInternalBoundaries()</em>. The material should not be equal to 0, as this is the default material ID. The boundaries between Cells with this material ID will not be removed. The same Cell cannot be added with different materials. It is also possible to remove the boundaries when the result is combined. To do this, it is necessary to set the material for parts (not equal to 0) and set the flag <em>bUpdate</em> to TRUE. If the same material ID has been set for parts of different dimension, the removal of internal boundaries for this material will not be performed.</p>
<p>It is possible to create typed Containers from the parts added into result by using method <em>MakeContainers()</em>. The type of the containers will depend on the type of the input shapes: WIRES for EDGE, SHELLS for FACES and COMPSOLIDS for SOLIDS. The result will be a compound containing containers.</p>
<h4>API usage</h4>
<p>Here is the example of the algorithm use on the API level: </p><div class="fragment"><div class="line">BOPAlgo_CellsBuilder aCBuilder;</div><div class="line">// Set the arguments</div><div class="line">TopTools_ListOfShape aLS = …; // arguments</div><div class="line">aCBuilder.SetArguments(aLS);</div><div class="line"></div><div class="line">// Set options for the algorithm</div><div class="line">// setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line"></div><div class="line">aCBuilder.Perform(); // build splits of all arguments (GF)</div><div class="line">if (aCBuilder.HasErrors()) { // check error status</div><div class="line">  return;</div><div class="line">}</div><div class="line">//</div><div class="line">// collecting of the cells into result</div><div class="line">const TopoDS_Shape&amp; anEmptyRes = aCBuilder.Shape(); // empty result, as nothing has been added yet </div><div class="line">const TopoDS_Shape&amp; anAllCells = aCBuilder.GetAllParts(); //all split parts </div><div class="line">//</div><div class="line">TopTools_ListOfShape aLSToTake = ...; // parts of these arguments will be taken into result</div><div class="line">TopTools_ListOfShape aLSToAvoid = ...; // parts of these arguments will not be taken into result</div><div class="line">//</div><div class="line">Standard_Integer iMaterial = 1; // defines the material for the cells</div><div class="line">Standard_Boolean bUpdate = Standard_False; // defines whether to update the result right now or not</div><div class="line">// adding to result</div><div class="line">aCBuilder.AddToResult(aLSToTake, aLSToAvoid, iMaterial, bUpdate);</div><div class="line">aCBuilder.RemoveInternalBoundaries(); // removing of the boundaries</div><div class="line">TopoDS_Shape aResult = aCBuilder.Shape(); // the result</div><div class="line">// removing from result</div><div class="line">aCBuilder.AddAllToResult();</div><div class="line">aCBuilder.RemoveFromResult(aLSToTake, aLSToAvoid);</div><div class="line">aResult = aCBuilder.Shape(); // the result</div></div><!-- fragment --><h4>DRAW usage</h4>
<p>The following set of new commands has been implemented to run the algorithm in DRAW Test Harness: </p><div class="fragment"><div class="line">bcbuild          : Initialization of the Cells Builder. Use: *bcbuild r*</div><div class="line">bcadd            : Add parts to result. Use: *bcadd r s1 (0,1) s2 (0,1) ... [-m material [-u]]*</div><div class="line">bcaddall         : Add all parts to result. Use: *bcaddall r [-m material [-u]]*</div><div class="line">bcremove         : Remove parts from result. Use: *bcremove r s1 (0,1) s2 (0,1) ...*</div><div class="line">bcremoveall      : Remove all parts from result. Use: *bcremoveall*</div><div class="line">bcremoveint      : Remove internal boundaries. Use: *bcremoveint r*</div><div class="line">bcmakecontainers : Make containers from the parts added to result. Use: *bcmakecontainers r*</div></div><!-- fragment --><p>Here is the example of the algorithm use on the DRAW level: </p><div class="fragment"><div class="line">psphere s1 15</div><div class="line">psphere s2 15</div><div class="line">psphere s3 15</div><div class="line">ttranslate s1 0 0 10</div><div class="line">ttranslate s2 20 0 10</div><div class="line">ttranslate s3 10 0 0 </div><div class="line">bclearobjects; bcleartools</div><div class="line">baddobjects s1 s2 s3</div><div class="line">bfillds</div><div class="line"># rx will contain all split parts</div><div class="line">bcbuild rx </div><div class="line"># add to result the part that is common for all three spheres</div><div class="line">bcadd res s1 1 s2 1 s3 1 -m 1</div><div class="line"># add to result the part that is common only for first and third spheres</div><div class="line">bcadd res s1 1 s2 0 s3 1 -m 1</div><div class="line"># remove internal boundaries</div><div class="line">bcremoveint res</div></div><!-- fragment --><h2><a class="anchor" id="occt_algorithms_10c_Cells_2"></a>
Examples</h2>
<p>The following simple example illustrates the possibilities of the algorithm working on a cylinder and a sphere intersected by a plane: </p><div class="fragment"><div class="line">pcylinder c 10 30 </div><div class="line">psphere s 15</div><div class="line">ttranslate s 0 0 30</div><div class="line">plane p 0 0 20 1 0 0</div><div class="line">mkface f p -25 30 -17 17</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_001.png" alt="cells_algorithm_001.png"/>
<div class="caption">
Arguments</div></div>
<div class="fragment"><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line">baddobjects c s f</div><div class="line">bfillds</div><div class="line">bcbuild r</div></div><!-- fragment --><h4>1. Common for all arguments</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res c 1 s 1 f 1</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_002.png" alt="cells_algorithm_002.png"/>
<div class="caption">
The result of COMMON operation</div></div>
<h4>2. Common between cylinder and face</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res f 1 c 1</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_003.png" alt="cells_algorithm_003.png"/>
<div class="caption">
The result of COMMON operation between cylinder and face</div></div>
<h4>3. Common between cylinder and sphere</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res c 1 s 1</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_004.png" alt="cells_algorithm_004.png"/>
<div class="caption">
The result of COMMON operation between cylinder and sphere</div></div>
<h4>4. Fuse of cylinder and sphere</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res c 1 -m 1</div><div class="line">bcadd res s 1 -m 1</div><div class="line">bcremoveint res</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_005.png" alt="cells_algorithm_005.png"/>
<div class="caption">
The result of FUSE operation between cylinder and sphere</div></div>
<h4>5. Parts of the face inside solids - FUSE(COMMON(f, c), COMMON(f, s))</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res f 1 s 1 -m 1</div><div class="line">bcadd res f 1 c 1 -m 1</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_006_1.png" alt="cells_algorithm_006_1.png"/>
<div class="caption">
Parts of the face inside solids</div></div>
<div class="fragment"><div class="line">bcremoveint res</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_006_2.png" alt="cells_algorithm_006_2.png"/>
<div class="caption">
Unified parts of the face inside solids</div></div>
<h4>6. Part of the face outside solids</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res f 1 c 0 s 0</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_007.png" alt="cells_algorithm_007.png"/>
<div class="caption">
Part of the face outside solids</div></div>
<h4>7. Fuse operation (impossible using standard Boolean Fuse operation)</h4>
<div class="fragment"><div class="line">bcremoveall</div><div class="line">bcadd res c 1 -m 1</div><div class="line">bcadd res s 1 -m 1</div><div class="line">bcadd res f 1 c 0 s 0</div><div class="line">bcremoveint res</div></div><!-- fragment --><div class="image">
<img src="cells_algorithm_008.png" alt="cells_algorithm_008.png"/>
<div class="caption">
Fuse operation</div></div>
<p>These examples may last forever. To define any new operation, it is just necessary to define, which Cells should be taken and which should be avoided.</p>
<h1><a class="anchor" id="occt_algorithms_10"></a>
Algorithm Limitations</h1>
<p>The chapter describes the problems that are considered as Algorithm limitations. In most cases an Algorithm failure is caused by a combination of various factors, such as self-interfered arguments, inappropriate or ungrounded values of the argument tolerances, adverse mutual position of the arguments, tangency, etc.</p>
<p>A lot of failures of GFA algorithm can be caused by bugs in low-level algorithms: Intersection Algorithm, Projection Algorithm, Approximation Algorithm, Classification Algorithm, etc.</p><ul>
<li>The Intersection, Projection and Approximation Algorithms are mostly used at the Intersection step. Their bugs directly cause wrong section results (i.e. incorrect section edges, section points, missing section edges or micro edges). It is not possible to obtain a correct final result of the GFA if a section result is wrong.</li>
<li>The Projection Algorithm is used at the Intersection step. The purpose of Projection Algorithm is to compute 2D curves on surfaces. Wrong results here lead to incorrect or missing faces in the final GFA result.</li>
<li>The Classification Algorithm is used at the Building step. The bugs in the Classification Algorithm lead to errors in selecting shape parts (edges, faces, solids) and ultimately to a wrong final GFA result.</li>
</ul>
<p>The description below illustrates some known GFA limitations. It does not enumerate exhaustively all problems that can arise in practice. Please address cases of Algorithm failure to the OCCT Maintenance Service.</p>
<h2><a class="anchor" id="occt_algorithms_10_1"></a>
Arguments</h2>
<h3><a class="anchor" id="occt_algorithms_10_1_1"></a>
Common requirements</h3>
<p>Each argument should be valid (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>), or conversely, if the argument is considered as non-valid (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>), it cannot be used as an argument of the algorithm.</p>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> is used to check the overall validity of a shape. In OCCT a Shape (or its sub-shapes) is considered valid if it meets certain criteria. If the shape is found as invalid, it can be fixed by tools from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis.html">ShapeAnalysis</a>, <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade.html">ShapeUpgrade</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em> packages.</p>
<p>However, it is important to note that class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> is just a tool that can have its own problems; this means that due to a specific factor(s) this tool can sometimes provide a wrong result.</p>
<p>Let us consider the following example:</p>
<p>The Analyzer checks distances between couples of 3D check-points <em>(Pi, PSi)</em> of edge <em>E</em> on face <em>F</em>. Point <em>Pi</em> is obtained from the 3D curve (at the parameter <em>ti</em>) of the edge. <em>PSi</em> is obtained from 2D curve (at the parameter <em>ti</em>) of the edge on surface <em>S</em> of face <em>F</em>. To be valid the distance should be less than <em>Tol(E)</em> for all couples of check-points. The number of these check-points is a predefined value (e.g. 23).</p>
<p>Let us consider the case when edge <em>E</em> is recognized valid (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>).</p>
<p>Further, after some operation, edge <em>E</em> is split into two edges <em>E1</em> and <em>E2</em>. Each split edge has the same 3D curve and 2D curve as the original edge <em>E</em>.</p>
<p>Let us check <em>E1</em> (or E2). The Analyzer again checks the distances between the couples of check-points points <em>(Pi, PSi)</em>. The number of these check-points is the same constant value (23), but there is no guarantee that the distances will be less than <em>Tol(E)</em>, because the points chosen for <em>E1</em> are not the same as for <em>E</em>.</p>
<p>Thus, if <em>E1</em> is recognized by the Analyzer as non-valid, edge <em>E</em> should also be non-valid. However <em>E</em> has been recognized as valid. Thus the Analyzer gives a wrong result for <em>E</em>.</p>
<p>The fact that the argument is a valid shape (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>) is a necessary but insufficient requirement to produce a valid result of the Algorithms.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_3"></a>
Pure self-interference</h3>
<p>The argument should not be self-interfered, i.e. all sub-shapes of the argument that have geometrical coincidence through any topological entities (vertices, edges, faces) should share these entities.</p>
<h4>Example 1: Compound of two edges</h4>
<p>The compound of two edges <em>E1</em> and <em>E2</em> is a self-interfered shape and cannot be used as the argument of the Algorithms.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image036.svg">operations_image036.svg</object>
<div class="caption">
Compound of two edges</div></div>
 <h4>Example 2: Self-interfered Edge</h4>
<p>The edge <em>E</em> is a self-interfered shape and cannot be used as an argument of the Algorithms.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image037.svg">operations_image037.svg</object>
<div class="caption">
Self-interfered Edge</div></div>
 <h4>Example 3: Self-interfered Face</h4>
<p>The face <em>F</em> is a self-interfered shape and cannot be used as an argument of the Algorithms.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image038.svg">operations_image038.svg</object>
<div class="caption">
Self-interfered Face</div></div>
 <h4>Example 4: Face of Revolution</h4>
<p>The face <em>F</em> has been obtained by revolution of edge <em>E</em> around line <em>L</em>.</p>
<div class="image">
<img src="operations_image039a.png" alt="operations_image039a.png"/>
<div class="caption">
Face of Revolution: Arguments</div></div>
<div class="image">
<img src="operations_image039b.png" alt="operations_image039b.png"/>
<div class="caption">
Face of Revolution: Result</div></div>
<p> In spite of the fact that face <em>F</em> is valid (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>) it is a self-interfered shape and cannot be used as the argument of the Algorithms.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_4"></a>
Self-interferences due to tolerances</h3>
<h4>Example 1: Non-closed Edge</h4>
<p>Let us consider edge <em>E</em> based on a non-closed circle. </p><div class="image">
<img src="operations_image040.png" alt="operations_image040.png"/>
<div class="caption">
Edge based on a non-closed circle</div></div>
<p> The distance between the vertices of <em>E</em> is <em>D=0.69799</em>. The values of the tolerances <em>Tol(V1)=Tol(V2)=0.5</em>. </p><div class="image">
<img src="operations_image041.png" alt="operations_image041.png"/>
<div class="caption">
Distance and Tolerances</div></div>
<p> In spite of the fact that the edge <em>E</em> is valid in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>, it is a self-interfered shape because its vertices are interfered. Thus, edge <em>E</em> cannot be used as an argument of the Algorithms.</p>
<h4>Example 2: Solid containing an interfered vertex</h4>
<p>Let us consider solid <em>S</em> containing vertex V. </p><div class="image">
<img src="operations_image042.png" alt="operations_image042.png"/>
<div class="caption">
Solid containing an interfered vertex</div></div>
<p> The value of tolerance Tol(V)= 50.000075982061.</p>
<div class="image">
<img src="operations_image043.png" alt="operations_image043.png"/>
<div class="caption">
Tolerance</div></div>
<p> In spite of the fact that solid <em>S</em> is valid in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> it is a self-interfered shape because vertex <em>V</em> is interfered with a lot of sub-shapes from <em>S</em> without any topological connection with them. Thus solid <em>S</em> cannot be used as an argument of the Algorithms.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_5"></a>
Parametric representation</h3>
<p>The parameterization of some surfaces (cylinder, cone, surface of revolution) can be the cause of limitation.</p>
<h4>Example 1: Cylindrical surface</h4>
<p>The parameterization range for cylindrical surface is:</p>
<div class="image">
<img src="boolean_image135.png" alt="boolean_image135.png"/>
</div>
<p> The range of <em>U</em> coordinate is always restricted while the range of <em>V</em> coordinate is non-restricted.</p>
<p>Let us consider a cylinder-based <em>Face 1</em> with radii <em>R=3</em> and <em>H=6</em>.</p>
<div class="image">
<img src="operations_image044.png" alt="operations_image044.png"/>
<div class="caption">
Face 1</div></div>
 <div class="image">
<img src="operations_image045.png" alt="operations_image045.png"/>
<div class="caption">
P-Curves for Face 1</div></div>
<p> Let us also consider a cylinder-based <em>Face 2</em> with radii <em>R=3000</em> and <em>H=6000</em> (resulting from scaling Face 1 with scale factor <em>ScF=1000</em>).</p>
<div class="image">
<img src="operations_image046.png" alt="operations_image046.png"/>
<div class="caption">
Face 2</div></div>
 <div class="image">
<img src="operations_image047.png" alt="operations_image047.png"/>
<div class="caption">
P-Curves for Face 2</div></div>
<p> Pay attention to the Zoom value of the Figures.</p>
<p>It is obvious that starting with some value of <em>ScF</em>, e.g. <em>ScF&gt;1000000</em>, all sloped p-Curves on <em>Face 2</em> will be almost vertical. At least, there will be no difference between the values of angles computed by standard C Run-Time Library functions, such as <em>double acos(double x)</em>. The loss of accuracy in computation of angles can cause failure of some BP sub-algorithms, such as building faces from a set of edges or building solids from a set of faces.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_6"></a>
Using tolerances of vertices to fix gaps</h3>
<p>It is possible to create shapes that use sub-shapes of lower order to avoid gaps in the tolerance-based data model.</p>
<p>Let us consider the following example:</p>
<div class="image">
<img src="operations_image048.png" alt="operations_image048.png"/>
<div class="caption">
Example</div></div>
<ul>
<li>Face <em>F</em> has two edges <em>E1</em> and <em>E2</em> and two vertices, the base plane is <em>{0,0,0, 0,0,1}</em>;</li>
<li>Edge <em>E1</em> is based on line <em>{0,0,0, 1,0,0}, Tol(E1) = 1.e-7; </em></li>
<li>Edge <em>E2</em> is based on line <em>{0,1,0, 1,0,0}, Tol(E2) = 1.e-7;</em></li>
<li>Vertex <em>V1</em>, point <em>{0,0.5,0}, Tol(V1) = 1;</em></li>
<li>Vertex <em>V2</em>, point <em>{10,0.5,0}, Tol(V2) = 1;</em></li>
<li>Face <em>F</em> is valid (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>).</li>
</ul>
<p>The values of tolerances <em>Tol(V1)</em> and <em>Tol(V2)</em> are big enough to fix the gaps between the ends of the edges, but the vertices <em>V1</em> and <em>V2</em> do not contain any information about the trajectories connecting the corresponding ends of the edges. Thus, the trajectories are undefined. This will cause failure of some sub-algorithms of BP. For example, the sub-algorithms for building faces from a set of edges use the information about all edges connected in a vertex. The situation when a vertex has several pairs of edges such as above will not be solved in a right way.</p>
<h2><a class="anchor" id="occt_algorithms_11_1"></a>
Intersection problems</h2>
<h3><a class="anchor" id="occt_algorithms_11_1_1"></a>
Pure intersections and common zones</h3>
<h4>Example: Intersecting Edges</h4>
<p>Let us consider the intersection between two edges:</p><ul>
<li><em>E1</em> is based on a line: <em>{0,-10,0, 1,0,0}, Tol(E1)=2.</em></li>
<li><em>E2</em> is based on a circle: <em>{0,0,0, 0,0,1}, R=10, Tol(E2)=2.</em></li>
</ul>
<div class="image">
<img src="operations_image049.png" alt="operations_image049.png"/>
<div class="caption">
Intersecting Edges</div></div>
<p> The result of pure intersection between <em>E1</em> and <em>E2</em> is vertex <em>Vx {0,-10,0}</em>.</p>
<p>The result of intersection taking into account tolerances is the common zone <em>CZ</em> (part of 3D-space where the distance between the curves is less than or equals to the sum of edge tolerances.</p>
<p>The Intersection Part of Algorithms uses the result of pure intersection <em>Vx</em> instead of <em>CZ</em> for the following reasons:</p><ul>
<li>The Algorithms do not produce Common Blocks between edges based on underlying curves of explicitly different type (e.g. Line / Circle). If the curves have different types, the rule of thumb is that the produced result is of type <b>vertex</b>. This rule does not work for non-analytic curves (Bezier, B-Spline) and their combinations with analytic curves.</li>
<li>The algorithm of intersection between two surfaces <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_patch___intersection.html">IntPatch_Intersection</a></em> does not compute <em>CZ</em> of the intersection between curves and points. So even if <em>CZ</em> were computed by Edge/Edge intersection algorithm, its result could not be treated by Face/Face intersection algorithm.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_11_2_2"></a>
Tolerances and inaccuracies</h3>
<p>The following limitations result from modeling errors or inaccuracies.</p>
<h4>Example: Intersection of planar faces</h4>
<p>Let us consider two planar rectangular faces <em>F1</em> and <em>F2</em>.</p>
<p>The intersection curve between the planes is curve <em>C12</em>. The curve produces a new intersection edge <em>EC12</em>. The edge goes through vertices <em>V1</em> and <em>V2</em> thanks to big tolerance values of vertices <em>Tol(V1)</em> and <em>Tol(V2)</em>. So, two straight edges <em>E12</em> and <em>EC12</em> go through two vertices, which is impossible in this case.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image050.svg">operations_image050.svg</object>
<div class="caption">
Intersecting Faces</div></div>
<p>The problem cannot be solved in general, because the length of <em>E12</em> can be infinite and the values of <em>Tol(V1)</em> and <em>Tol(V2)</em> theoretically can be infinite too.</p>
<p>In a particular case the problem can be solved in several ways:</p><ul>
<li>Reduce, if possible, the values of <em>Tol(V1)</em> and <em>Tol(V2)</em> (refinement of <em>F1</em>).</li>
<li>Analyze the value of <em>Tol(EC12)</em> and increase <em>Tol(EC12)</em> to get a common part between the edges <em>EC12</em> and <em>E12</em>. Then the common part will be rejected as there is an already existing edge <em>E12</em> for face <em>F1</em>.</li>
</ul>
<p>It is easy to see that if <em>C12</em> is slightly above the tolerance spheres of <em>V1</em> and <em>V2</em> the problem does not appear.</p>
<h4>Example: Intersection of two edges</h4>
<p>Let us consider two edges <em>E1</em> and <em>E2</em>, which have common vertices <em>V1</em> and <em>V2</em>. The edges <em>E1</em> and <em>E2</em> have 3D-curves <em>C1</em> and <em>C2. Tol(E1)=1.e<sup>-7</sup>, Tol(E2)=1.e<sup>-7</sup>.</em></p>
<p><em>C1</em> practically coincides in 3D with <em>C2</em>. The value of deflection is <em>Dmax</em> (e.g. <em>Dmax=1.e<sup>-6</sup></em>).</p>
<div class="image">
<object type="image/svg+xml" data="operations_image051.svg">operations_image051.svg</object>
<div class="caption">
Intersecting Edges</div></div>
<p> The evident and prospective result should be the Common Block between <em>E1</em> and <em>E2</em>. However, the result of intersection differs.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image052.svg">operations_image052.svg</object>
<div class="caption">
Result of Intersection</div></div>
<p> The result contains three new vertices <em>Vx1, Vx2</em> and <em>Vx3</em>, 8 new edges <em>(V1, Vx1, Vx2, Vx3, V2)</em> and no Common Blocks. This is correct due to the source data: <em>Tol(E1)=1.e<sup>-7</sup>, Tol(E2)=1.e<sup>-7</sup></em> and <em>Dmax=1.e<sup>-6</sup></em>.</p>
<p>In this particular case the problem can be solved by several ways:</p><ul>
<li>Increase, if possible, the values <em>Tol(E1)</em> and <em>Tol(E2)</em> to get coincidence in 3D between <em>E1</em> and <em>E2</em> in terms of tolerance.</li>
<li>Replace <em>E1</em> by a more accurate model.</li>
</ul>
<p>The example can be extended from 1D (edges) to 2D (faces).</p>
<div class="image">
<object type="image/svg+xml" data="operations_image053.svg">operations_image053.svg</object>
<div class="caption">
Intersecting Faces</div></div>
<p> The comments and recommendations are the same as for 1D case above.</p>
<h3><a class="anchor" id="occt_algorithms_11_2_3"></a>
Acquired Self-interferences</h3>
<h4>Example 1: Vertex and edge</h4>
<p>Let us consider vertex <em>V1</em> and edge <em>E2</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image054.svg">operations_image054.svg</object>
<div class="caption">
Vertex and Edge</div></div>
<p> Vertex <em>V1</em> interferes with vertices <em>V12</em> and <em>V22</em>. So vertex <em>V21</em> should interfere with vertex <em>V22</em>, which is impossible because vertices <em>V21</em> and <em>V22</em> are the vertices of edge <em>E2</em>, thus <em>V21</em> is not equal to <em>V22</em>.</p>
<p>The problem cannot be solved in general, because the length can be as small as possible to provide validity of <em>E2</em> (in the extreme case: <em>Length (E2) = Tol(V21) + Tol(V22) + e,</em> where <em>e-&gt; 0</em>).</p>
<p>In a particular case the problem can be solved by refinement of arguments, i.e. by decreasing the values of <em>Tol(V21)</em>, <em>Tol(V22)</em> and <em>Tol(V1)</em>.</p>
<h4>Example 2: Vertex and wire</h4>
<p>Let us consider vertex <em>V2</em> and wire consisting of edges <em>E11</em> and <em>E12</em>.</p>
<div class="image">
<object type="image/svg+xml" data="operations_image055.svg">operations_image055.svg</object>
<div class="caption">
Vertex and Wire</div></div>
<p> The arguments themselves are not self-intersected. Vertex <em>V2</em> interferes with edges <em>E11</em> and <em>E12</em>. Thus, edge <em>E11</em> should interfere with edge <em>E22</em>, but it is impossible because edges <em>E11</em> and <em>E12</em> cannot interfere by the condition.</p>
<p>The cases when a non-self-interfered argument (or its sub-shapes) become interfered due to the intersections with other arguments (or their sub-shapes) are considered as limitations for the Algorithms.</p>
<h1><a class="anchor" id="occt_algorithms_11a"></a>
Advanced Options</h1>
<p>The previous chapters describe so called Basic Operations. Most of tasks can be solved using Basic Operations. Nonetheless, there are cases that can not be solved straightforwardly by Basic Operations. The tasks are considered as limitations of Basic Operations.</p>
<p>The chapter is devoted to Advanced Options. In some cases the usage of Advanced Options allows overcoming the limitations, improving the quality of the result of operations, robustness and performance of the operators themselves.</p>
<h2><a class="anchor" id="occt_algorithms_11a_1"></a>
Fuzzy Boolean Operation</h2>
<p>Fuzzy Boolean operation is the option of Basic Operations such as General Fuse, Splitting, Boolean, Section, Maker Volume and Cells building operations, in which additional user-specified tolerance is used. This option allows operators to handle robustly cases of touching and near-coincident, misaligned entities of the arguments.</p>
<p>The Fuzzy option is useful on the shapes with gaps or embeddings between the entities of these shapes, which are not covered by the tolerance values of these entities. Such shapes can be the result of modeling mistakes, or translating process, or import from other systems with loss of precision, or errors in some algorithms.</p>
<p>Most likely, the Basic Operations will give unsatisfactory results on such models. The result may contain unexpected and unwanted small entities, faulty entities (in terms of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>), or there can be no result at all.</p>
<p>With the Fuzzy option it is possible to get the expected result &ndash; it is just necessary to define the appropriate value of fuzzy tolerance for the operation. To define that value it is necessary to measure the value of the gap (or the value of embedding depth) between the entities of the models, slightly increase it (to make the shifted entities coincident in terms of their tolerance plus the additional one) and pass it to the algorithm.</p>
<p>Fuzzy option is included in interface of Intersection Part (class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>) and application programming interface (class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em>)</p>
<h3><a class="anchor" id="occt_algorithms_11a_1_1"></a>
Examples</h3>
<p>The following examples demonstrate the advantages of usage Fuzzy option operations over the Basic Operations in typical situations.</p>
<h4>Case 1</h4>
<p>In this example the cylinder (shown in yellow and transparent) is subtracted from the box (shown in red). The cylinder is shifted by 5e<sup>-5</sup> relatively to the box along its axis (the distance between rear faces of the box and cylinder is 5e<sup>-5</sup>).</p>
<div class="image">
<img src="boolean_image121.png" alt="boolean_image121.png"/>
</div>
<p> The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 5e<sup>-5</sup>:</p>
<div class="image">
<img src="boolean_image122.png" alt="boolean_image122.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
 <div class="image">
<img src="boolean_image123.png" alt="boolean_image123.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p> In this example Fuzzy option allows eliminating a very thin part of the result shape produced by Basic algorithm due to misalignment of rear faces of the box and the cylinder.</p>
<h4>Case 2</h4>
<p>In this example two boxes are fused. One of them has dimensions 10*10*10, and the other is 10*10.000001*10.000001 and adjacent to the first one. There is no gap in this case as the surfaces of the neighboring faces coincide, but one box is slightly greater than the other.</p>
<div class="image">
<img src="boolean_image124.png" alt="boolean_image124.png"/>
</div>
<p> The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 1e<sup>-6</sup>:</p>
<div class="image">
<img src="boolean_image125.png" alt="boolean_image125.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
 <div class="image">
<img src="boolean_image126.png" alt="boolean_image126.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p> In this example Fuzzy option allows eliminating an extremely narrow face in the result produced by Basic operation.</p>
<h4>Case 3</h4>
<p>In this example the small planar face (shown in orange) is subtracted from the big one (shown in yellow). There is a gap 1e<sup>-5</sup> between the edges of these faces.</p>
<div class="image">
<img src="boolean_image127.png" alt="boolean_image127.png"/>
</div>
<p> The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 1e<sup>-5</sup>:</p>
<div class="image">
<img src="boolean_image128.png" alt="boolean_image128.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
 <div class="image">
<img src="boolean_image129.png" alt="boolean_image129.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p> In this example Fuzzy options eliminated a pin-like protrusion resulting from the gap between edges of the argument faces.</p>
<h4>Case 4</h4>
<p>In this example the small edge is subtracted from the big one. The edges are overlapping not precisely, with max deviation between them equal to 5.28004e<sup>-5</sup>. We will use 6e<sup>-5</sup> value for Fuzzy option.</p>
<div class="image">
<img src="boolean_image130.png" alt="boolean_image130.png"/>
</div>
<p> The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 6e<sup>-5</sup>:</p>
<div class="image">
<img src="boolean_image131.png" alt="boolean_image131.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
 <div class="image">
<img src="boolean_image132.png" alt="boolean_image132.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p> This example stresses not only the validity, but also the performance issue. The usage of Fuzzy option with the appropriate value allows processing the case much faster than with the pure Basic operation. The performance gain for the case is 45 (Processor: Intel(R) Core(TM) i5-3450 CPU @ 3.10 GHz).</p>
<h2><a class="anchor" id="occt_algorithms_11a_2"></a>
Gluing Operation</h2>
<p>The Gluing operation is the option of the Basic Operations such as General Fuse, Splitting, Boolean, Section, Maker Volume and Cells building operations. It has been designed to speed up the computation of the interferences among arguments of the operations on special cases, in which the arguments may be overlapping but do not have real intersections between their sub-shapes.</p>
<p>This option cannot be used on the shapes having real intersections, like intersection vertex between edges, or intersection vertex between edge and a face or intersection line between faces:</p>
<div class="image">
<img src="glue_options_image002.png" alt="glue_options_image002.png"/>
<div class="caption">
Intersecting faces</div></div>
<p> There are two possibilities of overlapping shapes:</p><ul>
<li>The shapes can be partially coinciding - the faces do not have intersection curves, but overlapping. The faces of such arguments will be split during the operation. The following picture illustrates such shapes:</li>
</ul>
<div class="image">
<img src="glue_options_image001.png" alt="glue_options_image001.png"/>
<div class="caption">
Partially coinciding faces</div></div>
<ul>
<li>The shapes can be fully coinciding - there should be no partial overlapping of the faces, thus no intersection of type EDGE/FACE at all. In such cases the faces will not be split during the operation.</li>
</ul>
<div class="image">
<img src="glue_options_image003.png" alt="glue_options_image003.png"/>
<div class="caption">
Full coinciding faces of the boxes</div></div>
<p> Thus, there are two possible options - for full and partial coincidence of the shapes.</p>
<p>Even though there are no real intersections on such cases without Gluing options the algorithm will still intersect the sub-shapes of the arguments with interfering bounding boxes.</p>
<p>The performance improvement in gluing mode is achieved by excluding the most time consuming computations and in some case can go up to 90%:</p><ul>
<li>Exclude computation of FACE/FACE intersections for partial coincidence;</li>
<li>Exclude computation of VERTEX/FACE, EDGE/FACE and FACE/FACE intersections for full coincidence.</li>
</ul>
<p>By setting the Gluing option for the operation user should guarantee that the arguments are really coinciding. The algorithm does not check this itself. Setting inappropriate option for the operation is likely to lead to incorrect result.</p>
<h3><a class="anchor" id="occt_algorithms_11a_2_1"></a>
Usage</h3>
<p>The Gluing option is an enumeration implemented in <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_b_o_p_algo___glue_enum_8hxx.html">BOPAlgo_GlueEnum.hxx</a>:</p><ul>
<li>BOPAlgo_GlueOff - default value for the algorithms, Gluing is switched off;</li>
<li>BOPAlgo_GlueShift - Glue option for shapes with partial coincidence;</li>
<li>BOPAlgo_GlueFull - Glue option for shapes with full coincidence.</li>
</ul>
<h4>API level</h4>
<p>For setting the Gluing options for the algorithm it is just necessary to call the SetGlue(const BOPAlgo_Glue) method with appropriate value: </p><div class="fragment"><div class="line">BOPAlgo_Builder aGF;</div><div class="line">//</div><div class="line">....</div><div class="line">// setting the gluing option to speed up intersection of the arguments</div><div class="line">aGF.SetGlue(BOPAlgo_GlueShift)</div><div class="line">//</div><div class="line">....</div></div><!-- fragment --><h4>TCL level</h4>
<p>For setting the Gluing options in DRAW it is necessary to call the <em>bglue</em> command with appropriate value:</p><ul>
<li>0 - default value, Gluing is off;</li>
<li>1 - for partial coincidence;</li>
<li>2 - for full coincidence</li>
</ul>
<div class="fragment"><div class="line">bglue 1</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11a_2_2"></a>
Examples</h3>
<h4>Case1 - Fusing the 64 bspline boxes into one solid</h4>
<div class="image">
<img src="glue_options_image004.png" alt="glue_options_image004.png"/>
<div class="caption">
BSpline Boxes with partial coincidence</div></div>
<p> Performance improvement from using the GlueShift option in this case is about 70 percent.</p>
<h4>Case2 - Sewing faces of the shape after reading from IGES</h4>
<div class="image">
<img src="glue_options_image005.png" alt="glue_options_image005.png"/>
<div class="caption">
Faces with coinciding but not shared edges</div></div>
<p> Performance improvement in this case is also about 70 percent.</p>
<h2><a class="anchor" id="occt_algorithms_11a_3"></a>
Safe processing mode</h2>
<p>The safe processing mode is the advanced option in Boolean Operation component. This mode can be applied to all Basic operations such as General Fuse, Splitting, Boolean, Section, Maker Volume, Cells building. This option allows keeping the input arguments untouched. In other words, switching this option on prevents the input arguments from any modification such as tolerance increase, addition of the P-Curves on edges, etc.</p>
<p>The option can be very useful for implementation of the Undo/Redo mechanism in the applications and allows performing the operation many times without changing the inputs.</p>
<p>By default the safe processing option is switched off for the algorithms. Enabling this option might slightly decrease the performance of the operation, because instead of the modification of some entity it will be necessary to create the copy of this entity and modify it. However, this degradation should be very small because the copying is performed only in case of necessity.</p>
<p>The option is also available in the Intersection algorithm - <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>. To perform several different operations on the same arguments, the safe processing mode can be enabled in PaveFiller, prepared only once and then used in operations. It is enough to set this option to PaveFiller only and all algorithms taking this PaveFiller will also work in the safe mode.</p>
<h3><a class="anchor" id="occt_algorithms_11a_3_1"></a>
Usage</h3>
<h4>API level</h4>
<p>To enable/disable the safe processing mode for the algorithm, it is necessary to call <em>SetNonDestructive()</em> method with the appropriate value: </p><div class="fragment"><div class="line">BOPAlgo_Builder aGF;</div><div class="line">//</div><div class="line">....</div><div class="line">// enabling the safe processing mode to prevent modification of the input shapes</div><div class="line">aGF.SetNonDestructive(Standard_True);</div><div class="line">//</div><div class="line">....</div></div><!-- fragment --><h4>TCL level</h4>
<p>To enable the safe processing mode for the operation in DRAW, it is necessary to call the <em>bnondestructive</em> command with the appropriate value:</p><ul>
<li>0 - default value, the safe mode is switched off;</li>
<li>1 - the safe mode will be switched on.</li>
</ul>
<div class="fragment"><div class="line">bnondestructive 1</div></div><!-- fragment --><h2><a class="anchor" id="occt_algorithms_11a_4"></a>
How to disable check of input solids for inverted status</h2>
<p>By default, all input solids are checked for inverted status, i.e. the solids are classified to understand if they are holes in the space (negative volumes) or normal solids (positive volumes). The possibility to disable the check of the input solids for inverted status is the advanced option in Boolean Operation component. This option can be applied to all Basic operations, such as General Fuse, Splitting, Boolean, Section, Maker Volume and Cells building. This option allows avoiding time-consuming classification of the input solids and processing them in the same way as positive volumes, saving up to 10 percent of time on the cases with a big number of input solids.</p>
<p>The classification should be disabled only if the user is sure that there are no negative volumes among the input solids, otherwise the result may be invalid.</p>
<h3><a class="anchor" id="occt_algorithms_11a_4_1"></a>
Usage</h3>
<h4>API level</h4>
<p>To enable/disable the classification of the input solids it is necessary to call <em>SetCheckInverted()</em> method with the appropriate value: </p><div class="fragment"><div class="line">BOPAlgo_Builder aGF;</div><div class="line">//</div><div class="line">....</div><div class="line">// disabling the classification of the input solid</div><div class="line">aGF.SetCheckInverted(Standard_False);</div><div class="line">//</div><div class="line">....</div></div><!-- fragment --><h4>TCL level</h4>
<p>To enable/disable the classification of the solids in DRAW, it is necessary to call <em>bcheckinverted</em> command with the appropriate value:</p><ul>
<li>0 - disabling the classification;</li>
<li>1 - default value, enabling the classification.</li>
</ul>
<div class="fragment"><div class="line">bcheckinverted 0</div></div><!-- fragment --><h2><a class="anchor" id="occt_algorithms_11a_5_obb"></a>
Usage of Oriented Bounding Boxes</h2>
<p>Since Oriented Bounding Boxes are usually much tighter than Axes Aligned Bounding Boxes (for more information on OBB see the <a class="el" href="occt_user_guides__modeling_data.html#occt_modat_6">Bounding boxes</a> chapter of Modeling data User guide) its usage can significantly speed-up the intersection stage of the operation by reducing the number of interfering objects.</p>
<h3><a class="anchor" id="occt_algorithms_11a_5_obb_1"></a>
Usage</h3>
<h4>API level</h4>
<p>To enable/disable the usage of OBB in the operation it is necessary to call the <em>SetUseOBB()</em> method with the approriate value: </p><div class="fragment"><div class="line">BOPAlgo_Builder aGF;</div><div class="line">//</div><div class="line">....</div><div class="line">// Enabling the usage of OBB in the operation</div><div class="line">aGF.SetUseOBB(Standard_True);</div><div class="line">//</div><div class="line">....</div></div><!-- fragment --><h4>TCL level</h4>
<p>To enable/disable the usage of OBB in the operation in DRAW it is necessary to call the <em>buseobb</em> command with the approriate value:</p><ul>
<li>0 - disabling the usage of OBB;</li>
<li>1 - enabling the usage of OBB. <div class="fragment"><div class="line">buseobb 1</div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="occt_algorithms_ers"></a>
Errors and warnings reporting system</h1>
<p>The chapter describes the Error/Warning reporting system of the algorithms in the Boolean Component.</p>
<p>The errors and warnings are collected in the instance of the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message___report.html">Message_Report</a></em> maintained as a field by common base class of Boolean operation algorithms <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___options.html">BOPAlgo_Options</a></em>.</p>
<p>The error is reported in for problems which cannot be treated and cause the algorithm to fail. In this case the result of the operation will be incorrect or incomplete or there will be no result at all.</p>
<p>The warnings are reported for the problems which can be potentially handled or ignored and thus do not cause the algorithms to stop their work (but probably affect the result).</p>
<p>All possible errors and warnings that can be set by the algorithm are listed in its header file. The complete list of errors and warnings that can be generated by Boolean operations is defined in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_b_o_p_algo___alerts_8hxx.html">BOPAlgo_Alerts.hxx</a></em>.</p>
<p>Use method <em>HasErrors()</em> to check for presence of error; method <em>HasError()</em> can be used to check for particular error. Methods <em>DumpErrors()</em> outputs textual description of collected errors into the stream. Similar methods <em>HasWarnings()</em>, <em>HasWarning()</em>, and <em>DumpWarnings()</em> are provided for warnings.</p>
<p>Note that messages corresponding to errors and warnings are defined in resource file <em>BOPAlgo.msg</em>. These messages can be localized; for that put translated version to separate file and load it in the application by call to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message___msg_file.html#a3d0853e2cd90f99e81fa0653e3120c03">Message_MsgFile::Load()</a></em> .</p>
<p>Here is the example of how to use this system: </p><div class="fragment"><div class="line">BOPAlgo_PaveFiller aPF;</div><div class="line">aPF.SetArguments(...);</div><div class="line">aPF.Perform();</div><div class="line">if (aPF.HasErrors()) {</div><div class="line">  aPF.DumpErrors(std::cerr);</div><div class="line">  //</div><div class="line">  if (aPF.HasError(STANDARD_TYPE(BOPAlgo_AlertNullInputShapes)) {</div><div class="line">    // some actions</div><div class="line">  }</div><div class="line">  if (aPF.HasWarning(STANDARD_TYPE(BOPAlgo_AlertTooSmallEdge)) {</div><div class="line">    // some actions</div><div class="line">  }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>DRAW commands executing Boolean operations output errors and warnings generated by these operations in textual form. Additional option allows saving shapes for which warnings have been generated, as DRAW variables. To activate this option, run command <em>bdrawwarnshapes</em> with argument 1 (or with 0 to deactivate): </p><div class="fragment"><div class="line">bdrawwarnshapes 1</div></div><!-- fragment --><p>After setting this option and running an algorithm the result will look as follows: </p><div class="fragment"><div class="line">Warning: The interfering vertices of the same argument: ws_1_1 ws_1_2</div><div class="line">Warning: The positioning of the shapes leads to creation of small edges without valid range: ws_2_1</div></div><!-- fragment --><h1><a class="anchor" id="occt_algorithms_history"></a>
History Information</h1>
<p>All operations in Boolean Component support <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_hist">History information</a>. This chapter describes how the History is filled for these operations.</p>
<p>Additionally to Vertices, Edges and Faces the history is also available for the Solids.</p>
<p>The rules for filling the History information about Deleted and Modified shapes are the same as for the API algorithms.</p>
<p>Only the rules for Generated shapes require clarification. In terms of the algorithms in Boolean Component the shape from the arguments can have Generated shapes only if these new shapes have been obtained as a result of pure intersection (not overlapping) of this shape with any other shapes from arguments. Thus, the Generated shapes are always:</p><ul>
<li>VERTICES created from the intersection points and may be Generated from edges and faces only;</li>
<li>EDGES created from the intersection edges and may be Generated from faces only.</li>
</ul>
<p>So, only EDGES and FACES could have information about Generated shapes. For all other types of shapes the list of Generated shapes will be empty.</p>
<h2><a class="anchor" id="occt_algorithms_history_ex"></a>
Examples</h2>
<p>Here are some examples illustrating the History information.</p>
<h3><a class="anchor" id="occt_algorithms_history_ex_del"></a>
Deleted shapes</h3>
<p>The result of CUT operation of two overlapping planar faces (see the example below) does not contain any parts from the tool face. Thus, the tool face is considered as Deleted. If the faces are not fully coinciding, the result must contain some parts of the object face. In this case object face will be considered as not deleted. But if the faces are fully coinciding, the result must be empty, and both faces will be considered as Deleted.</p>
<p>Example of the overlapping faces:</p>
<div class="fragment"><div class="line">plane p 0 0 0 0 0 1</div><div class="line">mkface f1 p -10 10 -10 10</div><div class="line">mkface f2 p 0 20 -10 10</div><div class="line"></div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line">baddobjects f1</div><div class="line">baddtools f2</div><div class="line">bfillds</div><div class="line">bbop r 2</div><div class="line"></div><div class="line">savehistory cut_hist</div><div class="line">isdeleted cut_hist f1</div><div class="line"># Not deleted</div><div class="line"></div><div class="line">isdeleted cut_hist f2</div><div class="line"># Deleted</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_history_ex_modif"></a>
Modified shapes</h3>
<p>In the FUSE operation of two edges intersecting in one point (see the example below), both edges will be split by the intersection point. All these splits will be contained in the result. Thus, each of the input edges will be Modified into its two splits. But in the CUT operation on the same edges, the tool edge will be Deleted from the result and, thus, will not have any Modified shapes.</p>
<p>Example of the intersecting edges: </p><div class="fragment"><div class="line">line l1 0 0 0 1 0 0</div><div class="line">mkedge e1 l1 -10 10</div><div class="line"></div><div class="line">line l2 0 0 0 0 1 0</div><div class="line">mkedge e2 l2 -10 10</div><div class="line"></div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line">baddobjects e1</div><div class="line">baddtools e2</div><div class="line">bfillds</div><div class="line"></div><div class="line"># fuse operation</div><div class="line">bbop r 1</div><div class="line"></div><div class="line">savehistory fuse_hist</div><div class="line"></div><div class="line">modified m1 fuse_hist e1</div><div class="line">nbshapes m1</div><div class="line"># EDGES: 2</div><div class="line"></div><div class="line">modified m2 fuse_hist e2</div><div class="line">nbshapes m2</div><div class="line"># EDGES: 2</div><div class="line"></div><div class="line"># cut operation</div><div class="line">bbop r 2</div><div class="line"></div><div class="line">savehistory cut_hist</div><div class="line"></div><div class="line">modified m1 cut_hist e1</div><div class="line">nbshapes m1</div><div class="line"># EDGES: 2</div><div class="line"></div><div class="line">modified m2 cut_hist e2</div><div class="line"># The shape has not been modified</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_history_gen"></a>
Generated shapes</h3>
<p>Two intersecting edges will both have the intersection vertices Generated from them.</p>
<p>As for the operation with intersecting faces, consider the following example:</p>
<div class="fragment"><div class="line">plane p1 0 0 0 0 0 1</div><div class="line">mkface f1 p1 -10 10 -10 10</div><div class="line"></div><div class="line">plane p2 0 0 0 1 0 0</div><div class="line">mkface f2 p2 -10 10 -10 10</div><div class="line"></div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line">baddobjects f1</div><div class="line">baddtools f2</div><div class="line">bfillds</div><div class="line"></div><div class="line"># fuse operation</div><div class="line">bbop r 1</div><div class="line"></div><div class="line">savehistory fuse_hist</div><div class="line"></div><div class="line">generated gf1 fuse_hist f1</div><div class="line">nbshapes gf1</div><div class="line"># EDGES: 1</div><div class="line"></div><div class="line">generated gf2 fuse_hist f2</div><div class="line">nbshapes gf2</div><div class="line"># EDGES: 1</div><div class="line"></div><div class="line"></div><div class="line"># common operation - result is empty</div><div class="line">bbop r 0</div><div class="line"></div><div class="line">savehistory com_hist</div><div class="line"></div><div class="line">generated gf1 com_hist f1</div><div class="line"># No shapes were generated from the shape</div><div class="line"></div><div class="line">generated gf2 com_hist f2</div><div class="line"># No shapes were generated from the shape</div></div><!-- fragment --><h1><a class="anchor" id="occt_algorithms_simplification"></a>
BOP result simplification</h1>
<p>The API algorithms implementing Boolean Operations provide possibility to simplify the result shape by unification of the connected tangential edges and faces. This simplification is performed by the method <em>SimplifyResult</em> which is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___builder_algo.html">BRepAlgoAPI_BuilderAlgo</a></em> (General Fuse operation). It makes it available for users of the classes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em> (all Boolean Operations) and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___splitter.html">BRepAlgoAPI_Splitter</a></em> (split operation).</p>
<p>The simplification is performed by the means of <em>ShapeUpgrade_UnifySameDom</em> algorithm. The result of operation is overwritten with the simplified result.</p>
<p>The simplification is performed without creation of the Internal shapes, i.e. shapes connections will never be broken. It is performed on the whole result shape. Thus, if the input shapes contained connected tangent edges or faces unmodified during the operation they will also be unified.</p>
<p>History of the simplification is merged into the main history of operation, thus it will be accounted when asking for Modified, Generated and Deleted shapes.</p>
<p>Some options of the main operation are passed into the Unifier:</p><ul>
<li>Fuzzy tolerance of the operation is given to the Unifier as the linear tolerance.</li>
<li>Non destructive mode here controls the safe input mode in Unifier.</li>
</ul>
<p>For controlling this possibility in DRAW the command <b>bsimplify</b> has been implemented. See the <a class="el" href="occt_user_guides__test_harness.html#occt_draw_bop_options">Boolean Operations options</a> chapter in draw user guide.</p>
<h2><a class="anchor" id="occt_algorithms_simplification_examples"></a>
Examples</h2>
<p>Here is the simple example of simplification of the result of Fuse operation of two boxes:</p>
<div class="fragment"><div class="line">bsimplify -f 1</div><div class="line"></div><div class="line">box b1 10 10 15</div><div class="line">box b2 3 7 0 10 10 15</div><div class="line">bclearobjects</div><div class="line">bcleartools</div><div class="line">baddobjects b1</div><div class="line">baddtools b2</div><div class="line">bfillds</div><div class="line">bapibop r 1</div></div><!-- fragment --><table align="center">
<tr>
<td><div class="image">
<img src="bop_simple_001.png" alt="bop_simple_001.png"/>
<div class="caption">
Not simplified result</div></div>
 </td><td><div class="image">
<img src="bop_simple_002.png" alt="bop_simple_002.png"/>
<div class="caption">
Simplified result</div></div>
  </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_11b"></a>
Usage</h1>
<p>The chapter contains some examples of the OCCT Boolean Component usage. The usage is possible on two levels: C++ and Tcl.</p>
<h2><a class="anchor" id="occt_algorithms_11b_1"></a>
Package BRepAlgoAPI</h2>
<p>The package <em>BRepAlgoAPI</em> provides the Application Programming Interface of the Boolean Component.</p>
<p>The package consists of the following classes:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___algo.html">BRepAlgoAPI_Algo</a></em> &ndash; the root class that provides the interface for algorithms.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___builder_algo.html">BRepAlgoAPI_BuilderAlgo</a></em> &ndash; the class API level of General Fuse algorithm.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___splitter.html">BRepAlgoAPI_Splitter</a></em> &ndash; the class API level of the Splitter algorithm.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em> &ndash; the root class for the classes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___fuse.html">BRepAlgoAPI_Fuse</a></em>. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___common.html">BRepAlgoAPI_Common</a></em>, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___cut.html">BRepAlgoAPI_Cut</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___section.html">BRepAlgoAPI_Section</a></em>.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___fuse.html">BRepAlgoAPI_Fuse</a></em> &ndash; the class provides Boolean fusion operation.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___common.html">BRepAlgoAPI_Common</a></em> &ndash; the class provides Boolean common operation.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___cut.html">BRepAlgoAPI_Cut</a></em> &ndash; the class provides Boolean cut operation.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___section.html">BRepAlgoAPI_Section</a></em> &ndash; the class provides Boolean section operation.</li>
</ul>
<div class="image">
<img src="operations_image065.png" alt="operations_image065.png"/>
<div class="caption">
Diagram of BRepAlgoAPI package</div></div>
<p> The detailed description of the classes can be found in the corresponding .hxx files. The examples are below in this chapter.</p>
<h2><a class="anchor" id="occt_algorithms_11b_2"></a>
Package BOPTest</h2>
<p>The package <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_test.html">BOPTest</a></em> provides the usage of the Boolean Component on Tcl level. The method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_test.html#a4c7258de9652281389994a8d4464f81f">BOPTest::APICommands</a></em> contains corresponding Tcl commands:</p>
<ul>
<li><em>bapibuild</em> &ndash; for General Fuse Operator;</li>
<li><em>bapisplit</em> &ndash; for Splitter Operator;</li>
<li><em>bapibop</em> &ndash; for Boolean Operator and Section Operator.</li>
</ul>
<p>The examples of how to use the commands are below in this chapter.</p>
<h3><a class="anchor" id="occt_algorithms_11b_2_1"></a>
Case 1. General Fuse operation</h3>
<p>The following example illustrates how to use General Fuse operator:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt;</div><div class="line">#include &lt;TopTools_ListOfShape.hxx&gt;</div><div class="line">#include &lt;BRepAlgoAPI_BuilderAlgo.hxx&gt;</div><div class="line"> {…</div><div class="line">  BRepAlgoAPI_BuilderAlgo aBuilder;</div><div class="line">  //</div><div class="line">  // prepare the arguments</div><div class="line">  TopTools_ListOfShape&amp; aLS=…;</div><div class="line">  //</div><div class="line">  // set the arguments  </div><div class="line">  aBuilder.SetArguments(aLS);</div><div class="line"></div><div class="line">  // Set options for the algorithm</div><div class="line">  // setting options on this level is similar to setting options to GF algorithm on low level (see &quot;GF Usage&quot; chapter)</div><div class="line">  ...</div><div class="line"></div><div class="line">  // run the algorithm </div><div class="line">  aBuilder.Build(); </div><div class="line">  if (aBuilder.HasErrors()) {</div><div class="line">    // an error treatment</div><div class="line">    return;</div><div class="line">  }</div><div class="line">  //</div><div class="line">  // result of the operation aR</div><div class="line">  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div><div class="line">…</div><div class="line">}</div></div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 3 4 5 10 10 10 </div><div class="line">box b3 5 6 7 10 10 10 </div><div class="line">#</div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line">#</div><div class="line"># set the arguments</div><div class="line">baddobjects b1 b2 b3</div><div class="line"></div><div class="line"># set options for the algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line"></div><div class="line"># run the algorithm</div><div class="line"># r is the result of the operation</div><div class="line">bapibuild r </div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_2"></a>
Case 2. Splitting operation</h3>
<p>The following example illustrates how to use the Splitter operator:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt;</div><div class="line">#include &lt;TopTools_ListOfShape.hxx&gt;</div><div class="line">#include &lt;BRepAlgoAPI_Splitter.hxx&gt;</div><div class="line">//</div><div class="line">BRepAlgoAPI_BuilderAlgo aSplitter;</div><div class="line">//</div><div class="line">// prepare the arguments</div><div class="line">// objects</div><div class="line">TopTools_ListOfShape&amp; aLSObjects = … ;</div><div class="line">// tools</div><div class="line">TopTools_ListOfShape&amp; aLSTools = … ;</div><div class="line">//</div><div class="line">// set the arguments</div><div class="line">aSplitter.SetArguments(aLSObjects);</div><div class="line">aSplitter.SetTools(aLSTools);</div><div class="line">//</div><div class="line">// Set options for the algorithm</div><div class="line">// setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">//</div><div class="line">// run the algorithm </div><div class="line">aSplitter.Build(); </div><div class="line">// check error status</div><div class="line">if (aSplitter.HasErrors()) {</div><div class="line">  return;</div><div class="line">}</div><div class="line">//</div><div class="line">// result of the operation aResult</div><div class="line">const TopoDS_Shape&amp; aResult = aSplitter.Shape();</div></div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line"># objects</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 7 0 0 10 10 10</div><div class="line"></div><div class="line"># tools</div><div class="line">plane p 10 5 5 0 1 0</div><div class="line">mkface f p -20 20 -20 20</div><div class="line">#</div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line">#</div><div class="line"># set the objects</div><div class="line">baddobjects b1 b2</div><div class="line"># set the tools</div><div class="line">baddtools f</div><div class="line">#</div><div class="line"># set options for the algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">#</div><div class="line"># run the algorithm</div><div class="line"># r is the result of the operation</div><div class="line">bapisplit r </div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_3"></a>
Case 3. Common operation</h3>
<p>The following example illustrates how to use Common operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt;</div><div class="line">#include &lt;TopTools_ListOfShape.hxx&gt;</div><div class="line">#include &lt; BRepAlgoAPI_Common.hxx&gt;</div><div class="line"> {…</div><div class="line">  Standard_Boolean bRunParallel;</div><div class="line">  Standard_Real aFuzzyValue;</div><div class="line">  BRepAlgoAPI_Common aBuilder;</div><div class="line"></div><div class="line">  // perpare the arguments</div><div class="line">  TopTools_ListOfShape&amp; aLS=…;</div><div class="line">  TopTools_ListOfShape&amp; aLT=…;</div><div class="line">  //</div><div class="line">  bRunParallel=Standard_True;</div><div class="line">  aFuzzyValue=2.1e-5;</div><div class="line">  //</div><div class="line">  // set the arguments  </div><div class="line">  aBuilder.SetArguments(aLS);</div><div class="line">  aBuilder.SetTools(aLT);</div><div class="line">  //    </div><div class="line">  // Set options for the algorithm</div><div class="line">  // setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">  ...</div><div class="line">  //</div><div class="line">  // run the algorithm </div><div class="line">  aBuilder.Build(); </div><div class="line">  if (aBuilder.HasErrors()) {</div><div class="line">    // an error treatment</div><div class="line">    return;</div><div class="line">  }</div><div class="line">  //</div><div class="line">  // result of the operation aR</div><div class="line">  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div><div class="line">…</div><div class="line">}</div></div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 7 0 4 10 10 10 </div><div class="line">box b3 14 0 0 10 10 10 </div><div class="line">#</div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line">#</div><div class="line"># set the arguments</div><div class="line">baddobjects b1 b3</div><div class="line">baddtools b2</div><div class="line">#</div><div class="line"># set options for the algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">#</div><div class="line"># run the algorithm</div><div class="line"># r is the result of the operation</div><div class="line"># 0 means Common operation</div><div class="line">bapibop r 0</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_4"></a>
Case 4. Fuse operation</h3>
<p>The following example illustrates how to use Fuse operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt;</div><div class="line">#include &lt;TopTools_ListOfShape.hxx&gt;</div><div class="line">#include &lt; BRepAlgoAPI_Fuse.hxx&gt;</div><div class="line"> {…</div><div class="line">  Standard_Boolean bRunParallel;</div><div class="line">  Standard_Real aFuzzyValue;</div><div class="line">  BRepAlgoAPI_Fuse aBuilder;</div><div class="line"></div><div class="line">  // perpare the arguments</div><div class="line">  TopTools_ListOfShape&amp; aLS=…;</div><div class="line">  TopTools_ListOfShape&amp; aLT=…;</div><div class="line">  //</div><div class="line">  bRunParallel=Standard_True;</div><div class="line">  aFuzzyValue=2.1e-5;</div><div class="line">  //</div><div class="line">  // set the arguments  </div><div class="line">  aBuilder.SetArguments(aLS);</div><div class="line">  aBuilder.SetTools(aLT);</div><div class="line">  //    </div><div class="line">  // Set options for the algorithm</div><div class="line">  // setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">  ...</div><div class="line">  //</div><div class="line">  // run the algorithm </div><div class="line">  aBuilder.Build(); </div><div class="line">  if (aBuilder.HasErrors()) {</div><div class="line">    // an error treatment</div><div class="line">    return;</div><div class="line">  }</div><div class="line">  //</div><div class="line">  // result of the operation aR</div><div class="line">  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div><div class="line">…</div><div class="line">}</div></div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 7 0 4 10 10 10 </div><div class="line">box b3 14 0 0 10 10 10 </div><div class="line">#</div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line">#</div><div class="line"># set the arguments</div><div class="line">baddobjects b1 b3</div><div class="line">baddtools b2</div><div class="line">#</div><div class="line"># set options for the algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">#</div><div class="line"># run the algorithm</div><div class="line"># r is the result of the operation</div><div class="line"># 1 means Fuse operation</div><div class="line">bapibop r 1</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_5"></a>
Case 5. Cut operation</h3>
<p>The following example illustrates how to use Cut operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt;</div><div class="line">#include &lt;TopTools_ListOfShape.hxx&gt;</div><div class="line">#include &lt; BRepAlgoAPI_Cut.hxx&gt;</div><div class="line"> {…</div><div class="line">  Standard_Boolean bRunParallel;</div><div class="line">  Standard_Real aFuzzyValue;</div><div class="line">  BRepAlgoAPI_Cut aBuilder;</div><div class="line"></div><div class="line">  // perpare the arguments</div><div class="line">  TopTools_ListOfShape&amp; aLS=…;</div><div class="line">  TopTools_ListOfShape&amp; aLT=…;</div><div class="line">  //</div><div class="line">  bRunParallel=Standard_True;</div><div class="line">  aFuzzyValue=2.1e-5;</div><div class="line">  //</div><div class="line">  // set the arguments  </div><div class="line">  aBuilder.SetArguments(aLS);</div><div class="line">  aBuilder.SetTools(aLT);</div><div class="line">  //    </div><div class="line">  // Set options for the algorithm</div><div class="line">  // setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">  ...</div><div class="line">  //</div><div class="line">  // run the algorithm </div><div class="line">  aBuilder.Build(); </div><div class="line">  if (aBuilder.HasErrors()) {</div><div class="line">    // an error treatment</div><div class="line">    return;</div><div class="line">  }</div><div class="line">  //</div><div class="line">  // result of the operation aR</div><div class="line">  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div><div class="line">…</div><div class="line">}</div></div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 7 0 4 10 10 10 </div><div class="line">box b3 14 0 0 10 10 10 </div><div class="line">#</div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line">#</div><div class="line"># set the arguments</div><div class="line">baddobjects b1 b3</div><div class="line">baddtools b2</div><div class="line">#</div><div class="line"># set options for the algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">#</div><div class="line"># run the algorithm</div><div class="line"># r is the result of the operation</div><div class="line"># 2 means Cut operation</div><div class="line">bapibop r 2</div></div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_6"></a>
Case 6. Section operation</h3>
<p>The following example illustrates how to use Section operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt;</div><div class="line">#include &lt;TopTools_ListOfShape.hxx&gt;</div><div class="line">#include &lt; BRepAlgoAPI_Section.hxx&gt;</div><div class="line"> {…</div><div class="line">  Standard_Boolean bRunParallel;</div><div class="line">  Standard_Real aFuzzyValue;</div><div class="line">  BRepAlgoAPI_Section aBuilder;</div><div class="line"></div><div class="line">  // perpare the arguments</div><div class="line">  TopTools_ListOfShape&amp; aLS=…;</div><div class="line">  TopTools_ListOfShape&amp; aLT=…;</div><div class="line">  //</div><div class="line">  bRunParallel=Standard_True;</div><div class="line">  aFuzzyValue=2.1e-5;</div><div class="line">  //</div><div class="line">  // set the arguments  </div><div class="line">  aBuilder.SetArguments(aLS);</div><div class="line">  aBuilder.SetTools(aLT);</div><div class="line">  //    </div><div class="line">  // Set options for the algorithm</div><div class="line">  // setting options for this algorithm is similar to setting options for GF algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">  ...</div><div class="line">  //</div><div class="line">  // run the algorithm </div><div class="line">  aBuilder.Build(); </div><div class="line">  if (aBuilder.HasErrors()) {</div><div class="line">    // an error treatment</div><div class="line">    return;</div><div class="line">  }</div><div class="line">  //</div><div class="line">  // result of the operation aR</div><div class="line">  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div><div class="line">…</div><div class="line">}</div></div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"># prepare the arguments</div><div class="line">box b1 10 10 10 </div><div class="line">box b2 3 4 5 10 10 10 </div><div class="line">box b3 5 6 7 10 10 10 </div><div class="line">#</div><div class="line"># clear inner contents</div><div class="line">bclearobjects; bcleartools;</div><div class="line">#</div><div class="line"># set the arguments</div><div class="line">baddobjects b1 b3</div><div class="line">baddtools b2</div><div class="line">#</div><div class="line"># set options for the algorithm (see &quot;GF Usage&quot; chapter)</div><div class="line">...</div><div class="line">#</div><div class="line"># run the algorithm</div><div class="line"># r is the result of the operation</div><div class="line"># 4 means Section operation</div><div class="line">bapibop r 4</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 26 2019 18:39:15 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
