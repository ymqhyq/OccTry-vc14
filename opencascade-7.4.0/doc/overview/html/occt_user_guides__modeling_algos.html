<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Modeling Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.4.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__modeling_algos.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Modeling Algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_modalg_1">Introduction</a></li>
<li class="level1"><a href="#occt_modalg_2">Geometric Tools</a><ul><li class="level2"><a href="#occt_modalg_2_2">Intersections</a><ul><li class="level3"><a href="#occt_modalg_2_2_1">Intersection of two curves</a></li>
<li class="level3"><a href="#occt_modalg_2_2_2">Intersection of Curves and Surfaces</a></li>
<li class="level3"><a href="#occt_modalg_2_2_3">Intersection of two Surfaces</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_3">Interpolations</a><ul><li class="level3"><a href="#occt_modalg_2_3_1">Geom2dAPI_Interpolate</a></li>
<li class="level3"><a href="#occt_modalg_2_3_2">GeomAPI_Interpolate</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_4">Lines and  Circles from Constraints</a><ul><li class="level3"><a href="#occt_modalg_2_4_1">Types of constraints</a></li>
<li class="level3"><a href="#occt_modalg_2_4_2">Available types of lines and circles</a></li>
<li class="level3"><a href="#occt_modalg_2_4_3">Types of  algorithms</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_5">Curves and Surfaces from Constraints</a><ul><li class="level3"><a href="#occt_modalg_2_5_1">Faired and Minimal Variation 2D Curves</a></li>
<li class="level3"><a href="#occt_modalg_2_5_2">Ruled Surfaces</a></li>
<li class="level3"><a href="#occt_modalg_2_5_3">Pipe Surfaces</a></li>
<li class="level3"><a href="#occt_modalg_2_5_4">Filling a contour</a></li>
<li class="level3"><a href="#occt_modalg_2_5_5">Plate surfaces</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_6">Projections</a><ul><li class="level3"><a href="#occt_modalg_2_6_1">Projection of a 2D Point on a Curve</a></li>
<li class="level3"><a href="#occt_modalg_2_6_2">Projection of a 3D Point on a Curve</a></li>
<li class="level3"><a href="#occt_modalg_2_6_3">Projection of a Point on a Surface</a></li>
<li class="level3"><a href="#occt_modalg_2_12_8">Switching from 2d and 3d Curves</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_2_topo_tools">Topological Tools</a><ul><li class="level2"><a href="#occt_modalg_2_topo_tools_1">Creation of the faces from wireframe model</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_2">Classification of the shapes</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_3">Orientation of the shapes in the container</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_4">Making new shapes</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_5">Building PCurves</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_6">Checking the validity of the shapes</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_7">Taking a point inside the face</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_8">Getting normal for the face</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_3a">The Topology API</a><ul><li class="level2"><a href="#occt_modalg_3a_1">Error Handling in the Topology API</a></li>
<li class="level2"><a href="#occt_modalg_hist">History support</a><ul><li class="level3"><a href="#occt_modalg_hist_del">Deleted shapes</a></li>
<li class="level3"><a href="#occt_modalg_hist_mod">Modified shapes</a></li>
<li class="level3"><a href="#occt_modalg_hist_gen">Generated shapes</a></li>
<li class="level3"><a href="#occt_modalg_hist_tool">BRepTools_History</a></li>
<li class="level3"><a href="#occt_modalg_hist_draw">DRAW history support</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_3">Standard  Topological Objects</a><ul><li class="level2"><a href="#occt_modalg_3_1">Vertex</a></li>
<li class="level2"><a href="#occt_modalg_3_2">Edge</a><ul><li class="level3"><a href="#occt_modalg_3_2_1">Basic edge construction method</a></li>
<li class="level3"><a href="#occt_modalg_3_2_2">Supplementary edge construction methods</a></li>
<li class="level3"><a href="#occt_modalg_3_2_3">Other information and error status</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_3_3">Edge 2D</a></li>
<li class="level2"><a href="#occt_modalg_3_4">Polygon</a></li>
<li class="level2"><a href="#occt_modalg_3_5">Face</a><ul><li class="level3"><a href="#occt_modalg_3_5_1">Basic face construction method</a></li>
<li class="level3"><a href="#occt_modalg_3_5_2">Supplementary face construction methods</a></li>
<li class="level3"><a href="#occt_modalg_3_5_3">Error status</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_3_6">Wire</a></li>
<li class="level2"><a href="#occt_modalg_3_7">Shell</a></li>
<li class="level2"><a href="#occt_modalg_3_8">Solid</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_3b">Object Modification</a><ul><li class="level2"><a href="#occt_modalg_3b_1">Transformation</a></li>
<li class="level2"><a href="#occt_modalg_3b_2">Duplication</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_4">Primitives</a><ul><li class="level2"><a href="#occt_modalg_4_1">Making  Primitives</a><ul><li class="level3"><a href="#occt_modalg_4_1_1">Box</a></li>
<li class="level3"><a href="#occt_modalg_4_1_2">Wedge</a></li>
<li class="level3"><a href="#occt_modalg_4_1_3">Rotation object</a></li>
<li class="level3"><a href="#occt_modalg_4_1_4">Cylinder</a></li>
<li class="level3"><a href="#occt_modalg_4_1_5">Cone</a></li>
<li class="level3"><a href="#occt_modalg_4_1_6">Sphere</a></li>
<li class="level3"><a href="#occt_modalg_4_1_7">Torus</a></li>
<li class="level3"><a href="#occt_modalg_4_1_8">Revolution</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_4_2">Sweeping:  Prism, Revolution and Pipe</a><ul><li class="level3"><a href="#occt_modalg_4_2_1">Sweeping</a></li>
<li class="level3"><a href="#occt_modalg_4_2_2">Prism</a></li>
<li class="level3"><a href="#occt_modalg_4_2_3">Rotational Sweep</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_5">Boolean  Operations</a><ul><li class="level2"><a href="#occt_modalg_5_1">Input and Result Arguments</a></li>
<li class="level2"><a href="#occt_modalg_5_2">Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_6">Fillets and  Chamfers</a><ul><li class="level2"><a href="#occt_modalg_6_1">Fillets</a></li>
<li class="level2"><a href="#occt_modalg_6_1_1">Fillet on shape</a></li>
<li class="level2"><a href="#occt_modalg_6_1_2">Chamfer</a></li>
<li class="level2"><a href="#occt_modalg_6_1_3">Fillet on a planar face</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_7">Offsets, Drafts, Pipes and Evolved shapes</a><ul><li class="level2"><a href="#occt_modalg_7_1">Offset computation</a></li>
<li class="level2"><a href="#occt_modalg_7_2">Shelling</a></li>
<li class="level2"><a href="#occt_modalg_7_3">Draft Angle</a></li>
<li class="level2"><a href="#occt_modalg_7_4">Pipe  Constructor</a></li>
<li class="level2"><a href="#occt_modalg_7_5">Evolved Solid</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_8">Sewing</a><ul><li class="level2"><a href="#occt_modalg_8_1">Introduction</a></li>
<li class="level2"><a href="#occt_modalg_8_2">Sewing Algorithm</a></li>
<li class="level2"><a href="#occt_modalg_8_3">Tolerance Management</a></li>
<li class="level2"><a href="#occt_modalg_8_4">Manifold and Non-manifold Sewing</a></li>
<li class="level2"><a href="#occt_modalg_8_5">Local Sewing</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_9">Features</a><ul><li class="level2"><a href="#occt_modalg_9_1">Form Features</a><ul><li class="level3"><a href="#occt_modalg_9_1_1">Prism</a></li>
<li class="level3"><a href="#occt_modalg_9_1_2">Draft Prism</a></li>
<li class="level3"><a href="#occt_modalg_9_1_3">Revolution</a></li>
<li class="level3"><a href="#occt_modalg_9_1_4">Pipe</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_9_2">Mechanical Features</a><ul><li class="level3"><a href="#occt_modalg_9_2_1">Linear Form</a></li>
<li class="level3"><a href="#occt_modalg_9_2_3">Gluer</a></li>
<li class="level3"><a href="#occt_modalg_9_2_4">Split Shape</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_10">Hidden Line  Removal</a><ul><li class="level2"><a href="#occt_modalg_10_1">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_11">Meshing</a><ul><li class="level2"><a href="#occt_modalg_11_1">Mesh presentations</a></li>
<li class="level2"><a href="#occt_modalg_11_2">Meshing algorithm</a></li>
<li class="level2"><a href="#occt_modalg_11_3">BRepMesh Architecture</a><ul><li class="level3"><a href="#occt_modalg_11_3_1">Goals</a></li>
<li class="level3"><a href="#occt_modalg_11_3_2">General workflow</a></li>
<li class="level3"><a href="#occt_modalg_11_3_3">Common interfaces</a></li>
<li class="level3"><a href="#occt_modalg_11_3_4">Create model data structure</a></li>
<li class="level3"><a href="#occt_modalg_11_3_5">Discretize edges 3D &amp; 2D curves</a></li>
<li class="level3"><a href="#occt_modalg_11_3_6">Heal discrete model</a></li>
<li class="level3"><a href="#occt_modalg_11_3_7">Preprocess discrete model</a></li>
<li class="level3"><a href="#occt_modalg_11_3_8">Discretize faces</a></li>
<li class="level3"><a href="#occt_modalg_11_3_9">Postprocess discrete model</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_defeaturing">3D Model Defeaturing</a><ul><li class="level2"><a href="#occt_modalg_defeaturing_usage">Usage</a></li>
<li class="level2"><a href="#occt_modalg_defeaturing_examples">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_makeperiodic">3D Model Periodicity</a><ul><li class="level2"><a href="#occt_modalg_makeperiodic_how_it_works">How the shape is made periodic</a></li>
<li class="level2"><a href="#occt_modalg_makeperiodic_association">Opposite shapes association</a></li>
<li class="level2"><a href="#occt_modalg_makeperiodic_repetition">Periodic shape repetition</a></li>
<li class="level2"><a href="#occt_modalg_makeperiodic_history">History support</a></li>
<li class="level2"><a href="#occt_modalg_makeperiodic_errors">Errors/Warnings</a></li>
<li class="level2"><a href="#occt_modalg_makeperiodic_usage">Usage</a></li>
<li class="level2"><a href="#occt_modalg_makeperiodic_examples">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_makeconnected">Making touching shapes connected</a><ul><li class="level2"><a href="#occt_modalg_makeconnected_materials">Material association</a></li>
<li class="level2"><a href="#occt_modalg_makeconnected_makeperiodic">Making connected shape periodic</a></li>
<li class="level2"><a href="#occt_modalg_makeconnected_history">History support</a></li>
<li class="level2"><a href="#occt_modalg_makeconnected_errors">Errors/Warnings</a></li>
<li class="level2"><a href="#occt_modalg_makeconnected_usage">Usage</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_modalg_1"></a>
Introduction</h1>
<p>This manual explains how to use the Modeling Algorithms. It provides basic documentation on modeling algorithms. For advanced information on Modeling Algorithms, see our <a href="https://www.opencascade.com/content/tutorial-learning">E-learning &amp; Training</a> offerings.</p>
<p>The Modeling Algorithms module brings together a wide range of topological algorithms used in modeling. Along with these tools, you will find the geometric algorithms, which they call.</p>
<h1><a class="anchor" id="occt_modalg_2"></a>
Geometric Tools</h1>
<p>Open CASCADE Technology geometric tools provide algorithms to:</p><ul>
<li>Calculate the intersection of two 2D curves, surfaces, or a 3D curve and a surface;</li>
<li>Project points onto 2D and 3D curves, points onto surfaces, and 3D curves onto surfaces;</li>
<li>Construct lines and circles from constraints;</li>
<li>Construct curves and surfaces from constraints;</li>
<li>Construct curves and surfaces by interpolation.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_2"></a>
Intersections</h2>
<p>The Intersections component is used to compute intersections between 2D or 3D geometrical objects:</p><ul>
<li>the intersections between two 2D curves;</li>
<li>the self-intersections of a 2D curve;</li>
<li>the intersection between a 3D curve and a surface;</li>
<li>the intersection between two surfaces.</li>
</ul>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___inter_curve_curve.html">Geom2dAPI_InterCurveCurve</a></em> class allows the evaluation of the intersection points (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a></em>) between two geometric curves (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>) and the evaluation of the points of self-intersection of a curve.</p>
<div class="image">
<img src="modeling_algos_image003.png" alt="modeling_algos_image003.png"/>
<div class="caption">
Intersection and self-intersection of curves</div></div>
<p> In both cases, the algorithm requires a value for the tolerance (Standard_Real) for the confusion between two points. The default tolerance value used in all constructors is <em>1.0e-6.</em></p>
<div class="image">
<img src="modeling_algos_image004.png" alt="modeling_algos_image004.png"/>
<div class="caption">
Intersection and tangent intersection</div></div>
<p> The algorithm returns a point in the case of an intersection and a segment in the case of tangent intersection.</p>
<h3><a class="anchor" id="occt_modalg_2_2_1"></a>
Intersection of two curves</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___inter_curve_curve.html">Geom2dAPI_InterCurveCurve</a></em> class may be instantiated for intersection of curves <em>C1</em> and <em>C2</em>. </p><div class="fragment"><div class="line">Geom2dAPI_InterCurveCurve Intersector(C1,C2,tolerance); </div></div><!-- fragment --><p>or for self-intersection of curve <em>C3</em>. </p><div class="fragment"><div class="line">Geom2dAPI_InterCurveCurve Intersector(C3,tolerance); </div></div><!-- fragment --><div class="fragment"><div class="line">Standard_Integer N = Intersector.NbPoints(); </div></div><!-- fragment --><p> Calls the number of intersection points</p>
<p>To select the desired intersection point, pass an integer index value in argument. </p><div class="fragment"><div class="line">gp_Pnt2d P = Intersector.Point(Index); </div></div><!-- fragment --><p>To call the number of intersection segments, use </p><div class="fragment"><div class="line">Standard_Integer M = Intersector.NbSegments(); </div></div><!-- fragment --><p>To select the desired intersection segment pass integer index values in argument. </p><div class="fragment"><div class="line">Handle(Geom2d_Curve) Seg1, Seg2; </div><div class="line">Intersector.Segment(Index,Seg1,Seg2); </div><div class="line">// if intersection of 2 curves </div><div class="line">Intersector.Segment(Index,Seg1); </div><div class="line">// if self-intersection of a curve </div></div><!-- fragment --><p>If you need access to a wider range of functionalities the following method will return the algorithmic object for the calculation of intersections:</p>
<div class="fragment"><div class="line">Geom2dInt_GInter&amp; TheIntersector = Intersector.Intersector(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_2_2"></a>
Intersection of Curves and Surfaces</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___int_c_s.html">GeomAPI_IntCS</a></em> class is used to compute the intersection points between a curve and a surface.</p>
<p>This class is instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_IntCS Intersector(C, S); </div></div><!-- fragment --><p>To call the number of intersection points, use: </p><div class="fragment"><div class="line">Standard_Integer nb = Intersector.NbPoints(); </div></div><!-- fragment --><div class="fragment"><div class="line">gp_Pnt&amp; P = Intersector.Point(Index); </div></div><!-- fragment --><p>Where <em>Index</em> is an integer between 1 and <em>nb</em>, calls the intersection points.</p>
<h3><a class="anchor" id="occt_modalg_2_2_3"></a>
Intersection of two Surfaces</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___int_s_s.html">GeomAPI_IntSS</a></em> class is used to compute the intersection of two surfaces from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em> with respect to a given tolerance.</p>
<p>This class is instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_IntSS Intersector(S1, S2, Tolerance); </div></div><!-- fragment --><p> Once the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___int_s_s.html">GeomAPI_IntSS</a></em> object has been created, it can be interpreted.</p>
<div class="fragment"><div class="line">Standard_Integer nb = Intersector. NbLines(); </div></div><!-- fragment --><p> Calls the number of intersection curves.</p>
<div class="fragment"><div class="line">Handle(Geom_Curve) C = Intersector.Line(Index) </div></div><!-- fragment --><p> Where <em>Index</em> is an integer between 1 and <em>nb</em>, calls the intersection curves.</p>
<h2><a class="anchor" id="occt_modalg_2_3"></a>
Interpolations</h2>
<p>The Interpolation Laws component provides definitions of functions: <em> y=f(x) </em>.</p>
<p>In particular, it provides definitions of:</p><ul>
<li>a linear function,</li>
<li>an <em> S </em> function, and</li>
<li>an interpolation function for a range of values.</li>
</ul>
<p>Such functions can be used to define, for example, the evolution law of a fillet along the edge of a shape.</p>
<p>The validity of the function built is never checked: the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_law.html">Law</a> package does not know for what application or to what end the function will be used. In particular, if the function is used as the evolution law of a fillet, it is important that the function is always positive. The user must check this.</p>
<h3><a class="anchor" id="occt_modalg_2_3_1"></a>
Geom2dAPI_Interpolate</h3>
<p>This class is used to interpolate a BSplineCurve passing through an array of points. If tangency is not requested at the point of interpolation, continuity will be <em>C2</em>. If tangency is requested at the point, continuity will be <em>C1</em>. If Periodicity is requested, the curve will be closed and the junction will be the first point given. The curve will then have a continuity of <em>C1</em> only. This class may be instantiated as follows: </p><div class="fragment"><div class="line">Geom2dAPI_Interpolate </div><div class="line">(const  Handle_TColgp_HArray1OfPnt2d&amp; Points, </div><div class="line">const  Standard_Boolean PeriodicFlag, </div><div class="line">const Standard_Real  Tolerance); </div><div class="line"></div><div class="line">Geom2dAPI_Interpolate Interp(Points, Standard_False, </div><div class="line">                                    Precision::Confusion()); </div></div><!-- fragment --><p>It is possible to call the BSpline curve from the object defined above it. </p><div class="fragment"><div class="line">Handle(Geom2d_BSplineCurve) C = Interp.Curve(); </div></div><!-- fragment --><p>Note that the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(Geom2d_BSplineCurve)</a></em> operator has been redefined by the method <em>Curve()</em>. Consequently, it is unnecessary to pass via the construction of an intermediate object of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___interpolate.html">Geom2dAPI_Interpolate</a></em> type and the following syntax is correct.</p>
<div class="fragment"><div class="line">Handle(Geom2d_BSplineCurve) C = </div><div class="line">Geom2dAPI_Interpolate(Points, </div><div class="line">    Standard_False, </div><div class="line">    Precision::Confusion()); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_3_2"></a>
GeomAPI_Interpolate</h3>
<p>This class may be instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_Interpolate </div><div class="line">(const  Handle_TColgp_HArray1OfPnt&amp; Points, </div><div class="line">const  Standard_Boolean PeriodicFlag, </div><div class="line">const Standard_Real  Tolerance); </div><div class="line"></div><div class="line">GeomAPI_Interpolate Interp(Points, Standard_False, </div><div class="line">                                    Precision::Confusion()); </div></div><!-- fragment --><p>It is possible to call the BSpline curve from the object defined above it. </p><div class="fragment"><div class="line">Handle(Geom_BSplineCurve) C = Interp.Curve(); </div></div><!-- fragment --><p> Note that the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(Geom_BSplineCurve)</a></em> operator has been redefined by the method <em>Curve()</em>. Thus, it is unnecessary to pass via the construction of an intermediate object of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___interpolate.html">GeomAPI_Interpolate</a></em> type and the following syntax is correct.</p>
<p><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(Geom_BSplineCurve)</a> C = <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___interpolate.html">GeomAPI_Interpolate</a>(Points, Standard_False, 1.0e-7);</p>
<p>Boundary conditions may be imposed with the method Load. </p><div class="fragment"><div class="line">GeomAPI_Interpolate AnInterpolator </div><div class="line">(Points, Standard_False, 1.0e-5); </div><div class="line">AnInterpolator.Load (StartingTangent, EndingTangent); </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_2_4"></a>
Lines and  Circles from Constraints</h2>
<h3><a class="anchor" id="occt_modalg_2_4_1"></a>
Types of constraints</h3>
<p>The algorithms for construction of 2D circles or lines can be described with numeric or geometric constraints in relation to other curves.</p>
<p>These constraints can impose the following :</p><ul>
<li>the radius of a circle,</li>
<li>the angle that a straight line makes with another straight line,</li>
<li>the tangency of a straight line or circle in relation to a curve,</li>
<li>the passage of a straight line or circle through a point,</li>
<li>the circle with center in a point or curve.</li>
</ul>
<p>For example, these algorithms enable to easily construct a circle of a given radius, centered on a straight line and tangential to another circle.</p>
<p>The implemented algorithms are more complex than those provided by the Direct Constructions component for building 2D circles or lines.</p>
<p>The expression of a tangency problem generally leads to several results, according to the relative positions of the solution and the circles or straight lines in relation to which the tangency constraints are expressed. For example, consider the following case of a circle of a given radius (a small one) which is tangential to two secant circles C1 and C2:</p>
<div class="image">
<img src="modeling_algos_image058.png" alt="modeling_algos_image058.png"/>
<div class="caption">
Example of a Tangency Constraint</div></div>
<p> This diagram clearly shows that there are 8 possible solutions.</p>
<p>In order to limit the number of solutions, we can try to express the relative position of the required solution in relation to the circles to which it is tangential. For example, if we specify that the solution is inside the circle C1 and outside the circle C2, only two solutions referenced 3 and 4 on the diagram respond to the problem posed.</p>
<p>These definitions are very easy to interpret on a circle, where it is easy to identify the interior and exterior sides. In fact, for any kind of curve the interior is defined as the left-hand side of the curve in relation to its orientation.</p>
<p>This technique of qualification of a solution, in relation to the curves to which it is tangential, can be used in all algorithms for constructing a circle or a straight line by geometric constraints. Four qualifiers are used:</p><ul>
<li><b>Enclosing</b> &ndash; the solution(s) must enclose the argument;</li>
<li><b>Enclosed</b> &ndash; the solution(s) must be enclosed by the argument;</li>
<li><b>Outside</b> &ndash; the solution(s) and the argument must be external to one another;</li>
<li><b>Unqualified</b> &ndash; the relative position is not qualified, i.e. all solutions apply.</li>
</ul>
<p>It is possible to create expressions using the qualifiers, for example: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosing(C2),  Rad, Tolerance); </div></div><!-- fragment --><p>This expression finds all circles of radius <em>Rad</em>, which are tangent to both circle <em>C1</em> and <em>C2</em>, while <em>C1</em> is outside and <em>C2</em> is inside.</p>
<h3><a class="anchor" id="occt_modalg_2_4_2"></a>
Available types of lines and circles</h3>
<p>The following analytic algorithms using value-handled entities for creation of 2D lines or circles with geometric constraints are available:</p><ul>
<li>circle tangent to three elements (lines, circles, curves, points),</li>
<li>circle tangent to two elements and having a radius,</li>
<li>circle tangent to two elements and centered on a third element,</li>
<li>circle tangent to two elements and centered on a point,</li>
<li>circle tangent to one element and centered on a second,</li>
<li>bisector of two points,</li>
<li>bisector of two lines,</li>
<li>bisector of two circles,</li>
<li>bisector of a line and a point,</li>
<li>bisector of a circle and a point,</li>
<li>bisector of a line and a circle,</li>
<li>line tangent to two elements (points, circles, curves),</li>
<li>line tangent to one element and parallel to a line,</li>
<li>line tangent to one element and perpendicular to a line,</li>
<li>line tangent to one element and forming angle with a line.</li>
</ul>
<h4>Exterior/Interior</h4>
<p>It is not hard to define the interior and exterior of a circle. As is shown in the following diagram, the exterior is indicated by the sense of the binormal, that is to say the right side according to the sense of traversing the circle. The left side is therefore the interior (or &quot;material&quot;).</p>
<div class="image">
<img src="modeling_algos_image006.png" alt="modeling_algos_image006.png"/>
<div class="caption">
Exterior/Interior of a Circle</div></div>
<p> By extension, the interior of a line or any open curve is defined as the left side according to the passing direction, as shown in the following diagram:</p>
<div class="image">
<img src="modeling_algos_image007.png" alt="modeling_algos_image007.png"/>
<div class="caption">
Exterior/Interior of a Line and a Curve</div></div>
 <h4>Orientation of a Line</h4>
<p>It is sometimes necessary to define in advance the sense of travel along a line to be created. This sense will be from first to second argument.</p>
<p>The following figure shows a line, which is first tangent to circle C1 which is interior to the line, and then passes through point P1.</p>
<div class="image">
<img src="modeling_algos_image008.png" alt="modeling_algos_image008.png"/>
<div class="caption">
An Oriented Line</div></div>
<h4>Line tangent to two circles</h4>
<p>The following four diagrams illustrate four cases of using qualifiers in the creation of a line. The fifth shows the solution if no qualifiers are given.</p>
<p><b>Example 1 Case 1</b></p>
<div class="image">
<img src="modeling_algos_image009.png" alt="modeling_algos_image009.png"/>
<div class="caption">
Both circles outside</div></div>
<p> Constraints: Tangent and Exterior to C1. Tangent and Exterior to C2.</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Outside(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 2</b></p>
<div class="image">
<img src="modeling_algos_image010.png" alt="modeling_algos_image010.png"/>
<div class="caption">
Both circles enclosed</div></div>
<p> Constraints: Tangent and Including C1. Tangent and Including C2.</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Enclosing(C1), </div><div class="line">        GccEnt::Enclosing(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 3</b></p>
<div class="image">
<img src="modeling_algos_image011.png" alt="modeling_algos_image011.png"/>
<div class="caption">
C1 enclosed and C2 outside</div></div>
<p> Constraints: Tangent and Including C1. Tangent and Exterior to C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Enclosing(C1), </div><div class="line">        GccEnt::Outside(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 4</b></p>
<div class="image">
<img src="modeling_algos_image012.png" alt="modeling_algos_image012.png"/>
<div class="caption">
C1 outside and C2 enclosed</div></div>
<p>Constraints: Tangent and Exterior to C1. Tangent and Including C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosing(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 5</b></p>
<div class="image">
<img src="modeling_algos_image013.png" alt="modeling_algos_image013.png"/>
<div class="caption">
Without qualifiers</div></div>
<p> Constraints: Tangent and Undefined with respect to C1. Tangent and Undefined with respect to C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Unqualified(C1), </div><div class="line">        GccEnt::Unqualified(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><h4>Circle of given radius tangent to two circles</h4>
<p>The following four diagrams show the four cases in using qualifiers in the creation of a circle.</p>
<p><b>Example 2 Case 1</b> </p><div class="image">
<img src="modeling_algos_image014.png" alt="modeling_algos_image014.png"/>
<div class="caption">
Both solutions outside</div></div>
<p> Constraints: Tangent and Exterior to C1. Tangent and Exterior to C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">    GccEnt::Outside(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 2</b></p>
<div class="image">
<img src="modeling_algos_image015.png" alt="modeling_algos_image015.png"/>
<div class="caption">
C2 encompasses C1</div></div>
<p> Constraints: Tangent and Exterior to C1. Tangent and Included by C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosed(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 3</b> </p><div class="image">
<img src="modeling_algos_image016.png" alt="modeling_algos_image016.png"/>
<div class="caption">
Solutions enclose C2</div></div>
<p> Constraints: Tangent and Exterior to C1. Tangent and Including C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosing(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 4</b> </p><div class="image">
<img src="modeling_algos_image017.png" alt="modeling_algos_image017.png"/>
<div class="caption">
Solutions enclose C1</div></div>
<p> Constraints: Tangent and Enclosing C1. Tangent and Enclosing C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Enclosing(C1), </div><div class="line">        GccEnt::Enclosing(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 5</b></p>
<p>The following syntax will give all the circles of radius <em>Rad</em>, which are tangent to <em>C1</em> and <em>C2</em> without discrimination of relative position:</p>
<div class="fragment"><div class="line">GccAna_Circ2d2TanRad  Solver(GccEnt::Unqualified(C1), </div><div class="line">                            GccEnt::Unqualified(C2), </div><div class="line">                            Rad,Tolerance); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_4_3"></a>
Types of  algorithms</h3>
<p>OCCT implements several categories of algorithms:</p>
<ul>
<li><b>Analytic</b> algorithms, where solutions are obtained by the resolution of an equation, such algorithms are used when the geometries which are worked on (tangency arguments, position of the center, etc.) are points, lines or circles;</li>
<li><b>Geometric</b> algorithms, where the solution is generally obtained by calculating the intersection of parallel or bisecting curves built from geometric arguments;</li>
<li><b>Iterative</b> algorithms, where the solution is obtained by a process of iteration.</li>
</ul>
<p>For each kind of geometric construction of a constrained line or circle, OCCT provides two types of access:</p>
<ul>
<li>algorithms from the package <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a> </em> automatically select the algorithm best suited to the problem, both in the general case and in all types of specific cases; the used arguments are <em>Geom2d</em> objects, while the computed solutions are <em> gp </em> objects;</li>
<li>algorithms from the package <em> GccAna</em> resolve the problem analytically, and can only be used when the geometries to be worked on are lines or circles; both the used arguments and the computed solutions are <em> gp </em> objects.</li>
</ul>
<p>The provided algorithms compute all solutions, which correspond to the stated geometric problem, unless the solution is found by an iterative algorithm.</p>
<p>Iterative algorithms compute only one solution, closest to an initial position. They can be used in the following cases:</p><ul>
<li>to build a circle, when an argument is more complex than a line or a circle, and where the radius is not known or difficult to determine: this is the case for a circle tangential to three geometric elements, or tangential to two geometric elements and centered on a curve;</li>
<li>to build a line, when a tangency argument is more complex than a line or a circle.</li>
</ul>
<p>Qualified curves (for tangency arguments) are provided either by:</p><ul>
<li>the <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_gcc_ent.html">GccEnt</a></em> package, for direct use by <em> GccAna</em> algorithms, or</li>
<li>the <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a> </em> package, for general use by <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a> </em> algorithms.</li>
</ul>
<p>The <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_gcc_ent.html">GccEnt</a></em> and <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a></em> packages also provide simple functions for building qualified curves in a very efficient way.</p>
<p>The <em> GccAna </em>package also provides algorithms for constructing bisecting loci between circles, lines or points. Bisecting loci between two geometric objects are such that each of their points is at the same distance from the two geometric objects. They are typically curves, such as circles, lines or conics for <em> GccAna</em> algorithms. Each elementary solution is given as an elementary bisecting locus object (line, circle, ellipse, hyperbola, parabola), described by the <em>GccInt</em> package.</p>
<p>Note: Curves used by <em>GccAna</em> algorithms to define the geometric problem to be solved, are 2D lines or circles from the <em> gp</em> package: they are not explicitly parameterized. However, these lines or circles retain an implicit parameterization, corresponding to that which they induce on equivalent Geom2d objects. This induced parameterization is the one used when returning parameter values on such curves, for instance with the functions <em> Tangency1, Tangency2, Tangency3, Intersection2</em> and <em> CenterOn3</em> provided by construction algorithms from the <em> GccAna </em> or <em> <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a></em> packages.</p>
<h2><a class="anchor" id="occt_modalg_2_5"></a>
Curves and Surfaces from Constraints</h2>
<p>The Curves and Surfaces from Constraints component groups together high level functions used in 2D and 3D geometry for:</p><ul>
<li>creation of faired and minimal variation 2D curves</li>
<li>construction of ruled surfaces</li>
<li>construction of pipe surfaces</li>
<li>filling of surfaces</li>
<li>construction of plate surfaces</li>
<li>extension of a 3D curve or surface beyond its original bounds.</li>
</ul>
<p>OPEN CASCADE company also provides a product known as <a href="https://www.opencascade.com/content/surfaces-scattered-points">Surfaces from Scattered Points</a>, which allows constructing surfaces from scattered points. This algorithm accepts or constructs an initial B-Spline surface and looks for its deformation (finite elements method) which would satisfy the constraints. Using optimized computation methods, this algorithm is able to construct a surface from more than 500 000 points.</p>
<p>SSP product is not supplied with Open CASCADE Technology, but can be purchased separately.</p>
<h3><a class="anchor" id="occt_modalg_2_5_1"></a>
Faired and Minimal Variation 2D Curves</h3>
<p>Elastic beam curves have their origin in traditional methods of modeling applied in boat-building, where a long thin piece of wood, a lathe, was forced to pass between two sets of nails and in this way, take the form of a curve based on the two points, the directions of the forces applied at those points, and the properties of the wooden lathe itself.</p>
<p>Maintaining these constraints requires both longitudinal and transversal forces to be applied to the beam in order to compensate for its internal elasticity. The longitudinal forces can be a push or a pull and the beam may or may not be allowed to slide over these fixed points.</p>
<h4>Batten Curves</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_fair_curve___batten.html">FairCurve_Batten</a></em> allows producing faired curves defined on the basis of one or more constraints on each of the two reference points. These include point, angle of tangency and curvature settings. The following constraint orders are available:</p>
<ul>
<li>0 the curve must pass through a point</li>
<li>1 the curve must pass through a point and have a given tangent</li>
<li>2 the curve must pass through a point, have a given tangent and a given curvature.</li>
</ul>
<p>Only 0 and 1 constraint orders are used. The function Curve returns the result as a 2D BSpline curve.</p>
<h4>Minimal Variation Curves</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_fair_curve___minimal_variation.html">FairCurve_MinimalVariation</a></em> allows producing curves with minimal variation in curvature at each reference point. The following constraint orders are available:</p>
<ul>
<li>0 the curve must pass through a point</li>
<li>1 the curve must pass through a point and have a given tangent</li>
<li>2 the curve must pass through a point, have a given tangent and a given curvature.</li>
</ul>
<p>Constraint orders of 0, 1 and 2 can be used. The algorithm minimizes tension, sagging and jerk energy.</p>
<p>The function <em>Curve</em> returns the result as a 2D BSpline curve.</p>
<p>If you want to give a specific length to a batten curve, use:</p>
<div class="fragment"><div class="line">b.SetSlidingFactor(L / b.SlidingOfReference()) </div></div><!-- fragment --><p> where <em>b</em> is the name of the batten curve object</p>
<p>Free sliding is generally more aesthetically pleasing than constrained sliding. However, the computation can fail with values such as angles greater than <em>p/2</em> because in this case the length is theoretically infinite.</p>
<p>In other cases, when sliding is imposed and the sliding factor is too large, the batten can collapse.</p>
<p>The constructor parameters, <em>Tolerance</em> and <em>NbIterations</em>, control how precise the computation is, and how long it will take.</p>
<h3><a class="anchor" id="occt_modalg_2_5_2"></a>
Ruled Surfaces</h3>
<p>A ruled surface is built by ruling a line along the length of two curves.</p>
<h4>Creation of Bezier surfaces</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___bezier_curves.html">GeomFill_BezierCurves</a></em> allows producing a Bezier surface from contiguous Bezier curves. Note that problems may occur with rational Bezier Curves.</p>
<h4>Creation of BSpline surfaces</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___b_spline_curves.html">GeomFill_BSplineCurves</a></em> allows producing a BSpline surface from contiguous BSpline curves. Note that problems may occur with rational BSplines.</p>
<h3><a class="anchor" id="occt_modalg_2_5_3"></a>
Pipe Surfaces</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___pipe.html">GeomFill_Pipe</a></em> allows producing a pipe by sweeping a curve (the section) along another curve (the path). The result is a BSpline surface.</p>
<p>The following types of construction are available:</p><ul>
<li>pipes with a circular section of constant radius,</li>
<li>pipes with a constant section,</li>
<li>pipes with a section evolving between two given curves.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_2_5_4"></a>
Filling a contour</h3>
<p>It is often convenient to create a surface from some curves, which will form the boundaries that define the new surface. This is done by the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___constrained_filling.html">GeomFill_ConstrainedFilling</a></em>, which allows filling a contour defined by three or four curves as well as by tangency constraints. The resulting surface is a BSpline.</p>
<p>A case in point is the intersection of two fillets at a corner. If the radius of the fillet on one edge is different from that of the fillet on another, it becomes impossible to sew together all the edges of the resulting surfaces. This leaves a gap in the overall surface of the object which you are constructing.</p>
<div class="image">
<img src="modeling_algos_image059.png" alt="modeling_algos_image059.png"/>
<div class="caption">
Intersecting filleted edges with differing radiuses</div></div>
<p> These algorithms allow you to fill this gap from two, three or four curves. This can be done with or without constraints, and the resulting surface will be either a Bezier or a BSpline surface in one of a range of filling styles.</p>
<h4>Creation of a Boundary</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___simple_bound.html">GeomFill_SimpleBound</a></em> allows you defining a boundary for the surface to be constructed.</p>
<h4>Creation of a Boundary with an adjoining surface</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___bound_with_surf.html">GeomFill_BoundWithSurf</a></em> allows defining a boundary for the surface to be constructed. This boundary will already be joined to another surface.</p>
<h4>Filling styles</h4>
<p>The enumerations <em>FillingStyle</em> specify the styles used to build the surface. These include:</p>
<ul>
<li><em>Stretch</em> &ndash; the style with the flattest patches</li>
<li><em>Coons</em> &ndash; a rounded style with less depth than <em>Curved</em></li>
<li><em>Curved</em> &ndash; the style with the most rounded patches.</li>
</ul>
<div class="image">
<img src="modeling_algos_image018.png" alt="modeling_algos_image018.png"/>
<div class="caption">
Intersecting filleted edges with different radii leave a gap filled by a surface</div></div>
 <h3><a class="anchor" id="occt_modalg_2_5_5"></a>
Plate surfaces</h3>
<p>In CAD, it is often necessary to generate a surface which has no exact mathematical definition, but which is defined by respective constraints. These can be of a mathematical, a technical or an aesthetic order.</p>
<p>Essentially, a plate surface is constructed by deforming a surface so that it conforms to a given number of curve or point constraints. In the figure below, you can see four segments of the outline of the plane, and a point which have been used as the curve constraints and the point constraint respectively. The resulting surface can be converted into a BSpline surface by using the function <em> MakeApprox </em>.</p>
<p>The surface is built using a variational spline algorithm. It uses the principle of deformation of a thin plate by localised mechanical forces. If not already given in the input, an initial surface is calculated. This corresponds to the plate prior to deformation. Then, the algorithm is called to calculate the final surface. It looks for a solution satisfying constraints and minimizing energy input.</p>
<div class="image">
<img src="modeling_algos_image061.png" alt="modeling_algos_image061.png"/>
<div class="caption">
Surface generated from two curves and a point</div></div>
<p> The package <em>GeomPlate</em> provides the following services for creating surfaces respecting curve and point constraints:</p>
<h4>Definition of a Framework</h4>
<p>The class <em>BuildPlateSurface</em> allows creating a framework to build surfaces according to curve and point constraints as well as tolerance settings. The result is returned with the function <em>Surface</em>.</p>
<p>Note that you do not have to specify an initial surface at the time of construction. It can be added later or, if none is loaded, a surface will be computed automatically.</p>
<h4>Definition of a Curve Constraint</h4>
<p>The class <em>CurveConstraint</em> allows defining curves as constraints to the surface, which you want to build.</p>
<h4>Definition of a Point Constraint</h4>
<p>The class <em>PointConstraint</em> allows defining points as constraints to the surface, which you want to build.</p>
<h4>Applying <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a> to Plate Surfaces</h4>
<p>The class <em>Surface</em> allows describing the characteristics of plate surface objects returned by <b>BuildPlateSurface::Surface</b> using the methods of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em></p>
<h4>Approximating a Plate surface to a BSpline</h4>
<p>The class <em>MakeApprox</em> allows converting a <em>GeomPlate</em> surface into a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___b_spline_surface.html">Geom_BSplineSurface</a></em>.</p>
<div class="image">
<img src="modeling_algos_image060.png" alt="modeling_algos_image060.png"/>
<div class="caption">
Surface generated from four curves and a point</div></div>
<p> Let us create a Plate surface and approximate it from a polyline as a curve constraint and a point constraint</p>
<div class="fragment"><div class="line">Standard_Integer NbCurFront=4, </div><div class="line">NbPointConstraint=1; </div><div class="line">gp_Pnt P1(0.,0.,0.); </div><div class="line">gp_Pnt P2(0.,10.,0.); </div><div class="line">gp_Pnt P3(0.,10.,10.); </div><div class="line">gp_Pnt P4(0.,0.,10.); </div><div class="line">gp_Pnt P5(5.,5.,5.); </div><div class="line">BRepBuilderAPI_MakePolygon W; </div><div class="line">W.Add(P1); </div><div class="line">W.Add(P2); </div><div class="line">W.Add(P3); </div><div class="line">W.Add(P4); </div><div class="line">W.Add(P1); </div><div class="line">// Initialize a BuildPlateSurface </div><div class="line">GeomPlate_BuildPlateSurface BPSurf(3,15,2); </div><div class="line">// Create the curve constraints </div><div class="line">BRepTools_WireExplorer anExp; </div><div class="line">for(anExp.Init(W); anExp.More(); anExp.Next()) </div><div class="line">{ </div><div class="line">TopoDS_Edge E = anExp.Current(); </div><div class="line">Handle(BRepAdaptor_HCurve) C = new </div><div class="line">BRepAdaptor_HCurve(); </div><div class="line">C-ChangeCurve().Initialize(E); </div><div class="line">Handle(BRepFill_CurveConstraint) Cont= new </div><div class="line">BRepFill_CurveConstraint(C,0); </div><div class="line">BPSurf.Add(Cont); </div><div class="line">} </div><div class="line">// Point constraint </div><div class="line">Handle(GeomPlate_PointConstraint) PCont= new </div><div class="line">GeomPlate_PointConstraint(P5,0); </div><div class="line">BPSurf.Add(PCont); </div><div class="line">// Compute the Plate surface </div><div class="line">BPSurf.Perform(); </div><div class="line">// Approximation of the Plate surface </div><div class="line">Standard_Integer MaxSeg=9; </div><div class="line">Standard_Integer MaxDegree=8; </div><div class="line">Standard_Integer CritOrder=0; </div><div class="line">Standard_Real dmax,Tol; </div><div class="line">Handle(GeomPlate_Surface) PSurf = BPSurf.Surface(); </div><div class="line">dmax = Max(0.0001,10*BPSurf.G0Error()); </div><div class="line">Tol=0.0001; </div><div class="line">GeomPlate_MakeApprox </div><div class="line">Mapp(PSurf,Tol,MaxSeg,MaxDegree,dmax,CritOrder); </div><div class="line">Handle (Geom_Surface) Surf (Mapp.Surface()); </div><div class="line">// create a face corresponding to the approximated Plate </div><div class="line">Surface </div><div class="line">Standard_Real Umin, Umax, Vmin, Vmax; </div><div class="line">PSurf-&gt;Bounds( Umin, Umax, Vmin, Vmax); </div><div class="line">BRepBuilderAPI_MakeFace MF(Surf,Umin, Umax, Vmin, Vmax); </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_2_6"></a>
Projections</h2>
<p>Projections provide for computing the following:</p><ul>
<li>the projections of a 2D point onto a 2D curve</li>
<li>the projections of a 3D point onto a 3D curve or surface</li>
<li>the projection of a 3D curve onto a surface.</li>
<li>the planar curve transposition from the 3D to the 2D parametric space of an underlying plane and v. s.</li>
<li>the positioning of a 2D gp object in the 3D geometric space.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_2_6_1"></a>
Projection of a 2D Point on a Curve</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> allows calculation of all normals projected from a point (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a></em>) onto a geometric curve (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>). The calculation may be restricted to a given domain.</p>
<div class="image">
<img src="modeling_algos_image020.png" alt="modeling_algos_image020.png"/>
<div class="caption">
Normals from a point to a curve</div></div>
<p> The curve does not have to be a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___trimmed_curve.html">Geom2d_TrimmedCurve</a></em>. The algorithm will function with any class inheriting <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>.</p>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> may be instantiated as in the following example:</p>
<div class="fragment"><div class="line">gp_Pnt2d P; </div><div class="line">Handle(Geom2d_BezierCurve) C = </div><div class="line">    new  Geom2d_BezierCurve(args); </div><div class="line">Geom2dAPI_ProjectPointOnCurve Projector (P, C); </div></div><!-- fragment --><p>To restrict the search for normals to a given domain <em>[U1,U2]</em>, use the following constructor: </p><div class="fragment"><div class="line">Geom2dAPI_ProjectPointOnCurve Projector (P, C, U1, U2); </div></div><!-- fragment --><p> Having thus created the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> object, we can now interrogate it.</p>
<h4>Calling the number of solution points</h4>
<div class="fragment"><div class="line">Standard_Integer NumSolutions = Projector.NbPoints(); </div></div><!-- fragment --><h4>Calling the location of a solution point</h4>
<p>The solutions are indexed in a range from <em>1</em> to <em>Projector.NbPoints()</em>. The point, which corresponds to a given <em>Index</em> may be found: </p><div class="fragment"><div class="line">gp_Pnt2d Pn = Projector.Point(Index); </div></div><!-- fragment --><h4>Calling the parameter of a solution point</h4>
<p>For a given point corresponding to a given <em>Index</em>:</p>
<div class="fragment"><div class="line">Standard_Real U = Projector.Parameter(Index); </div></div><!-- fragment --><p>This can also be programmed as:</p>
<div class="fragment"><div class="line">Standard_Real U; </div><div class="line">Projector.Parameter(Index,U); </div></div><!-- fragment --><h4>Calling the distance between the start and end points</h4>
<p>We can find the distance between the initial point and a point, which corresponds to the given <em>Index</em>:</p>
<div class="fragment"><div class="line">Standard_Real D = Projector.Distance(Index); </div></div><!-- fragment --><h4>Calling the nearest solution point</h4>
<p>This class offers a method to return the closest solution point to the starting point. This solution is accessed as follows: </p><div class="fragment"><div class="line">gp_Pnt2d P1 = Projector.NearestPoint(); </div></div><!-- fragment --><h4>Calling the parameter of the nearest solution point</h4>
<div class="fragment"><div class="line">Standard_Real U = Projector.LowerDistanceParameter(); </div></div><!-- fragment --><h4>Calling the minimum distance from the point to the curve</h4>
<div class="fragment"><div class="line">Standard_Real D = Projector.LowerDistance(); </div></div><!-- fragment --><h4>Redefined operators</h4>
<p>Some operators have been redefined to find the closest solution.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real()</a></em> returns the minimum distance from the point to the curve.</p>
<div class="fragment"><div class="line">Standard_Real D = Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer()</a></em> returns the number of solutions.</p>
<div class="fragment"><div class="line">Standard_Integer N = </div><div class="line">Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d()</a></em> returns the nearest solution point.</p>
<div class="fragment"><div class="line">gp_Pnt2d P1 = Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p>Using these operators makes coding easier when you only need the nearest point. Thus: </p><div class="fragment"><div class="line">Geom2dAPI_ProjectPointOnCurve Projector (P, C); </div><div class="line">gp_Pnt2d P1 = Projector.NearestPoint(); </div></div><!-- fragment --><p> can be written more concisely as: </p><div class="fragment"><div class="line">gp_Pnt2d P1 = Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p> However, note that in this second case no intermediate <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> object is created, and thus it is impossible to have access to other solution points.</p>
<h4>Access to lower-level functionalities</h4>
<p>If you want to use the wider range of functionalities available from the <em>Extrema</em> package, a call to the <em>Extrema()</em> method will return the algorithmic object for calculating extrema. For example:</p>
<div class="fragment"><div class="line">Extrema_ExtPC2d&amp; TheExtrema = Projector.Extrema(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_6_2"></a>
Projection of a 3D Point on a Curve</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> is instantiated as in the following example:</p>
<div class="fragment"><div class="line">gp_Pnt P; </div><div class="line">Handle(Geom_BezierCurve) C = </div><div class="line">    new  Geom_BezierCurve(args); </div><div class="line">GeomAPI_ProjectPointOnCurve Projector (P, C); </div></div><!-- fragment --><p>If you wish to restrict the search for normals to the given domain [U1,U2], use the following constructor:</p>
<div class="fragment"><div class="line">GeomAPI_ProjectPointOnCurve Projector (P, C, U1, U2); </div></div><!-- fragment --><p> Having thus created the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> object, you can now interrogate it.</p>
<h4>Calling the number of solution points</h4>
<div class="fragment"><div class="line">Standard_Integer NumSolutions = Projector.NbPoints(); </div></div><!-- fragment --><h4>Calling the location of a solution point</h4>
<p>The solutions are indexed in a range from 1 to <em>Projector.NbPoints()</em>. The point, which corresponds to a given index, may be found: </p><div class="fragment"><div class="line">gp_Pnt Pn = Projector.Point(Index); </div></div><!-- fragment --><h4>Calling the parameter of a solution point</h4>
<p>For a given point corresponding to a given index:</p>
<div class="fragment"><div class="line">Standard_Real U = Projector.Parameter(Index); </div></div><!-- fragment --><p>This can also be programmed as: </p><div class="fragment"><div class="line">Standard_Real U; </div><div class="line">Projector.Parameter(Index,U); </div></div><!-- fragment --><h4>Calling the distance between the start and end point</h4>
<p>The distance between the initial point and a point, which corresponds to a given index, may be found: </p><div class="fragment"><div class="line">Standard_Real D = Projector.Distance(Index); </div></div><!-- fragment --><h4>Calling the nearest solution point</h4>
<p>This class offers a method to return the closest solution point to the starting point. This solution is accessed as follows: </p><div class="fragment"><div class="line">gp_Pnt P1 = Projector.NearestPoint(); </div></div><!-- fragment --><h4>Calling the parameter of the nearest solution point</h4>
<div class="fragment"><div class="line">Standard_Real U = Projector.LowerDistanceParameter(); </div></div><!-- fragment --><h4>Calling the minimum distance from the point to the curve</h4>
<div class="fragment"><div class="line">Standard_Real D =  Projector.LowerDistance(); </div></div><!-- fragment --><h4>Redefined operators</h4>
<p>Some operators have been redefined to find the nearest solution.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real()</a></em> returns the minimum distance from the point to the curve.</p>
<div class="fragment"><div class="line">Standard_Real D = GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer()</a></em> returns the number of solutions. </p><div class="fragment"><div class="line">Standard_Integer N =  GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d()</a></em> returns the nearest solution point.</p>
<div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p> Using these operators makes coding easier when you only need the nearest point. In this way,</p>
<div class="fragment"><div class="line">GeomAPI_ProjectPointOnCurve Projector (P, C); </div><div class="line">gp_Pnt P1 = Projector.NearestPoint(); </div></div><!-- fragment --><p>can be written more concisely as: </p><div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p> In the second case, however, no intermediate <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> object is created, and it is impossible to access other solutions points.</p>
<h4>Access to lower-level functionalities</h4>
<p>If you want to use the wider range of functionalities available from the <em>Extrema</em> package, a call to the <em>Extrema()</em> method will return the algorithmic object for calculating the extrema. For example:</p>
<div class="fragment"><div class="line">Extrema_ExtPC&amp; TheExtrema = Projector.Extrema(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_6_3"></a>
Projection of a Point on a Surface</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> allows calculation of all normals projected from a point from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a></em> onto a geometric surface from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em>.</p>
<div class="image">
<img src="modeling_algos_image021.png" alt="modeling_algos_image021.png"/>
<div class="caption">
Projection of normals from a point to a surface</div></div>
<p> Note that the surface does not have to be of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___rectangular_trimmed_surface.html">Geom_RectangularTrimmedSurface</a></em> type. The algorithm will function with any class inheriting <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em>.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> is instantiated as in the following example: </p><div class="fragment"><div class="line">gp_Pnt P; </div><div class="line">Handle (Geom_Surface) S = new Geom_BezierSurface(args); </div><div class="line">GeomAPI_ProjectPointOnSurf Proj (P, S); </div></div><!-- fragment --><p>To restrict the search for normals within the given rectangular domain [U1, U2, V1, V2], use the constructor <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a> Proj (P, S, U1, U2, V1, V2)</em></p>
<p>The values of <em>U1, U2, V1</em> and <em>V2</em> lie at or within their maximum and minimum limits, i.e.: </p><div class="fragment"><div class="line">Umin &lt;=  U1 &lt; U2 &lt;= Umax </div><div class="line">Vmin &lt;=  V1 &lt; V2 &lt;= Vmax </div></div><!-- fragment --><p> Having thus created the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> object, you can interrogate it.</p>
<h4>Calling the number of solution points</h4>
<div class="fragment"><div class="line">Standard_Integer NumSolutions = Proj.NbPoints(); </div></div><!-- fragment --><h4>Calling the location of a solution point</h4>
<p>The solutions are indexed in a range from 1 to <em>Proj.NbPoints()</em>. The point corresponding to the given index may be found:</p>
<div class="fragment"><div class="line">gp_Pnt Pn = Proj.Point(Index); </div></div><!-- fragment --><h4>Calling the parameters of a solution point</h4>
<p>For a given point corresponding to the given index:</p>
<div class="fragment"><div class="line">Standard_Real U,V; </div><div class="line">Proj.Parameters(Index, U, V); </div></div><!-- fragment --><h4>Calling the distance between the start and end point</h4>
<p>The distance between the initial point and a point corresponding to the given index may be found: </p><div class="fragment"><div class="line">Standard_Real D = Projector.Distance(Index); </div></div><!-- fragment --><h4>Calling the nearest solution point</h4>
<p>This class offers a method, which returns the closest solution point to the starting point. This solution is accessed as follows: </p><div class="fragment"><div class="line">gp_Pnt P1 = Proj.NearestPoint(); </div></div><!-- fragment --><h4>Calling the parameters of the nearest solution point</h4>
<div class="fragment"><div class="line">Standard_Real U,V; </div><div class="line">Proj.LowerDistanceParameters (U, V); </div></div><!-- fragment --><h4>Calling the minimum distance from a point to the surface</h4>
<div class="fragment"><div class="line">Standard_Real D = Proj.LowerDistance(); </div></div><!-- fragment --><h4>Redefined operators</h4>
<p>Some operators have been redefined to help you find the nearest solution.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real()</a></em> returns the minimum distance from the point to the surface.</p>
<div class="fragment"><div class="line">Standard_Real D = GeomAPI_ProjectPointOnSurf (P,S); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer()</a></em> returns the number of solutions.</p>
<div class="fragment"><div class="line">Standard_Integer N = GeomAPI_ProjectPointOnSurf (P,S); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d()</a></em> returns the nearest solution point.</p>
<div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnSurf (P,S); </div></div><!-- fragment --><p>Using these operators makes coding easier when you only need the nearest point. In this way,</p>
<div class="fragment"><div class="line">GeomAPI_ProjectPointOnSurface Proj (P, S); </div><div class="line">gp_Pnt P1 = Proj.NearestPoint(); </div></div><!-- fragment --><p>can be written more concisely as:</p>
<div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnSurface (P,S); </div></div><!-- fragment --><p>In the second case, however, no intermediate <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> object is created, and it is impossible to access other solution points.</p>
<h4>Access to lower-level functionalities</h4>
<p>If you want to use the wider range of functionalities available from the <em>Extrema</em> package, a call to the <em>Extrema()</em> method will return the algorithmic object for calculating the extrema as follows:</p>
<div class="fragment"><div class="line">Extrema_ExtPS&amp; TheExtrema = Proj.Extrema(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_12_8"></a>
Switching from 2d and 3d Curves</h3>
<p>The <em>To2d</em> and <em>To3d</em> methods are used to;</p>
<ul>
<li>build a 2d curve from a 3d <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___curve.html">Geom_Curve</a></em> lying on a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pln.html">gp_Pln</a></em> plane</li>
<li>build a 3d curve from a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em> and a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pln.html">gp_Pln</a></em> plane.</li>
</ul>
<p>These methods are called as follows: </p><div class="fragment"><div class="line">Handle(Geom2d_Curve) C2d = GeomAPI::To2d(C3d, Pln); </div><div class="line">Handle(Geom_Curve) C3d = GeomAPI::To3d(C2d, Pln); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_2_topo_tools"></a>
Topological Tools</h1>
<p>Open CASCADE Technology topological tools provide algorithms to</p><ul>
<li>Create wires from edges;</li>
<li>Create faces from wires;</li>
<li>Compute state of the shape relatively other shape;</li>
<li>Orient shapes in container;</li>
<li>Create new shapes from the existing ones;</li>
<li>Build PCurves of edges on the faces;</li>
<li>Check the validity of the shapes;</li>
<li>Take the point in the face;</li>
<li>Get the normal direction for the face.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_1"></a>
Creation of the faces from wireframe model</h2>
<p>It is possible to create the planar faces from the arbitrary set of planar edges randomly located in 3D space. This feature might be useful if you need for instance to restore the shape from the wireframe model: </p><table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_image062.png" alt="modeling_algos_image062.png"/>
<div class="caption">
Wireframe model</div></div>
 </td><td><div class="image">
<img src="modeling_algos_image063.png" alt="modeling_algos_image063.png"/>
<div class="caption">
Faces of the model</div></div>
  </td></tr>
</table>
<p>To make the faces from edges it is, firstly, necessary to create planar wires from the given edges and than create planar faces from each wire. The static methods <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#abf38b2c9278bd3b67033c9f05f60159b">BOPAlgo_Tools::EdgesToWires</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#adaaf99ff3f36d82283eea8fec64b7752">BOPAlgo_Tools::WiresToFaces</a></em> can be used for that: </p><div class="fragment"><div class="line">TopoDS_Shape anEdges = ...; /* The input edges */</div><div class="line">Standard_Real anAngTol = 1.e-8; /* The angular tolerance for distinguishing the planes in which the wires are located */</div><div class="line">Standard_Boolean bShared = Standard_False; /* Defines whether the edges are shared or not */</div><div class="line">//</div><div class="line">TopoDS_Shape aWires; /* resulting wires */</div><div class="line">Standard_Integer iErr = BOPAlgo_Tools::EdgesToWires(anEdges, aWires, bShared, anAngTol);</div><div class="line">if (iErr) {</div><div class="line">  cout &lt;&lt; &quot;Error: Unable to build wires from given edges\n&quot;;</div><div class="line">  return;</div><div class="line">}</div><div class="line">//</div><div class="line">TopoDS_Shape aFaces; /* resulting faces */</div><div class="line">Standard_Boolean bDone = BOPAlgo_Tools::WiresToFaces(aWires, aFaces, anAngTol);</div><div class="line">if (!bDone) {</div><div class="line">  cout &lt;&lt; &quot;Error: Unable to build faces from wires\n&quot;;</div><div class="line">  return;</div><div class="line">}</div></div><!-- fragment --><p>These methods can also be used separately:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#abf38b2c9278bd3b67033c9f05f60159b">BOPAlgo_Tools::EdgesToWires</a></em> allows creating planar wires from edges. The input edges may be not shared, but the output wires will be sharing the coinciding vertices and edges. For this the intersection of the edges is performed. Although, it is possible to skip the intersection stage (if the input edges are already shared) by passing the corresponding flag into the method. The input edges are expected to be planar, but the method does not check it. Thus, if the input edges are not planar, the output wires will also be not planar. In general, the output wires are non-manifold and may contain free vertices, as well as multi-connected vertices.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#adaaf99ff3f36d82283eea8fec64b7752">BOPAlgo_Tools::WiresToFaces</a></em> allows creating planar faces from the planar wires. In general, the input wires are non-manifold and may be not closed, but should share the coinciding parts. The wires located in the same plane and completely included into other wires will create holes in the faces built from outer wires:</li>
</ul>
<table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_image064.png" alt="modeling_algos_image064.png"/>
<div class="caption">
Wireframe model</div></div>
 </td><td><div class="image">
<img src="modeling_algos_image065.png" alt="modeling_algos_image065.png"/>
<div class="caption">
Two faces (red face has a hole)</div></div>
  </td></tr>
</table>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_2"></a>
Classification of the shapes</h2>
<p>The following methods allow classifying the different shapes relatively other shapes:</p><ul>
<li>The variety of the <em>BOPTools_AlgoTools::ComputState</em> methods classify the vertex/edge/face relatively solid;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a4cd7628a627d477005e87eeafbd4a3b7">BOPTools_AlgoTools::IsHole</a></em> classifies wire relatively face;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___tools.html#ae41089ceb30b82099e21b12403efccc2">IntTools_Tools::ClassifyPointByFace</a></em> classifies point relatively face.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_3"></a>
Orientation of the shapes in the container</h2>
<p>The following methods allow reorienting shapes in the containers:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#af6fd9353fc803c7486e33424ba38d6f8">BOPTools_AlgoTools::OrientEdgesOnWire</a></em> correctly orients edges on the wire;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a6bbbb83dfd2bf2e281c5b18ebe3b06a5">BOPTools_AlgoTools::OrientFacesOnShell</a></em> correctly orients faces on the shell.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_4"></a>
Making new shapes</h2>
<p>The following methods allow creating new shapes from the existing ones:</p><ul>
<li>The variety of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#abef4c3e4bd5f2e294aef08f684617531">BOPTools_AlgoTools::MakeNewVertex</a></em> creates the new vertices from other vertices and edges;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a842021c09e30e6791d0b667be9c563ed">BOPTools_AlgoTools::MakeSplitEdge</a></em> splits the edge by the given parameters.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_5"></a>
Building PCurves</h2>
<p>The following methods allow building PCurves of edges on faces:</p><ul>
<li><em>BOPTools_AlgoTools::BuildPCurveForEdgeOnFace</em> computes PCurve for the edge on the face;</li>
<li><em>BOPTools_AlgoTools::BuildPCurveForEdgeOnPlane</em> and <em>BOPTools_AlgoTools::BuildPCurveForEdgesOnPlane</em> allow building PCurves for edges on the planar face;</li>
<li><em>BOPTools_AlgoTools::AttachExistingPCurve</em> takes PCurve on the face from one edge and attach this PCurve to other edge coinciding with the first one.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_6"></a>
Checking the validity of the shapes</h2>
<p>The following methods allow checking the validity of the shapes:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#af88d910ad2d5b0008d998e0008187ca6">BOPTools_AlgoTools::IsMicroEdge</a></em> detects the small edges;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#aa95381613041f0d866db022034d6d5b5">BOPTools_AlgoTools::ComputeTolerance</a></em> computes the correct tolerance of the edge on the face;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a6343494e98622a2b999e293947e92188">BOPTools_AlgoTools::CorrectShapeTolerances</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#acfaaad8fd5c299c703668b2501f01603">BOPTools_AlgoTools::CorrectTolerances</a></em> allow correcting the tolerances of the sub-shapes.</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_lib.html#a8f2ad719749a367a78ebca99a1236850">BRepLib::FindValidRange</a></em> finds a range of 3d curve of the edge not covered by tolerance spheres of vertices.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_7"></a>
Taking a point inside the face</h2>
<p>The following methods allow taking a point located inside the face:</p><ul>
<li>The variety of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#aadfbba81cecf33d882795fbc574846a5">BOPTools_AlgoTools3D::PointNearEdge</a></em> allows getting a point inside the face located near the edge;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#a70d77ef256f521e6a33f9bb21dea87b6">BOPTools_AlgoTools3D::PointInFace</a></em> allows getting a point inside the face.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_8"></a>
Getting normal for the face</h2>
<p>The following methods allow getting the normal direction for the face/surface:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#a53a590daa1fd7d7b7f5cd91577c8d069">BOPTools_AlgoTools3D::GetNormalToSurface</a></em> computes the normal direction for the surface in the given point defined by UV parameters;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#ae2bbf90afb21348df738a5d799f1fe40">BOPTools_AlgoTools3D::GetNormalToFaceOnEdge</a></em> computes the normal direction for the face in the point located on the edge of the face;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#ac7a17a56b15c669d02db76b916cf3474">BOPTools_AlgoTools3D::GetApproxNormalToFaceOnEdge</a></em> computes the normal direction for the face in the point located near the edge of the face.</li>
</ul>
<h1><a class="anchor" id="occt_modalg_3a"></a>
The Topology API</h1>
<p>The Topology API of Open CASCADE Technology (<b>OCCT</b>) includes the following six packages:</p><ul>
<li><em>BRepAlgoAPI</em></li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em></li>
<li><em>BRepFilletAPI</em></li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em></li>
<li><em>BRepOffsetAPI</em></li>
<li><em>BRepPrimAPI</em></li>
</ul>
<p>The classes provided by the API have the following features:</p><ul>
<li>The constructors of classes provide different construction methods;</li>
<li>The class retains different tools used to build objects as fields;</li>
<li>The class provides a casting method to obtain the result automatically with a function-like call.</li>
</ul>
<p>Let us use the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> to create a linear edge from two points.</p>
<div class="fragment"><div class="line">gp_Pnt P1(10,0,0), P2(20,0,0); </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(P1,P2);</div></div><!-- fragment --><p>This is the simplest way to create edge E from two points P1, P2, but the developer can test for errors when he is not as confident of the data as in the previous example.</p>
<div class="fragment"><div class="line">#include &lt;gp_Pnt.hxx&gt; </div><div class="line">#include &lt;TopoDS_Edge.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeEdge.hxx&gt; </div><div class="line">void EdgeTest() </div><div class="line">{ </div><div class="line">gp_Pnt P1; </div><div class="line">gp_Pnt P2; </div><div class="line">BRepBuilderAPI_MakeEdge ME(P1,P2); </div><div class="line">if (!ME.IsDone()) </div><div class="line">{ </div><div class="line">// doing ME.Edge() or E = ME here </div><div class="line">// would raise StdFail_NotDone </div><div class="line">Standard_DomainError::Raise </div><div class="line">(“ProcessPoints::Failed to createan edge”); </div><div class="line">} </div><div class="line">TopoDS_Edge E = ME; </div><div class="line">} </div></div><!-- fragment --><p>In this example an intermediary object ME has been introduced. This can be tested for the completion of the function before accessing the result. More information on <b>error handling</b> in the topology programming interface can be found in the next section.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> provides valuable information. For example, when creating an edge from two points, two vertices have to be created from the points. Sometimes you may be interested in getting these vertices quickly without exploring the new edge. Such information can be provided when using a class. The following example shows a function creating an edge and two vertices from two points.</p>
<div class="fragment"><div class="line">void MakeEdgeAndVertices(const gp_Pnt&amp; P1, </div><div class="line">const gp_Pnt&amp; P2, </div><div class="line">TopoDS_Edge&amp; E, </div><div class="line">TopoDS_Vertex&amp; V1, </div><div class="line">TopoDS_Vertex&amp; V2) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakeEdge ME(P1,P2); </div><div class="line">if (!ME.IsDone()) { </div><div class="line">Standard_DomainError::Raise </div><div class="line">(“MakeEdgeAndVerices::Failed  to create an edge”); </div><div class="line">} </div><div class="line">E = ME; </div><div class="line">V1 = ME.Vextex1(); </div><div class="line">V2 = ME.Vertex2(); </div></div><!-- fragment --><p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> provides two methods <em>Vertex1</em> and <em>Vertex2</em>, which return two vertices used to create the edge.</p>
<p>How can <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> be both a function and a class? It can do this because it uses the casting capabilities of C++. The <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> class has a method called Edge; in the previous example the line <em>E = ME</em> could have been written.</p>
<div class="fragment"><div class="line">E = ME.Edge(); </div></div><!-- fragment --><p>This instruction tells the C++ compiler that there is an <b>implicit casting</b> of a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> into a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> using the <em>Edge</em> method. It means this method is automatically called when a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> is found where a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> is required.</p>
<p>This feature allows you to provide classes, which have the simplicity of function calls when required and the power of classes when advanced processing is necessary. All the benefits of this approach are explained when describing the topology programming interface classes.</p>
<h2><a class="anchor" id="occt_modalg_3a_1"></a>
Error Handling in the Topology API</h2>
<p>A method can report an error in the two following situations:</p><ul>
<li>The data or arguments of the method are incorrect, i.e. they do not respect the restrictions specified by the methods in its specifications. Typical example: creating a linear edge from two identical points is likely to lead to a zero divide when computing the direction of the line.</li>
<li>Something unexpected happened. This situation covers every error not included in the first category. Including: interruption, programming errors in the method or in another method called by the first method, bad specifications of the arguments (i.e. a set of arguments that was not expected to fail).</li>
</ul>
<p>The second situation is supposed to become increasingly exceptional as a system is debugged and it is handled by the <b>exception mechanism</b>. Using exceptions avoids handling error statuses in the call to a method: a very cumbersome style of programming.</p>
<p>In the first situation, an exception is also supposed to be raised because the calling method should have verified the arguments and if it did not do so, there is a bug. For example, if before calling <em>MakeEdge</em> you are not sure that the two points are non-identical, this situation must be tested.</p>
<p>Making those validity checks on the arguments can be tedious to program and frustrating as you have probably correctly surmised that the method will perform the test twice. It does not trust you. As the test involves a great deal of computation, performing it twice is also time-consuming.</p>
<p>Consequently, you might be tempted to adopt the highly inadvisable style of programming illustrated in the following example:</p>
<div class="fragment"><div class="line">#include &lt;Standard_ErrorHandler.hxx&gt; </div><div class="line">try { </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(P1,P2); </div><div class="line">// go on with the edge </div><div class="line">} </div><div class="line">catch { </div><div class="line">// process the error. </div><div class="line">} </div></div><!-- fragment --><p>To help the user, the Topology API classes only raise the exception <em>StdFail_NotDone</em>. Any other exception means that something happened which was unforeseen in the design of this API.</p>
<p>The <em>NotDone</em> exception is only raised when the user tries to access the result of the computation and the original data is corrupted. At the construction of the class instance, if the algorithm cannot be completed, the internal flag <em>NotDone</em> is set. This flag can be tested and in some situations a more complete description of the error can be queried. If the user ignores the <em>NotDone</em> status and tries to access the result, an exception is raised.</p>
<div class="fragment"><div class="line">BRepBuilderAPI_MakeEdge ME(P1,P2); </div><div class="line">if (!ME.IsDone()) { </div><div class="line">// doing ME.Edge() or E = ME here </div><div class="line">// would raise StdFail_NotDone </div><div class="line">Standard_DomainError::Raise </div><div class="line">(“ProcessPoints::Failed to create an edge”); </div><div class="line">} </div><div class="line">TopoDS_Edge E = ME; </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_hist"></a>
History support</h2>
<p>All topological API algorithms support the history of shape modifications (or just History) for their arguments. Generally, the history is available for the following types of sub-shapes of input shapes:</p><ul>
<li>Vertex;</li>
<li>Edge;</li>
<li>Face.</li>
</ul>
<p>Some algorithms also support the history for Solids.</p>
<p>The history information consists of the following information:</p><ul>
<li>Information about Deleted shapes;</li>
<li>Information about Modified shapes;</li>
<li>Information about Generated shapes.</li>
</ul>
<p>The History is filled basing on the result of the operation. History cannot return any shapes not contained in the result. If the result of the operation is an empty shape, all input shapes will be considered as Deleted and none will have Modified and Generated shapes.</p>
<p>The history information can be accessed by the API methods:</p><ul>
<li><em>Standard_Boolean IsDeleted(const TopoDS_Shape&amp; theS)</em> - to check if the shape has been Deleted during the operation;</li>
<li><em>const TopTools_ListOfShape&amp; Modified(const TopoDS_Shape&amp; theS)</em> - to get the shapes Modified from the given shape;</li>
<li><em>const TopTools_ListOfShape&amp; Generated(const TopoDS_Shape&amp; theS)</em> - to get the shapes Generated from the given shape.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_hist_del"></a>
Deleted shapes</h3>
<p>The shape is considered as Deleted during the operation if all of the following conditions are met:</p><ul>
<li>The shape is a part of the argument shapes of the operation;</li>
<li>The result shape does not contain the shape itself;</li>
<li>The result shape does not contain any of the splits of the shape.</li>
</ul>
<p>For example, in the CUT operation between two intersecting solids all vertices/edges/faces located completely inside the Tool solid will be Deleted during the operation.</p>
<h3><a class="anchor" id="occt_modalg_hist_mod"></a>
Modified shapes</h3>
<p>The shape is considered as Modified during the operation if the result shape contains the splits of the shape, not the shape itself. The shape can be modified only into the shapes with the same dimension. The splits of the shape contained in the result shape are Modified from the shape. The Modified shapes are created from the sub-shapes of the input shapes and, generally, repeat their geometry.</p>
<p>The list of Modified elements will contain only those contributing to the result of the operation. If the list is empty, the shape has not been modified and it is necessary to check if it has been Deleted.</p>
<p>For example, after translation of the shape in any direction all its sub-shapes will be modified into their translated copies.</p>
<h3><a class="anchor" id="occt_modalg_hist_gen"></a>
Generated shapes</h3>
<p>The shapes contained in the result shape are considered as Generated from the input shape if they were produced during the operation and have a different dimension from the shapes from which they were created.</p>
<p>The list of Generated elements will contain only those included in the result of the operation. If the list is empty, no new shapes have been Generated from the shape.</p>
<p>For example, extrusion of the edge in some direction will create a face. This face will be generated from the edge.</p>
<h3><a class="anchor" id="occt_modalg_hist_tool"></a>
BRepTools_History</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> is the general History tool intended for unification of the histories of different algorithms.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> can be created from any algorithm supporting the standard history methods *(IsDeleted(), Modified()* and <em>Generated())</em>: </p><div class="fragment"><div class="line">// The arguments of the operation</div><div class="line">TopoDS_Shape aS = ...;</div><div class="line"></div><div class="line">// Perform transformation on the shape</div><div class="line">gp_Trsf aTrsf;</div><div class="line">aTrsf.SetTranslationPart(gp_Vec(0, 0, 1));</div><div class="line">BRepBuilderAPI_Transform aTransformer(aS, aTrsf); // Transformation API algorithm</div><div class="line">const TopoDS_Shape&amp; aRes = aTransformer.Shape();</div><div class="line"></div><div class="line">// Create the translation history object</div><div class="line">TopTools_ListOfShape anArguments;</div><div class="line">anArguments.Append(aS);</div><div class="line">BRepTools_History aHistory(anArguments, aTransformer);</div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> also allows merging histories. Thus, if you have two or more subsequent operations you can get one final history combined from histories of these operations:</p>
<div class="fragment"><div class="line">Handle(BRepTools_History) aHist1 = ...; // History of first operation</div><div class="line">Handle(BRepTools_History) aHist2 = ...; // History of second operation</div></div><!-- fragment --><p>It is possible to merge the second history into the first one: </p><div class="fragment"><div class="line">aHist1-&gt;Merge(aHist2);</div></div><!-- fragment --><p>Or create the new history keeping the two histories unmodified: </p><div class="fragment"><div class="line">Handle(BRepTools_History) aResHistory = new BRepTools_History;</div><div class="line">aResHistory-&gt;Merge(aHist1);</div><div class="line">aResHistory-&gt;Merge(aHist2);</div></div><!-- fragment --><p>The possibilities of Merging histories and history creation from the API algorithms allow providing easy History support for the new algorithms.</p>
<h3><a class="anchor" id="occt_modalg_hist_draw"></a>
DRAW history support</h3>
<p>DRAW History support for the algorithms is provided by three basic commands:</p><ul>
<li><em>isdeleted</em>;</li>
<li><em>modified</em>;</li>
<li><em>generated</em>.</li>
</ul>
<p>For more information on the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> History mechanism, refer to the corresponding chapter in the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> users guide - <a class="el" href="occt_user_guides__test_harness.html#occt_draw_hist">History commands</a>.</p>
<h1><a class="anchor" id="occt_modalg_3"></a>
Standard  Topological Objects</h1>
<p>The following standard topological objects can be created:</p><ul>
<li>Vertices;</li>
<li>Edges;</li>
<li>Faces;</li>
<li>Wires;</li>
<li>Polygonal wires;</li>
<li>Shells;</li>
<li>Solids.</li>
</ul>
<p>There are two root classes for their construction and modification:</p><ul>
<li>The deferred class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html">BRepBuilderAPI_MakeShape</a></em> is the root of all <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> classes, which build shapes. It inherits from the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___command.html">BRepBuilderAPI_Command</a></em> and provides a field to store the constructed shape.</li>
<li>The deferred class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___modify_shape.html">BRepBuilderAPI_ModifyShape</a></em> is used as a root for the shape modifications. It inherits <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html">BRepBuilderAPI_MakeShape</a></em> and implements the methods used to trace the history of all sub-shapes.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_3_1"></a>
Vertex</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_vertex.html">BRepBuilderAPI_MakeVertex</a></em> creates a new vertex from a 3D point from gp. </p><div class="fragment"><div class="line">gp_Pnt P(0,0,10); </div><div class="line">TopoDS_Vertex V = BRepBuilderAPI_MakeVertex(P); </div></div><!-- fragment --><p>This class always creates a new vertex and has no other methods.</p>
<h2><a class="anchor" id="occt_modalg_3_2"></a>
Edge</h2>
<h3><a class="anchor" id="occt_modalg_3_2_1"></a>
Basic edge construction method</h3>
<p>Use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> to create from a curve and vertices. The basic method constructs an edge from a curve, two vertices, and two parameters.</p>
<div class="fragment"><div class="line">Handle(Geom_Curve) C = ...; // a curve </div><div class="line">TopoDS_Vertex V1 = ...,V2 = ...;// two Vertices </div><div class="line">Standard_Real p1 = ..., p2 = ..;// two parameters </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(C,V1,V2,p1,p2); </div></div><!-- fragment --><p>where C is the domain of the edge; V1 is the first vertex oriented FORWARD; V2 is the second vertex oriented REVERSED; p1 and p2 are the parameters for the vertices V1 and V2 on the curve. The default tolerance is associated with this edge.</p>
<div class="image">
<img src="modeling_algos_image022.png" alt="modeling_algos_image022.png"/>
<div class="caption">
Basic Edge Construction</div></div>
<p> The following rules apply to the arguments:</p>
<p><b>The curve</b></p><ul>
<li>Must not be a Null Handle.</li>
<li>If the curve is a trimmed curve, the basis curve is used.</li>
</ul>
<p><b>The vertices</b></p><ul>
<li>Can be null shapes. When V1 or V2 is Null the edge is open in the corresponding direction and the corresponding parameter p1 or p2 must be infinite (i.e p1 is <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___real_8hxx.html#ad3de9dafc2ae3ca21ca628732ae6e209">RealFirst()</a>, p2 is <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___real_8hxx.html#a95979d57361a0a66ceaec655be8757da">RealLast()</a>).</li>
<li>Must be different vertices if they have different 3d locations and identical vertices if they have the same 3d location (identical vertices are used when the curve is closed).</li>
</ul>
<p><b>The parameters</b></p><ul>
<li>Must be increasing and in the range of the curve, i.e.:</li>
</ul>
<div class="fragment"><div class="line">C-&gt;FirstParameter() &lt;=  p1 &lt; p2 &lt;= C-&gt;LastParameter() </div></div><!-- fragment --><ul>
<li>If the parameters are decreasing, the Vertices are switched, i.e. V2 becomes V1 and V1 becomes V2.</li>
<li>On a periodic curve the parameters p1 and p2 are adjusted by adding or subtracting the period to obtain p1 in the range of the curve and p2 in the range p1 &lt; p2 &lt;= p1+ Period. So on a parametric curve p2 can be greater than the second parameter, see the figure below.</li>
<li>Can be infinite but the corresponding vertex must be Null (see above).</li>
<li>The distance between the Vertex 3d location and the point evaluated on the curve with the parameter must be lower than the default precision.</li>
</ul>
<p>The figure below illustrates two special cases, a semi-infinite edge and an edge on a periodic curve.</p>
<div class="image">
<img src="modeling_algos_image023.png" alt="modeling_algos_image023.png"/>
<div class="caption">
Infinite and Periodic Edges</div></div>
 <h3><a class="anchor" id="occt_modalg_3_2_2"></a>
Supplementary edge construction methods</h3>
<p>There exist supplementary edge construction methods derived from the basic one.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> class provides methods, which are all simplified calls of the previous one:</p>
<ul>
<li>The parameters can be omitted. They are computed by projecting the vertices on the curve.</li>
<li>3d points (Pnt from gp) can be given in place of vertices. Vertices are created from the points. Giving vertices is useful when creating connected vertices.</li>
<li>The vertices or points can be omitted if the parameters are given. The points are computed by evaluating the parameters on the curve.</li>
<li>The vertices or points and the parameters can be omitted. The first and the last parameters of the curve are used.</li>
</ul>
<p>The five following methods are thus derived from the basic construction:</p>
<div class="fragment"><div class="line">Handle(Geom_Curve) C = ...; // a curve </div><div class="line">TopoDS_Vertex V1 = ...,V2 = ...;// two Vertices </div><div class="line">Standard_Real p1 = ..., p2 = ..;// two parameters </div><div class="line">gp_Pnt P1 = ..., P2 = ...;// two points </div><div class="line">TopoDS_Edge E; </div><div class="line">// project the vertices on the curve </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,V1,V2); </div><div class="line">// Make vertices from points </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,P1,P2,p1,p2); </div><div class="line">// Make vertices from points and project them </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,P1,P2); </div><div class="line">// Computes the points from the parameters </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,p1,p2); </div><div class="line">// Make an edge from the whole curve </div><div class="line">E = BRepBuilderAPI_MakeEdge(C); </div></div><!-- fragment --><p>Six methods (the five above and the basic method) are also provided for curves from the gp package in place of Curve from Geom. The methods create the corresponding Curve from Geom and are implemented for the following classes:</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___lin.html">gp_Lin</a></em> creates a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___line.html">Geom_Line</a></em> <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___circ.html">gp_Circ</a></em> creates a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___circle.html">Geom_Circle</a></em> <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___elips.html">gp_Elips</a></em> creates a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___ellipse.html">Geom_Ellipse</a></em> <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___hypr.html">gp_Hypr</a></em> creates a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___hyperbola.html">Geom_Hyperbola</a></em> <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___parab.html">gp_Parab</a></em> creates a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___parabola.html">Geom_Parabola</a></em></p>
<p>There are also two methods to construct edges from two vertices or two points. These methods assume that the curve is a line; the vertices or points must have different locations.</p>
<div class="fragment"><div class="line">TopoDS_Vertex V1 = ...,V2 = ...;// two Vertices </div><div class="line">gp_Pnt P1 = ..., P2 = ...;// two points </div><div class="line">TopoDS_Edge E; </div><div class="line"></div><div class="line">// linear edge from two vertices </div><div class="line">E = BRepBuilderAPI_MakeEdge(V1,V2); </div><div class="line"></div><div class="line">// linear edge from two points </div><div class="line">E = BRepBuilderAPI_MakeEdge(P1,P2); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_3_2_3"></a>
Other information and error status</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> can provide extra information and return an error status.</p>
<p>If <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> is used as a class, it can provide two vertices. This is useful when the vertices were not provided as arguments, for example when the edge was constructed from a curve and parameters. The two methods <em>Vertex1</em> and <em>Vertex2</em> return the vertices. Note that the returned vertices can be null if the edge is open in the corresponding direction.</p>
<p>The <em>Error</em> method returns a term of the <em>BRepBuilderAPI_EdgeError</em> enumeration. It can be used to analyze the error when <em>IsDone</em> method returns False. The terms are:</p>
<ul>
<li><b>EdgeDone</b> &ndash; No error occurred, <em>IsDone</em> returns True.</li>
<li><b>PointProjectionFailed</b> &ndash; No parameters were given, but the projection of the 3D points on the curve failed. This happens if the point distance to the curve is greater than the precision.</li>
<li><b>ParameterOutOfRange</b> &ndash; The given parameters are not in the range <em>C-&gt;FirstParameter()</em>, <em>C-&gt;LastParameter()</em></li>
<li><b>DifferentPointsOnClosedCurve</b> &ndash; The two vertices or points have different locations but they are the extremities of a closed curve.</li>
<li><b>PointWithInfiniteParameter</b> &ndash; A finite coordinate point was associated with an infinite parameter (see the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a> package for a definition of infinite values).</li>
<li><b>DifferentsPointAndParameter</b> &ndash; The distance of the 3D point and the point evaluated on the curve with the parameter is greater than the precision.</li>
<li><b>LineThroughIdenticPoints</b> &ndash; Two identical points were given to define a line (construction of an edge without curve), <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp.html#aa61870781423b3eb351676856c99894f">gp::Resolution</a></em> is used to test confusion .</li>
</ul>
<p>The following example creates a rectangle centered on the origin of dimensions H, L with fillets of radius R. The edges and the vertices are stored in the arrays <em>theEdges</em> and <em>theVertices</em>. We use class <em>Array1OfShape</em> (i.e. not arrays of edges or vertices). See the image below.</p>
<div class="image">
<img src="modeling_algos_image024.png" alt="modeling_algos_image024.png"/>
<div class="caption">
Creating a Wire</div></div>
 <div class="fragment"><div class="line">#include &lt;BRepBuilderAPI_MakeEdge.hxx&gt; </div><div class="line">#include &lt;TopoDS_Shape.hxx&gt; </div><div class="line">#include &lt;gp_Circ.hxx&gt; </div><div class="line">#include &lt;gp.hxx&gt; </div><div class="line">#include &lt;TopoDS_Wire.hxx&gt; </div><div class="line">#include &lt;TopTools_Array1OfShape.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeWire.hxx&gt; </div><div class="line"></div><div class="line">// Use MakeArc method to make an edge and two vertices </div><div class="line">void MakeArc(Standard_Real x,Standard_Real y, </div><div class="line">Standard_Real R, </div><div class="line">Standard_Real ang, </div><div class="line">TopoDS_Shape&amp; E, </div><div class="line">TopoDS_Shape&amp; V1, </div><div class="line">TopoDS_Shape&amp; V2) </div><div class="line">{ </div><div class="line">gp_Ax2 Origin = gp::XOY(); </div><div class="line">gp_Vec Offset(x, y, 0.); </div><div class="line">Origin.Translate(Offset); </div><div class="line">BRepBuilderAPI_MakeEdge </div><div class="line">ME(gp_Circ(Origin,R),  ang, ang+PI/2); </div><div class="line">E = ME; </div><div class="line">V1 = ME.Vertex1(); </div><div class="line">V2 = ME.Vertex2(); </div><div class="line">} </div><div class="line"></div><div class="line">TopoDS_Wire MakeFilletedRectangle(const Standard_Real H, </div><div class="line">const Standard_Real L, </div><div class="line">const Standard_Real  R) </div><div class="line">{ </div><div class="line">TopTools_Array1OfShape theEdges(1,8); </div><div class="line">TopTools_Array1OfShape theVertices(1,8); </div><div class="line"></div><div class="line">// First create the circular edges and the vertices </div><div class="line">// using the MakeArc function described above. </div><div class="line">void MakeArc(Standard_Real, Standard_Real, </div><div class="line">Standard_Real, Standard_Real, </div><div class="line">TopoDS_Shape&amp;, TopoDS_Shape&amp;,  TopoDS_Shape&amp;); </div><div class="line"></div><div class="line">Standard_Real x = L/2 - R, y = H/2 - R; </div><div class="line">MakeArc(x,-y,R,3.*PI/2.,theEdges(2),theVertices(2), </div><div class="line">theVertices(3)); </div><div class="line">MakeArc(x,y,R,0.,theEdges(4),theVertices(4), </div><div class="line">theVertices(5)); </div><div class="line">MakeArc(-x,y,R,PI/2.,theEdges(6),theVertices(6), </div><div class="line">theVertices(7)); </div><div class="line">MakeArc(-x,-y,R,PI,theEdges(8),theVertices(8), </div><div class="line">theVertices(1)); </div><div class="line">// Create the linear edges </div><div class="line">for (Standard_Integer i = 1; i &lt;= 7; i += 2) </div><div class="line">{ </div><div class="line">theEdges(i) = BRepBuilderAPI_MakeEdge </div><div class="line">(TopoDS::Vertex(theVertices(i)),TopoDS::Vertex </div><div class="line">(theVertices(i+1))); </div><div class="line">} </div><div class="line">// Create the wire using the BRepBuilderAPI_MakeWire </div><div class="line">BRepBuilderAPI_MakeWire MW; </div><div class="line">for (i = 1; i &lt;= 8; i++) </div><div class="line">{ </div><div class="line">MW.Add(TopoDS::Edge(theEdges(i))); </div><div class="line">} </div><div class="line">return MW.Wire(); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_3_3"></a>
Edge 2D</h2>
<p>Use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge2d.html">BRepBuilderAPI_MakeEdge2d</a></em> class to make edges on a working plane from 2d curves. The working plane is a default value of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> package (see the <em>Plane</em> methods).</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge2d.html">BRepBuilderAPI_MakeEdge2d</a></em> class is strictly similar to <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a>, but it uses 2D geometry from gp and Geom2d instead of 3D geometry.</p>
<h2><a class="anchor" id="occt_modalg_3_4"></a>
Polygon</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> class is used to build polygonal wires from vertices or points. Points are automatically changed to vertices as in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em>.</p>
<p>The basic usage of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> is to create a wire by adding vertices or points using the Add method. At any moment, the current wire can be extracted. The close method can be used to close the current wire. In the following example, a closed wire is created from an array of points.</p>
<div class="fragment"><div class="line">#include &lt;TopoDS_Wire.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakePolygon.hxx&gt; </div><div class="line">#include &lt;TColgp_Array1OfPnt.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Wire ClosedPolygon(const TColgp_Array1OfPnt&amp;  Points) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakePolygon MP; </div><div class="line">for(Standard_Integer i=Points.Lower();i=Points.Upper();i++) </div><div class="line">{ </div><div class="line">MP.Add(Points(i)); </div><div class="line">} </div><div class="line">MP.Close(); </div><div class="line">return MP; </div><div class="line">} </div></div><!-- fragment --><p>Short-cuts are provided for 2, 3, or 4 points or vertices. Those methods have a Boolean last argument to tell if the polygon is closed. The default value is False.</p>
<p>Two examples:</p>
<p>Example of a closed triangle from three vertices: </p><div class="fragment"><div class="line">TopoDS_Wire W =  BRepBuilderAPI_MakePolygon(V1,V2,V3,Standard_True); </div></div><!-- fragment --><p>Example of an open polygon from four points: </p><div class="fragment"><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakePolygon(P1,P2,P3,P4); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> class maintains a current wire. The current wire can be extracted at any moment and the construction can proceed to a longer wire. After each point insertion, the class maintains the last created edge and vertex, which are returned by the methods <em>Edge, FirstVertex</em> and <em>LastVertex</em>.</p>
<p>When the added point or vertex has the same location as the previous one it is not added to the current wire but the most recently created edge becomes Null. The <em>Added</em> method can be used to test this condition. The <em>MakePolygon</em> class never raises an error. If no vertex has been added, the <em>Wire</em> is <em>Null</em>. If two vertices are at the same location, no edge is created.</p>
<h2><a class="anchor" id="occt_modalg_3_5"></a>
Face</h2>
<p>Use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_face.html">BRepBuilderAPI_MakeFace</a></em> class to create a face from a surface and wires. An underlying surface is constructed from a surface and optional parametric values. Wires can be added to the surface. A planar surface can be constructed from a wire. An error status can be returned after face construction.</p>
<h3><a class="anchor" id="occt_modalg_3_5_1"></a>
Basic face construction method</h3>
<p>A face can be constructed from a surface and four parameters to determine a limitation of the UV space. The parameters are optional, if they are omitted the natural bounds of the surface are used. Up to four edges and vertices are created with a wire. No edge is created when the parameter is infinite.</p>
<div class="fragment"><div class="line">Handle(Geom_Surface) S = ...; // a surface </div><div class="line">Standard_Real umin,umax,vmin,vmax; // parameters </div><div class="line">TopoDS_Face F =  BRepBuilderAPI_MakeFace(S,umin,umax,vmin,vmax); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image025.png" alt="modeling_algos_image025.png"/>
<div class="caption">
Basic Face Construction</div></div>
<p> To make a face from the natural boundary of a surface, the parameters are not required:</p>
<div class="fragment"><div class="line">Handle(Geom_Surface) S = ...; // a surface </div><div class="line">TopoDS_Face F = BRepBuilderAPI_MakeFace(S); </div></div><!-- fragment --><p>Constraints on the parameters are similar to the constraints in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em>.</p><ul>
<li><em>umin,umax (vmin,vmax)</em> must be in the range of the surface and must be increasing.</li>
<li>On a <em>U (V)</em> periodic surface <em>umin</em> and <em>umax (vmin,vmax)</em> are adjusted.</li>
<li><em>umin, umax, vmin, vmax</em> can be infinite. There will be no edge in the corresponding direction.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_3_5_2"></a>
Supplementary face construction methods</h3>
<p>The two basic constructions (from a surface and from a surface and parameters) are implemented for all <em>gp</em> package surfaces, which are transformed in the corresponding Surface from Geom.</p>
<table class="doxtable">
<tr>
<th align="left">gp package surface </th><th align="left"></th><th align="left">Geom package surface  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pln.html">gp_Pln</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___plane.html">Geom_Plane</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___cylinder.html">gp_Cylinder</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___cylindrical_surface.html">Geom_CylindricalSurface</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___cone.html">gp_Cone</a></em> </td><td align="left">creates a </td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___conical_surface.html">Geom_ConicalSurface</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___sphere.html">gp_Sphere</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___spherical_surface.html">Geom_SphericalSurface</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___torus.html">gp_Torus</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___toroidal_surface.html">Geom_ToroidalSurface</a></em> </td></tr>
</table>
<p>Once a face has been created, a wire can be added using the <em>Add</em> method. For example, the following code creates a cylindrical surface and adds a wire.</p>
<div class="fragment"><div class="line">gp_Cylinder C = ..; // a cylinder </div><div class="line">TopoDS_Wire W = ...;// a wire </div><div class="line">BRepBuilderAPI_MakeFace MF(C); </div><div class="line">MF.Add(W); </div><div class="line">TopoDS_Face F = MF; </div></div><!-- fragment --><p>More than one wire can be added to a face, provided that they do not cross each other and they define only one area on the surface. (Note that this is not checked). The edges on a Face must have a parametric curve description.</p>
<p>If there is no parametric curve for an edge of the wire on the Face it is computed by projection.</p>
<p>For one wire, a simple syntax is provided to construct the face from the surface and the wire. The above lines could be written:</p>
<div class="fragment"><div class="line">TopoDS_Face F = BRepBuilderAPI_MakeFace(C,W); </div></div><!-- fragment --><p>A planar face can be created from only a wire, provided this wire defines a plane. For example, to create a planar face from a set of points you can use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_face.html">BRepBuilderAPI_MakeFace</a></em>.</p>
<div class="fragment"><div class="line">#include &lt;TopoDS_Face.hxx&gt; </div><div class="line">#include &lt;TColgp_Array1OfPnt.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakePolygon.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeFace.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Face PolygonalFace(const TColgp_Array1OfPnt&amp;  thePnts) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakePolygon MP; </div><div class="line">for(Standard_Integer i=thePnts.Lower(); </div><div class="line">i&lt;=thePnts.Upper(); i++) </div><div class="line">{ </div><div class="line">MP.Add(thePnts(i)); </div><div class="line">} </div><div class="line">MP.Close(); </div><div class="line">TopoDS_Face F = BRepBuilderAPI_MakeFace(MP.Wire()); </div><div class="line">return F; </div><div class="line">} </div></div><!-- fragment --><p>The last use of <em>MakeFace</em> is to copy an existing face to add new wires. For example, the following code adds a new wire to a face:</p>
<div class="fragment"><div class="line">TopoDS_Face F = ...; // a face </div><div class="line">TopoDS_Wire W = ...; // a wire </div><div class="line">F = BRepBuilderAPI_MakeFace(F,W); </div></div><!-- fragment --><p>To add more than one wire an instance of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_face.html">BRepBuilderAPI_MakeFace</a></em> class can be created with the face and the first wire and the new wires inserted with the <em>Add</em> method.</p>
<h3><a class="anchor" id="occt_modalg_3_5_3"></a>
Error status</h3>
<p>The <em>Error</em> method returns an error status, which is a term from the <em>BRepBuilderAPI_FaceError</em> enumeration.</p>
<ul>
<li><em>FaceDone</em> &ndash; no error occurred.</li>
<li><em>NoFace</em> &ndash; no initialization of the algorithm; an empty constructor was used.</li>
<li><em>NotPlanar</em> &ndash; no surface was given and the wire was not planar.</li>
<li><em>CurveProjectionFailed</em> &ndash; no curve was found in the parametric space of the surface for an edge.</li>
<li><em>ParametersOutOfRange</em> &ndash; the parameters <em>umin, umax, vmin, vmax</em> are out of the surface.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_3_6"></a>
Wire</h2>
<p>The wire is a composite shape built not from a geometry, but by the assembly of edges. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_wire.html">BRepBuilderAPI_MakeWire</a></em> class can build a wire from one or more edges or connect new edges to an existing wire.</p>
<p>Up to four edges can be used directly, for example:</p>
<div class="fragment"><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakeWire(E1,E2,E3,E4); </div></div><!-- fragment --><p>For a higher or unknown number of edges the Add method must be used; for example, to build a wire from an array of shapes (to be edges).</p>
<div class="fragment"><div class="line">TopTools_Array1OfShapes theEdges; </div><div class="line">BRepBuilderAPI_MakeWire MW; </div><div class="line">for (Standard_Integer i = theEdge.Lower(); </div><div class="line">i &lt;= theEdges.Upper(); i++) </div><div class="line">MW.Add(TopoDS::Edge(theEdges(i)); </div><div class="line">TopoDS_Wire W = MW; </div></div><!-- fragment --><p>The class can be constructed with a wire. A wire can also be added. In this case, all the edges of the wires are added. For example to merge two wires:</p>
<div class="fragment"><div class="line">#include &lt;TopoDS_Wire.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeWire.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Wire MergeWires (const TopoDS_Wire&amp; W1, </div><div class="line">const  TopoDS_Wire&amp; W2) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakeWire MW(W1); </div><div class="line">MW.Add(W2); </div><div class="line">return MW; </div><div class="line">} </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_wire.html">BRepBuilderAPI_MakeWire</a></em> class connects the edges to the wire. When a new edge is added if one of its vertices is shared with the wire it is considered as connected to the wire. If there is no shared vertex, the algorithm searches for a vertex of the edge and a vertex of the wire, which are at the same location (the tolerances of the vertices are used to test if they have the same location). If such a pair of vertices is found, the edge is copied with the vertex of the wire in place of the original vertex. All the vertices of the edge can be exchanged for vertices from the wire. If no connection is found the wire is considered to be disconnected. This is an error.</p>
<p><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_wire.html">BRepBuilderAPI_MakeWire</a> class can return the last edge added to the wire (Edge method). This edge can be different from the original edge if it was copied.</p>
<p>The Error method returns a term of the <em>BRepBuilderAPI_WireError</em> enumeration: <em>WireDone</em> &ndash; no error occurred. <em>EmptyWire</em> &ndash; no initialization of the algorithm, an empty constructor was used. <em>DisconnectedWire</em> &ndash; the last added edge was not connected to the wire. <em>NonManifoldWire</em> &ndash; the wire with some singularity.</p>
<h2><a class="anchor" id="occt_modalg_3_7"></a>
Shell</h2>
<p>The shell is a composite shape built not from a geometry, but by the assembly of faces. Use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shell.html">BRepBuilderAPI_MakeShell</a></em> class to build a Shell from a set of Faces. What may be important is that each face should have the required continuity. That is why an initial surface is broken up into faces.</p>
<h2><a class="anchor" id="occt_modalg_3_8"></a>
Solid</h2>
<p>The solid is a composite shape built not from a geometry, but by the assembly of shells. Use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_solid.html">BRepBuilderAPI_MakeSolid</a></em> class to build a Solid from a set of Shells. Its use is similar to the use of the MakeWire class: shells are added to the solid in the same way that edges are added to the wire in MakeWire.</p>
<h1><a class="anchor" id="occt_modalg_3b"></a>
Object Modification</h1>
<h2><a class="anchor" id="occt_modalg_3b_1"></a>
Transformation</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___transform.html">BRepBuilderAPI_Transform</a></em> class can be used to apply a transformation to a shape (see class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___trsf.html">gp_Trsf</a></em>). The methods have a boolean argument to copy or share the original shape, as long as the transformation allows (it is only possible for direct isometric transformations). By default, the original shape is shared.</p>
<p>The following example deals with the rotation of shapes.</p>
<div class="fragment"><div class="line">TopoDS_Shape myShape1 = ...; </div><div class="line">// The original shape 1 </div><div class="line">TopoDS_Shape myShape2 = ...; </div><div class="line">// The original shape2 </div><div class="line">gp_Trsf T; </div><div class="line">T.SetRotation(gp_Ax1(gp_Pnt(0.,0.,0.),gp_Vec(0.,0.,1.)), </div><div class="line">2.*PI/5.); </div><div class="line">BRepBuilderAPI_Transformation theTrsf(T); </div><div class="line">theTrsf.Perform(myShape1); </div><div class="line">TopoDS_Shape myNewShape1 = theTrsf.Shape() </div><div class="line">theTrsf.Perform(myShape2,Standard_True); </div><div class="line">// Here duplication is forced </div><div class="line">TopoDS_Shape myNewShape2 = theTrsf.Shape() </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_3b_2"></a>
Duplication</h2>
<p>Use the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___copy.html">BRepBuilderAPI_Copy</a></em> class to duplicate a shape. A new shape is thus created. In the following example, a solid is copied:</p>
<div class="fragment"><div class="line">TopoDS Solid MySolid; </div><div class="line">....// Creates a solid </div><div class="line"></div><div class="line">TopoDS_Solid myCopy = BRepBuilderAPI_Copy(mySolid); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_4"></a>
Primitives</h1>
<p>The <em> BRepPrimAPI</em> package provides an API (Application Programming Interface) for construction of primitives such as:</p><ul>
<li>Boxes;</li>
<li>Cones;</li>
<li>Cylinders;</li>
<li>Prisms.</li>
</ul>
<p>It is possible to create partial solids, such as a sphere limited by longitude. In real models, primitives can be used for easy creation of specific sub-parts.</p>
<ul>
<li>Construction by sweeping along a profile:<ul>
<li>Linear;</li>
<li>Rotational (through an angle of rotation).</li>
</ul>
</li>
</ul>
<p>Sweeps are objects obtained by sweeping a profile along a path. The profile can be any topology and the path is usually a curve or a wire. The profile generates objects according to the following rules:</p><ul>
<li>Vertices generate Edges</li>
<li>Edges generate Faces.</li>
<li>Wires generate Shells.</li>
<li>Faces generate Solids.</li>
<li>Shells generate Composite Solids.</li>
</ul>
<p>It is not allowed to sweep Solids and Composite Solids. Swept constructions along complex profiles such as BSpline curves also available in the <em> BRepOffsetAPI </em> package. This API provides simple, high level calls for the most common operations.</p>
<h2><a class="anchor" id="occt_modalg_4_1"></a>
Making  Primitives</h2>
<h3><a class="anchor" id="occt_modalg_4_1_1"></a>
Box</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_box.html">BRepPrimAPI_MakeBox</a></em> allows building a parallelepiped box. The result is either a <b>Shell</b> or a <b>Solid</b>. There are four ways to build a box:</p>
<ul>
<li>From three dimensions <em>dx, dy</em> and <em>dz</em>. The box is parallel to the axes and extends for <em>[0,dx] [0,dy] [0,dz] </em>.</li>
<li>From a point and three dimensions. The same as above but the point is the new origin.</li>
<li>From two points, the box is parallel to the axes and extends on the intervals defined by the coordinates of the two points.</li>
<li>From a system of axes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em> and three dimensions. Same as the first way but the box is parallel to the given system of axes.</li>
</ul>
<p>An error is raised if the box is flat in any dimension using the default precision. The following code shows how to create a box: </p><div class="fragment"><div class="line">TopoDS_Solid theBox = BRepPrimAPI_MakeBox(10.,20.,30.); </div></div><!-- fragment --><p>The four methods to build a box are shown in the figure:</p>
<div class="image">
<img src="modeling_algos_image026.png" alt="modeling_algos_image026.png"/>
<div class="caption">
Making Boxes</div></div>
 <h3><a class="anchor" id="occt_modalg_4_1_2"></a>
Wedge</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_wedge.html">BRepPrimAPI_MakeWedge</a></em> class allows building a wedge, which is a slanted box, i.e. a box with angles. The wedge is constructed in much the same way as a box i.e. from three dimensions dx,dy,dz plus arguments or from an axis system, three dimensions, and arguments.</p>
<p>The following figure shows two ways to build wedges. One is to add a dimension <em>ltx</em>, which is the length in <em>x</em> of the face at <em>dy</em>. The second is to add <em>xmin, xmax, zmin</em> and <em>zmax</em> to describe the face at <em>dy</em>.</p>
<p>The first method is a particular case of the second with <em>xmin = 0, xmax = ltx, zmin = 0, zmax = dz</em>. To make a centered pyramid you can use <em>xmin = xmax = dx / 2, zmin = zmax = dz / 2</em>.</p>
<div class="image">
<img src="modeling_algos_image027.png" alt="modeling_algos_image027.png"/>
<div class="caption">
Making Wedges</div></div>
 <h3><a class="anchor" id="occt_modalg_4_1_3"></a>
Rotation object</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_one_axis.html">BRepPrimAPI_MakeOneAxis</a></em> is a deferred class used as a root class for all classes constructing rotational primitives. Rotational primitives are created by rotating a curve around an axis. They cover the cylinder, the cone, the sphere, the torus, and the revolution, which provides all other curves.</p>
<p>The particular constructions of these primitives are described, but they all have some common arguments, which are:</p>
<ul>
<li>A system of coordinates, where the Z axis is the rotation axis..</li>
<li>An angle in the range [0,2*PI].</li>
<li>A vmin, vmax parameter range on the curve.</li>
</ul>
<p>The result of the OneAxis construction is a Solid, a Shell, or a Face. The face is the face covering the rotational surface. Remember that you will not use the OneAxis directly but one of the derived classes, which provide improved constructions. The following figure illustrates the OneAxis arguments.</p>
<div class="image">
<img src="modeling_algos_image028.png" alt="modeling_algos_image028.png"/>
<div class="caption">
MakeOneAxis arguments</div></div>
 <h3><a class="anchor" id="occt_modalg_4_1_4"></a>
Cylinder</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_cylinder.html">BRepPrimAPI_MakeCylinder</a></em> class allows creating cylindrical primitives. A cylinder is created either in the default coordinate system or in a given coordinate system <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em>. There are two constructions:</p>
<ul>
<li>Radius and height, to build a full cylinder.</li>
<li>Radius, height and angle to build a portion of a cylinder.</li>
</ul>
<p>The following code builds the cylindrical face of the figure, which is a quarter of cylinder along the <em>Y</em> axis with the origin at <em>X,Y,Z</em> the length of <em>DY</em> and radius <em>R</em>.</p>
<div class="fragment"><div class="line">Standard_Real X = 20, Y = 10, Z = 15, R = 10, DY = 30; </div><div class="line">// Make the system of coordinates </div><div class="line">gp_Ax2 axes = gp::ZOX(); </div><div class="line">axes.Translate(gp_Vec(X,Y,Z)); </div><div class="line">TopoDS_Face F = </div><div class="line">BRepPrimAPI_MakeCylinder(axes,R,DY,PI/2.); </div></div><!-- fragment --> <div class="image">
<img src="modeling_algos_image029.png" alt="modeling_algos_image029.png"/>
<div class="caption">
Cylinder</div></div>
 <h3><a class="anchor" id="occt_modalg_4_1_5"></a>
Cone</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_cone.html">BRepPrimAPI_MakeCone</a></em> class allows creating conical primitives. Like a cylinder, a cone is created either in the default coordinate system or in a given coordinate system (<a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a>). There are two constructions:</p>
<ul>
<li>Two radii and height, to build a full cone. One of the radii can be null to make a sharp cone.</li>
<li>Radii, height and angle to build a truncated cone.</li>
</ul>
<p>The following code builds the solid cone of the figure, which is located in the default system with radii <em>R1</em> and <em>R2</em> and height <em>H</em>.</p>
<div class="fragment"><div class="line">Standard_Real R1 = 30, R2 = 10, H = 15; </div><div class="line">TopoDS_Solid S = BRepPrimAPI_MakeCone(R1,R2,H); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image030.png" alt="modeling_algos_image030.png"/>
<div class="caption">
Cone</div></div>
 <h3><a class="anchor" id="occt_modalg_4_1_6"></a>
Sphere</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_sphere.html">BRepPrimAPI_MakeSphere</a></em> class allows creating spherical primitives. Like a cylinder, a sphere is created either in the default coordinate system or in a given coordinate system <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em>. There are four constructions:</p>
<ul>
<li>From a radius &ndash; builds a full sphere.</li>
<li>From a radius and an angle &ndash; builds a lune (digon).</li>
<li>From a radius and two angles &ndash; builds a wraparound spherical segment between two latitudes. The angles <em>a1</em> and <em>a2</em> must follow the relation: <em>PI/2 &lt;= a1 &lt; a2 &lt;= PI/2 </em>.</li>
<li>From a radius and three angles &ndash; a combination of two previous methods builds a portion of spherical segment.</li>
</ul>
<p>The following code builds four spheres from a radius and three angles.</p>
<div class="fragment"><div class="line">Standard_Real R = 30, ang = </div><div class="line">    PI/2, a1 = -PI/2.3,  a2 = PI/4; </div><div class="line">TopoDS_Solid S1 = BRepPrimAPI_MakeSphere(R); </div><div class="line">TopoDS_Solid S2 = BRepPrimAPI_MakeSphere(R,ang); </div><div class="line">TopoDS_Solid S3 = BRepPrimAPI_MakeSphere(R,a1,a2); </div><div class="line">TopoDS_Solid S4 = BRepPrimAPI_MakeSphere(R,a1,a2,ang); </div></div><!-- fragment --><p>Note that we could equally well choose to create Shells instead of Solids.</p>
<div class="image">
<img src="modeling_algos_image031.png" alt="modeling_algos_image031.png"/>
<div class="caption">
Examples of Spheres</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_7"></a>
Torus</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_torus.html">BRepPrimAPI_MakeTorus</a></em> class allows creating toroidal primitives. Like the other primitives, a torus is created either in the default coordinate system or in a given coordinate system <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em>. There are four constructions similar to the sphere constructions:</p>
<ul>
<li>Two radii &ndash; builds a full torus.</li>
<li>Two radii and an angle &ndash; builds an angular torus segment.</li>
<li>Two radii and two angles &ndash; builds a wraparound torus segment between two radial planes. The angles a1, a2 must follow the relation 0 &lt; a2 - a1 &lt; 2*PI.</li>
<li>Two radii and three angles &ndash; a combination of two previous methods builds a portion of torus segment.</li>
</ul>
<div class="image">
<img src="modeling_algos_image032.png" alt="modeling_algos_image032.png"/>
<div class="caption">
Examples of Tori</div></div>
<p> The following code builds four toroidal shells from two radii and three angles.</p>
<div class="fragment"><div class="line">Standard_Real R1 = 30, R2 = 10, ang = PI, a1 = 0, </div><div class="line">    a2 = PI/2; </div><div class="line">TopoDS_Shell S1 = BRepPrimAPI_MakeTorus(R1,R2); </div><div class="line">TopoDS_Shell S2 = BRepPrimAPI_MakeTorus(R1,R2,ang); </div><div class="line">TopoDS_Shell S3 = BRepPrimAPI_MakeTorus(R1,R2,a1,a2); </div><div class="line">TopoDS_Shell S4 = </div><div class="line">    BRepPrimAPI_MakeTorus(R1,R2,a1,a2,ang); </div></div><!-- fragment --><p>Note that we could equally well choose to create Solids instead of Shells.</p>
<h3><a class="anchor" id="occt_modalg_4_1_8"></a>
Revolution</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revolution.html">BRepPrimAPI_MakeRevolution</a></em> class allows building a uniaxial primitive from a curve. As other uniaxial primitives it can be created in the default coordinate system or in a given coordinate system.</p>
<p>The curve can be any <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___curve.html">Geom_Curve</a></em>, provided it is planar and lies in the same plane as the Z-axis of local coordinate system. There are four modes of construction:</p>
<ul>
<li>From a curve, use the full curve and make a full rotation.</li>
<li>From a curve and an angle of rotation.</li>
<li>From a curve and two parameters to trim the curve. The two parameters must be growing and within the curve range.</li>
<li>From a curve, two parameters, and an angle. The two parameters must be growing and within the curve range.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_4_2"></a>
Sweeping:  Prism, Revolution and Pipe</h2>
<h3><a class="anchor" id="occt_modalg_4_2_1"></a>
Sweeping</h3>
<p>Sweeps are the objects you obtain by sweeping a <b>profile</b> along a <b>path</b>. The profile can be of any topology. The path is usually a curve or a wire. The profile generates objects according to the following rules:</p>
<ul>
<li>Vertices generate Edges</li>
<li>Edges generate Faces.</li>
<li>Wires generate Shells.</li>
<li>Faces generate Solids.</li>
<li>Shells generate Composite Solids</li>
</ul>
<p>It is forbidden to sweep Solids and Composite Solids. A Compound generates a Compound with the sweep of all its elements.</p>
<div class="image">
<img src="modeling_algos_image033.png" alt="modeling_algos_image033.png"/>
<div class="caption">
Generating a sweep</div></div>
<p> <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_sweep.html">BRepPrimAPI_MakeSweep</a> class</em> is a deferred class used as a root of the the following sweep classes:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_prism.html">BRepPrimAPI_MakePrism</a></em> &ndash; produces a linear sweep</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revol.html">BRepPrimAPI_MakeRevol</a></em> &ndash; produces a rotational sweep</li>
<li><em>BRepPrimAPI_MakePipe</em> &ndash; produces a general sweep.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_4_2_2"></a>
Prism</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_prism.html">BRepPrimAPI_MakePrism</a></em> class allows creating a linear <b>prism</b> from a shape and a vector or a direction.</p><ul>
<li>A vector allows creating a finite prism;</li>
<li>A direction allows creating an infinite or semi-infinite prism. The semi-infinite or infinite prism is toggled by a Boolean argument. All constructors have a boolean argument to copy the original shape or share it (by default).</li>
</ul>
<p>The following code creates a finite, an infinite and a semi-infinite solid using a face, a direction and a length.</p>
<div class="fragment"><div class="line">TopoDS_Face F = ..; // The swept face </div><div class="line">gp_Dir direc(0,0,1); </div><div class="line">Standard_Real l = 10; </div><div class="line">// create a vector from the direction and the length </div><div class="line">gp_Vec v = direc; </div><div class="line">v *= l; </div><div class="line">TopoDS_Solid P1 = BRepPrimAPI_MakePrism(F,v); </div><div class="line">// finite </div><div class="line">TopoDS_Solid P2 = BRepPrimAPI_MakePrism(F,direc); </div><div class="line">// infinite </div><div class="line">TopoDS_Solid P3 =  BRepPrimAPI_MakePrism(F,direc,Standard_False); </div><div class="line">// semi-infinite </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image034.png" alt="modeling_algos_image034.png"/>
<div class="caption">
,"Finite, infinite, and semi-infinite prisms",420</div></div>
<h3><a class="anchor" id="occt_modalg_4_2_3"></a>
Rotational Sweep</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revol.html">BRepPrimAPI_MakeRevol</a></em> class allows creating a rotational sweep from a shape, an axis (<a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax1.html">gp_Ax1</a>), and an angle. The angle has a default value of 2*PI which means a closed revolution.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revol.html">BRepPrimAPI_MakeRevol</a></em> constructors have a last argument to copy or share the original shape. The following code creates a a full and a partial rotation using a face, an axis and an angle.</p>
<div class="fragment"><div class="line">TopoDS_Face F = ...; // the profile </div><div class="line">gp_Ax1 axis(gp_Pnt(0,0,0),gp_Dir(0,0,1)); </div><div class="line">Standard_Real ang = PI/3; </div><div class="line">TopoDS_Solid R1 = BRepPrimAPI_MakeRevol(F,axis); </div><div class="line">// Full revol </div><div class="line">TopoDS_Solid R2 = BRepPrimAPI_MakeRevol(F,axis,ang); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image035.png" alt="modeling_algos_image035.png"/>
<div class="caption">
Full and partial rotation</div></div>
 <h1><a class="anchor" id="occt_modalg_5"></a>
Boolean  Operations</h1>
<p>Boolean operations are used to create new shapes from the combinations of two groups of shapes.</p>
<table class="doxtable">
<tr>
<th align="left">Operation </th><th align="left">Result  </th></tr>
<tr>
<td align="left">Fuse </td><td align="left">all points in S1 or S2 </td></tr>
<tr>
<td align="left">Common </td><td align="left">all points in S1 and S2 </td></tr>
<tr>
<td align="left">Cut S1 by S2</td><td align="left">all points in S1 and not in S2 </td></tr>
</table>
<div class="image">
<img src="modeling_algos_image036.png" alt="modeling_algos_image036.png"/>
<div class="caption">
Boolean Operations</div></div>
<p> From the viewpoint of Topology these are topological operations followed by blending (putting fillets onto edges created after the topological operation).</p>
<p>Topological operations are the most convenient way to create real industrial parts. As most industrial parts consist of several simple elements such as gear wheels, arms, holes, ribs, tubes and pipes. It is usually easy to create those elements separately and then to combine them by Boolean operations in the whole final part.</p>
<p>See <a class="el" href="occt_user_guides__boolean_operations.html">Boolean Operations</a> for detailed documentation.</p>
<h2><a class="anchor" id="occt_modalg_5_1"></a>
Input and Result Arguments</h2>
<p>Boolean Operations have the following types of the arguments and produce the following results:</p><ul>
<li>For arguments having the same shape type (e.g. SOLID / SOLID) the type of the resulting shape will be a COMPOUND, containing shapes of this type;</li>
<li>For arguments having different shape types (e.g. SHELL / SOLID) the type of the resulting shape will be a COMPOUND, containing shapes of the type that is the same as that of the low type of the argument. Example: For SHELL/SOLID the result is a COMPOUND of SHELLs.</li>
<li>For arguments with different shape types some of Boolean Operations can not be done using the default implementation, because of a non-manifold type of the result. Example: the FUSE operation for SHELL and SOLID can not be done, but the CUT operation can be done, where SHELL is the object and SOLID is the tool.</li>
<li>It is possible to perform Boolean Operations on arguments of the COMPOUND shape type. In this case each compound must not be heterogeneous, i.e. it must contain equidimensional shapes (EDGEs or/and WIREs, FACEs or/and SHELLs, SOLIDs). SOLIDs inside the COMPOUND must not contact (intersect or touch) each other. The same condition should be respected for SHELLs or FACEs, WIREs or EDGEs.</li>
<li>Boolean Operations for COMPSOLID type of shape are not supported.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_5_2"></a>
Implementation</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em> class is the deferred root class for Boolean operations.</p>
<h4>Fuse</h4>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___fuse.html">BRepAlgoAPI_Fuse</a></em> performs the Fuse operation.</p>
<div class="fragment"><div class="line">TopoDS_Shape A = ..., B = ...; </div><div class="line">TopoDS_Shape S = BRepAlgoAPI_Fuse(A,B); </div></div><!-- fragment --><h4>Common</h4>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___common.html">BRepAlgoAPI_Common</a></em> performs the Common operation.</p>
<div class="fragment"><div class="line">TopoDS_Shape A = ..., B = ...; </div><div class="line">TopoDS_Shape S = BRepAlgoAPI_Common(A,B); </div></div><!-- fragment --><h4>Cut</h4>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___cut.html">BRepAlgoAPI_Cut</a></em> performs the Cut operation.</p>
<div class="fragment"><div class="line">TopoDS_Shape A = ..., B = ...; </div><div class="line">TopoDS_Shape S = BRepAlgoAPI_Cut(A,B); </div></div><!-- fragment --><h4>Section</h4>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___section.html">BRepAlgoAPI_Section</a></em> performs the section, described as a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___compound.html">TopoDS_Compound</a></em> made of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em>.</p>
<div class="image">
<img src="modeling_algos_image037.png" alt="modeling_algos_image037.png"/>
<div class="caption">
Section operation</div></div>
 <div class="fragment"><div class="line">TopoDS_Shape A = ...,  TopoDS_ShapeB = ...; </div><div class="line">TopoDS_Shape S =  BRepAlgoAPI_Section(A,B); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_6"></a>
Fillets and  Chamfers</h1>
<p>This library provides algorithms to make fillets and chamfers on shape edges. The following cases are addressed:</p>
<ul>
<li>Corners and apexes with different radii;</li>
<li>Corners and apexes with different concavity.</li>
</ul>
<p>If there is a concavity, both surfaces that need to be extended and those, which do not, are processed.</p>
<h2><a class="anchor" id="occt_modalg_6_1"></a>
Fillets</h2>
<h2><a class="anchor" id="occt_modalg_6_1_1"></a>
Fillet on shape</h2>
<p>A fillet is a smooth face replacing a sharp edge.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_fillet.html">BRepFilletAPI_MakeFillet</a></em> class allows filleting a shape.</p>
<p>To produce a fillet, it is necessary to define the filleted shape at the construction of the class and add fillet descriptions using the <em>Add</em> method.</p>
<p>A fillet description contains an edge and a radius. The edge must be shared by two faces. The fillet is automatically extended to all edges in a smooth continuity with the original edge. It is not an error to add a fillet twice, the last description holds.</p>
<div class="image">
<img src="modeling_algos_image038.png" alt="modeling_algos_image038.png"/>
<div class="caption">
Filleting two edges using radii r1 and r2.</div></div>
<p> In the following example a filleted box with dimensions a,b,c and radius r is created.</p>
<h3>Constant radius</h3>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt; </div><div class="line">#include &lt;TopoDS.hxx&gt; </div><div class="line">#include &lt;BRepPrimAPI_MakeBox.hxx&gt; </div><div class="line">#include &lt;TopoDS_Solid.hxx&gt; </div><div class="line">#include &lt;BRepFilletAPI_MakeFillet.hxx&gt; </div><div class="line">#include &lt;TopExp_Explorer.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Shape FilletedBox(const Standard_Real a, </div><div class="line">                        const Standard_Real  b, </div><div class="line">                        const Standard_Real  c, </div><div class="line">                        const Standard_Real  r) </div><div class="line">{ </div><div class="line">    TopoDS_Solid Box =  BRepPrimAPI_MakeBox(a,b,c); </div><div class="line">    BRepFilletAPI_MakeFillet  MF(Box); </div><div class="line"></div><div class="line">    // add all the edges  to fillet </div><div class="line">    TopExp_Explorer  ex(Box,TopAbs_EDGE); </div><div class="line">    while (ex.More()) </div><div class="line">    { </div><div class="line">    MF.Add(r,TopoDS::Edge(ex.Current())); </div><div class="line">    ex.Next(); </div><div class="line">    } </div><div class="line">    return MF.Shape(); </div><div class="line">    } </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image039.png" alt="modeling_algos_image039.png"/>
<div class="caption">
Fillet with constant radius</div></div>
 <h4>Changing radius</h4>
<div class="fragment"><div class="line">void CSampleTopologicalOperationsDoc::OnEvolvedblend1() </div><div class="line">{ </div><div class="line">    TopoDS_Shape theBox  = BRepPrimAPI_MakeBox(200,200,200); </div><div class="line"></div><div class="line">    BRepFilletAPI_MakeFillet  Rake(theBox); </div><div class="line">    ChFi3d_FilletShape  FSh = ChFi3d_Rational; </div><div class="line">    Rake.SetFilletShape(FSh); </div><div class="line"></div><div class="line">    TColgp_Array1OfPnt2d  ParAndRad(1, 6); </div><div class="line">    ParAndRad(1).SetCoord(0.,  10.); </div><div class="line">    ParAndRad(1).SetCoord(50.,  20.); </div><div class="line">    ParAndRad(1).SetCoord(70.,  20.); </div><div class="line">    ParAndRad(1).SetCoord(130.,  60.); </div><div class="line">    ParAndRad(1).SetCoord(160.,  30.); </div><div class="line">    ParAndRad(1).SetCoord(200.,  20.); </div><div class="line"></div><div class="line">    TopExp_Explorer  ex(theBox,TopAbs_EDGE); </div><div class="line">    Rake.Add(ParAndRad, TopoDS::Edge(ex.Current())); </div><div class="line">    TopoDS_Shape  evolvedBox = Rake.Shape(); </div><div class="line">} </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image040.png" alt="modeling_algos_image040.png"/>
<div class="caption">
Fillet with changing radius</div></div>
 <h2><a class="anchor" id="occt_modalg_6_1_2"></a>
Chamfer</h2>
<p>A chamfer is a rectilinear edge replacing a sharp vertex of the face.</p>
<p>The use of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_chamfer.html">BRepFilletAPI_MakeChamfer</a></em> class is similar to the use of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_fillet.html">BRepFilletAPI_MakeFillet</a></em>, except for the following:</p><ul>
<li>The surfaces created are ruled and not smooth.</li>
<li>The <em>Add</em> syntax for selecting edges requires one or two distances, one edge and one face (contiguous to the edge).</li>
</ul>
<div class="fragment"><div class="line">Add(dist,  E, F) </div><div class="line">Add(d1,  d2, E, F) with d1 on the face F. </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image041.png" alt="modeling_algos_image041.png"/>
<div class="caption">
Chamfer</div></div>
 <h2><a class="anchor" id="occt_modalg_6_1_3"></a>
Fillet on a planar face</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_fillet2d.html">BRepFilletAPI_MakeFillet2d</a></em> class allows constructing fillets and chamfers on planar faces. To create a fillet on planar face: define it, indicate, which vertex is to be deleted, and give the fillet radius with <em>AddFillet</em> method.</p>
<p>A chamfer can be calculated with <em>AddChamfer</em> method. It can be described by</p><ul>
<li>two edges and two distances</li>
<li>one edge, one vertex, one distance and one angle. Fillets and chamfers are calculated when addition is complete.</li>
</ul>
<p>If face F2 is created by 2D fillet and chamfer builder from face F1, the builder can be rebuilt (the builder recovers the status it had before deletion). To do so, use the following syntax: </p><div class="fragment"><div class="line">BRepFilletAPI_MakeFillet2d builder; </div><div class="line">builder.Init(F1,F2); </div></div><!-- fragment --><h2>Planar Fillet </h2>
<div class="fragment"><div class="line">#include “BRepPrimAPI_MakeBox.hxx” </div><div class="line">#include “TopoDS_Shape.hxx” </div><div class="line">#include “TopExp_Explorer.hxx” </div><div class="line">#include “BRepFilletAPI_MakeFillet2d.hxx” </div><div class="line">#include “TopoDS.hxx” </div><div class="line">#include “TopoDS_Solid.hxx” </div><div class="line"></div><div class="line">TopoDS_Shape FilletFace(const Standard_Real a, </div><div class="line">                        const Standard_Real  b, </div><div class="line">                        const Standard_Real c, </div><div class="line">                        const Standard_Real  r) </div><div class="line"></div><div class="line">{ </div><div class="line">    TopoDS_Solid Box =  BRepPrimAPI_MakeBox (a,b,c); </div><div class="line">    TopExp_Explorer  ex1(Box,TopAbs_FACE); </div><div class="line"></div><div class="line">    const  TopoDS_Face&amp; F = TopoDS::Face(ex1.Current()); </div><div class="line">    BRepFilletAPI_MakeFillet2d  MF(F); </div><div class="line">    TopExp_Explorer  ex2(F, TopAbs_VERTEX); </div><div class="line">    while (ex2.More()) </div><div class="line">    { </div><div class="line">    MF.AddFillet(TopoDS::Vertex(ex2.Current()),r); </div><div class="line">    ex2.Next(); </div><div class="line">    } </div><div class="line">    // while... </div><div class="line">    return MF.Shape(); </div><div class="line">} </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_7"></a>
Offsets, Drafts, Pipes and Evolved shapes</h1>
<p>These classes provide the following services:</p>
<ul>
<li>Creation of offset shapes and their variants such as:<ul>
<li>Hollowing;</li>
<li>Shelling;</li>
<li>Lofting;</li>
</ul>
</li>
<li>Creation of tapered shapes using draft angles;</li>
<li>Creation of sweeps.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_7_1"></a>
Offset computation</h2>
<p>Offset computation can be performed using <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html">BRepOffsetAPI_MakeOffsetShape</a></em>. This class provides API to the two different offset algorithms:</p>
<p>Offset algorithm based on computation of the analytical continuation. Meaning of the parameters can be found in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html#a23130ef38ae1b07bc2eca631385ac9be">BRepOffsetAPI_MakeOffsetShape::PerformByJoin</a></em> method description. The list below demonstrates principal scheme of this algorithm:</p>
<ul>
<li>At the first step, the offsets are computed.</li>
<li>After this, the analytical continuations are computed for each offset.</li>
<li>Pairwise intersection is computed according to the original topological information (sharing, number of neighbors, etc.).</li>
<li>The offset shape is assembled.</li>
</ul>
<p>The second algorithm is based on the fact that the offset computation for a single face without continuation can always be built. The list below shows simple offset algorithm:</p><ul>
<li>Each surface is mapped to its geometric offset surface.</li>
<li>For each edge, pcurves are mapped to the same pcurves on offset surfaces.</li>
<li>For each edge, 3d curve is constructed by re-approximation of pcurve on the first offset face.</li>
<li>Position of each vertex in a result shell is computed as average point of all ends of edges sharing that vertex.</li>
<li>Tolerances are updated according to the resulting geometry. The possible drawback of the simple algorithm is that it leads, in general case, to tolerance increasing. The tolerances have to grow in order to cover the gaps between the neighbor faces in the output. It should be noted that the actual tolerance growth depends on the offset distance and the quality of joints between the input faces. Anyway the good input shell (smooth connections between adjacent faces) will lead to good result.</li>
</ul>
<p>The snippets below show usage examples: </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html">BRepOffsetAPI_MakeOffsetShape</a> OffsetMaker1;</div><div class="line"><span class="comment">// Computes offset shape using analytical continuation mechanism.</span></div><div class="line">OffsetMaker1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html#a23130ef38ae1b07bc2eca631385ac9be">PerformByJoin</a>(Shape, OffsetValue, Tolerance);</div><div class="line"><span class="keywordflow">if</span> (OffsetMaker1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___command.html#ac474eda9b2643b64815bad4b34d39f84">IsDone</a>())</div><div class="line">  NewShape = OffsetMaker1.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html#a5b5b6e22f99b84ee579f163ce4ffd9a9">Shape</a>();</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html">BRepOffsetAPI_MakeOffsetShape</a> OffsetMaker2;</div><div class="line"><span class="comment">// Computes offset shape using simple algorithm.</span></div><div class="line">OffsetMaker2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html#a517286824abd82c44010eb2332775c32">PerformBySimple</a>(Shape, OffsetValue);</div><div class="line"><span class="keywordflow">if</span> (OffsetMaker2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___command.html#ac474eda9b2643b64815bad4b34d39f84">IsDone</a>())</div><div class="line">  NewShape = OffsetMaker2.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html#a5b5b6e22f99b84ee579f163ce4ffd9a9">Shape</a>();</div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_7_2"></a>
Shelling</h2>
<p>Shelling is used to offset given faces of a solid by a specific value. It rounds or intersects adjacent faces along its edges depending on the convexity of the edge. The MakeThickSolidByJoin method of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html">BRepOffsetAPI_MakeThickSolid</a></em> takes the solid, the list of faces to remove and an offset value as input.</p>
<div class="fragment"><div class="line">TopoDS_Solid SolidInitial = ...;</div><div class="line"></div><div class="line">Standard_Real           Of      = ...;</div><div class="line">TopTools_ListOfShape    LCF;</div><div class="line">TopoDS_Shape            Result;</div><div class="line">Standard_Real           Tol = Precision::Confusion();</div><div class="line"></div><div class="line">for (Standard_Integer i = 1 ;i &lt;= n; i++) {</div><div class="line">    TopoDS_Face SF = ...; // a face from SolidInitial</div><div class="line">    LCF.Append(SF);</div><div class="line">}</div><div class="line"></div><div class="line">BRepOffsetAPI_MakeThickSolid SolidMaker;</div><div class="line">SolidMaker.MakeThickSolidByJoin(SolidInitial,</div><div class="line">                                LCF,</div><div class="line">                                Of,</div><div class="line">                                Tol);</div><div class="line">if (SolidMaker.IsDone())</div><div class="line">  Result = SolidMaker.Shape();</div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image042.png" alt="modeling_algos_image042.png"/>
<div class="caption">
Shelling</div></div>
<p> Also it is possible to create solid between shell, offset shell. This functionality can be called using <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html#a3a27e7e4444c98838a93bafb13256188">BRepOffsetAPI_MakeThickSolid::MakeThickSolidBySimple</a></em> method. The code below shows usage example:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html">BRepOffsetAPI_MakeThickSolid</a> SolidMaker;</div><div class="line">SolidMaker.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html#a3a27e7e4444c98838a93bafb13256188">MakeThickSolidBySimple</a>(Shell, OffsetValue);</div><div class="line"><span class="keywordflow">if</span> (myDone.IsDone())</div><div class="line">  Solid = SolidMaker.<a class="codeRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html#a5b5b6e22f99b84ee579f163ce4ffd9a9">Shape</a>();</div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_7_3"></a>
Draft Angle</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___draft_angle.html">BRepOffsetAPI_DraftAngle</a></em> class allows modifying a shape by applying draft angles to its planar, cylindrical and conical faces.</p>
<p>The class is created or initialized from a shape, then faces to be modified are added; for each face, three arguments are used:</p><ul>
<li>Direction: the direction with which the draft angle is measured</li>
<li>Angle: value of the angle</li>
<li>Neutral plane: intersection between the face and the neutral plane is invariant.</li>
</ul>
<p>The following code places a draft angle on several faces of a shape; the same direction, angle and neutral plane are used for each face:</p>
<div class="fragment"><div class="line">TopoDS_Shape myShape = ... </div><div class="line">// The original shape </div><div class="line">TopTools_ListOfShape ListOfFace; </div><div class="line">// Creation of the list of faces to be modified </div><div class="line">... </div><div class="line"></div><div class="line">gp_Dir Direc(0.,0.,1.); </div><div class="line">// Z direction </div><div class="line">Standard_Real Angle = 5.*PI/180.; </div><div class="line">// 5 degree angle </div><div class="line">gp_Pln Neutral(gp_Pnt(0.,0.,5.), Direc); </div><div class="line">// Neutral plane Z=5 </div><div class="line">BRepOffsetAPI_DraftAngle theDraft(myShape); </div><div class="line">TopTools_ListIteratorOfListOfShape itl; </div><div class="line">for (itl.Initialize(ListOfFace); itl.More(); itl.Next())  { </div><div class="line">    theDraft.Add(TopoDS::Face(itl.Value()),Direc,Angle,Neutral); </div><div class="line">    if  (!theDraft.AddDone()) { </div><div class="line">        // An error has occurred. The faulty face is given by //  ProblematicShape </div><div class="line">        break; </div><div class="line">        } </div><div class="line">} </div><div class="line">if (!theDraft.AddDone()) { </div><div class="line">    // An error has  occurred </div><div class="line">    TopoDS_Face guilty =  theDraft.ProblematicShape(); </div><div class="line">    ... </div><div class="line">} </div><div class="line">theDraft.Build(); </div><div class="line">if (!theDraft.IsDone()) { </div><div class="line">    // Problem  encountered during reconstruction </div><div class="line">    ... </div><div class="line">} </div><div class="line">else { </div><div class="line">    TopoDS_Shape  myResult = theDraft.Shape(); </div><div class="line">    ... </div><div class="line">} </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image043.png" alt="modeling_algos_image043.png"/>
<div class="caption">
DraftAngle</div></div>
 <h2><a class="anchor" id="occt_modalg_7_4"></a>
Pipe  Constructor</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_pipe.html">BRepOffsetAPI_MakePipe</a></em> class allows creating a pipe from a Spine, which is a Wire and a Profile which is a Shape. This implementation is limited to spines with smooth transitions, sharp transitions are precessed by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_pipe_shell.html">BRepOffsetAPI_MakePipeShell</a></em>. To be more precise the continuity must be G1, which means that the tangent must have the same direction, though not necessarily the same magnitude, at neighboring edges.</p>
<p>The angle between the spine and the profile is preserved throughout the pipe.</p>
<div class="fragment"><div class="line">TopoDS_Wire Spine = ...; </div><div class="line">TopoDS_Shape Profile = ...; </div><div class="line">TopoDS_Shape Pipe =  BRepOffsetAPI_MakePipe(Spine,Profile); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image044.png" alt="modeling_algos_image044.png"/>
<div class="caption">
Example of a Pipe</div></div>
 <h2><a class="anchor" id="occt_modalg_7_5"></a>
Evolved Solid</h2>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_evolved.html">BRepOffsetAPI_MakeEvolved</a></em> class allows creating an evolved solid from a Spine (planar face or wire) and a profile (wire).</p>
<p>The evolved solid is an unlooped sweep generated by the spine and the profile.</p>
<p>The evolved solid is created by sweeping the profile’s reference axes on the spine. The origin of the axes moves to the spine, the X axis and the local tangent coincide and the Z axis is normal to the face.</p>
<p>The reference axes of the profile can be defined following two distinct modes:</p>
<ul>
<li>The reference axes of the profile are the origin axes.</li>
<li>The references axes of the profile are calculated as follows:<ul>
<li>the origin is given by the point on the spine which is the closest to the profile</li>
<li>the X axis is given by the tangent to the spine at the point defined above</li>
<li>the Z axis is the normal to the plane which contains the spine.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Face Spine = ...; </div><div class="line">TopoDS_Wire Profile = ...; </div><div class="line">TopoDS_Shape Evol = </div><div class="line">BRepOffsetAPI_MakeEvolved(Spine,Profile); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_8"></a>
Sewing</h1>
<h2><a class="anchor" id="occt_modalg_8_1"></a>
Introduction</h2>
<p>Sewing allows creation of connected topology (shells and wires) from a set of separate topological elements (faces and edges). For example, Sewing can be used to create of shell from a compound of separate faces.</p>
<div class="image">
<img src="modeling_algos_image045.png" alt="modeling_algos_image045.png"/>
<div class="caption">
Shapes with partially shared edges</div></div>
<p> It is important to distinguish between sewing and other procedures, which modify the geometry, such as filling holes or gaps, gluing, bending curves and surfaces, etc.</p>
<p>Sewing does not change geometrical representation of the shapes. Sewing applies to topological elements (faces, edges) which are not connected but can be connected because they are geometrically coincident : it adds the information about topological connectivity. Already connected elements are left untouched in case of manifold sewing.</p>
<p>Let us define several terms:</p><ul>
<li><b>Floating edges</b> do not belong to any face;</li>
<li><b>Free boundaries</b> belong to one face only;</li>
<li><b>Shared edges</b> belong to several faces, (i.e. two faces in a manifold topology).</li>
<li><b>Sewn faces</b> should have edges shared with each other.</li>
<li><b>Sewn edges</b> should have vertices shared with each other.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_8_2"></a>
Sewing Algorithm</h2>
<p>The sewing algorithm is one of the basic algorithms used for shape processing, therefore its quality is very important.</p>
<p>Sewing algorithm is implemented in the class <em>BRepBuilder_Sewing</em>. This class provides the following methods:</p><ul>
<li>loading initial data for global or local sewing;</li>
<li>setting customization parameters, such as special operation modes, tolerances and output results;</li>
<li>applying analysis methods that can be used to obtain connectivity data required by external algorithms;</li>
<li>sewing of the loaded shapes.</li>
</ul>
<p>Sewing supports working mode with big value tolerance. It is not necessary to repeat sewing step by step while smoothly increasing tolerance.</p>
<p>It is also possible to sew edges to wire and to sew locally separate faces and edges from a shape.</p>
<p>The Sewing algorithm can be subdivided into several independent stages, some of which can be turned on or off using Boolean or other flags.</p>
<p>In brief, the algorithm should find a set of merge candidates for each free boundary, filter them according to certain criteria, and finally merge the found candidates and build the resulting sewn shape.</p>
<p>Each stage of the algorithm or the whole algorithm can be adjusted with the following parameters:</p><ul>
<li><b>Working tolerance</b> defines the maximal distance between topological elements which can be sewn. It is not ultimate that such elements will be actually sewn as many other criteria are applied to make the final decision.</li>
<li><b>Minimal tolerance</b> defines the size of the smallest element (edge) in the resulting shape. It is declared that no edges with size less than this value are created after sewing. If encountered, such topology becomes degenerated.</li>
<li><b>Non-manifold mode</b> enables sewing of non-manifold topology.</li>
</ul>
<h4>Example</h4>
<p>To connect a set of <em>n</em> contiguous but independent faces, do the following:</p>
<div class="fragment"><div class="line">BRepBuilderAPI_Sewing Sew;</div><div class="line">Sew.Add(Face1); </div><div class="line">Sew.Add(Face2); </div><div class="line">...</div><div class="line">Sew.Add(Facen); </div><div class="line">Sew.Perform();</div><div class="line">TopoDS_Shape result= Sew.SewedShape();</div></div><!-- fragment --><p>If all faces have been sewn correctly, the result is a shell. Otherwise, it is a compound. After a successful sewing operation all faces have a coherent orientation.</p>
<h2><a class="anchor" id="occt_modalg_8_3"></a>
Tolerance Management</h2>
<p>To produce a closed shell, Sewing allows specifying the value of working tolerance, exceeding the size of small faces belonging to the shape.</p>
<p>However, if we produce an open shell, it is possible to get incorrect sewing results if the value of working tolerance is too large (i.e. it exceeds the size of faces lying on an open boundary).</p>
<p>The following recommendations can be proposed for tuning-up the sewing process:</p><ul>
<li>Use as small working tolerance as possible. This will reduce the sewing time and, consequently, the number of incorrectly sewn edges for shells with free boundaries.</li>
<li>Use as large minimal tolerance as possible. This will reduce the number of small geometry in the shape, both original and appearing after cutting.</li>
<li>If it is expected to obtain a shell with holes (free boundaries) as a result of sewing, the working tolerance should be set to a value not greater than the size of the smallest element (edge) or smallest distance between elements of such free boundary. Otherwise the free boundary may be sewn only partially.</li>
<li>It should be mentioned that the Sewing algorithm is unable to understand which small (less than working tolerance) free boundary should be kept and which should be sewn.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_8_4"></a>
Manifold and Non-manifold Sewing</h2>
<p>To create one or several shells from a set of faces, sewing merges edges, which belong to different faces or one closed face.</p>
<p>Face sewing supports manifold and non manifold modes. Manifold mode can produce only a manifold shell. Sewing should be used in the non manifold mode to create non manifold shells.</p>
<p>Manifold sewing of faces merges only two nearest edges belonging to different faces or one closed face with each other. Non manifold sewing of faces merges all edges at a distance less than the specified tolerance.</p>
<p>For a complex topology it is advisable to apply first the manifold sewing and then the non manifold sewing a minimum possible working tolerance. However, this is not necessary for a easy topology.</p>
<p>Giving a large tolerance value to non manifold sewing will cause a lot of incorrectness since all nearby geometry will be sewn.</p>
<h2><a class="anchor" id="occt_modalg_8_5"></a>
Local Sewing</h2>
<p>If a shape still has some non-sewn faces or edges after sewing, it is possible to use local sewing with a greater tolerance.</p>
<p>Local sewing is especially good for open shells. It allows sewing an unwanted hole in one part of the shape and keeping a required hole, which is smaller than the working tolerance specified for the local sewing in the other part of the shape. Local sewing is much faster than sewing on the whole shape.</p>
<p>All preexisting connections of the whole shape are kept after local sewing.</p>
<p>For example, if you want to sew two open shells having coincided free edges using local sewing, it is necessary to create a compound from two shells then load the full compound using method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___sewing.html#a03bf44122d6368f558ef396aad190c7c">BRepBuilderAPI_Sewing::Load()</a></em>. After that it is necessary to add local sub-shapes, which should be sewn using method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___sewing.html#ace5bd7514b7e9047ca4c0289f3deb96a">BRepBuilderAPI_Sewing::Add()</a></em>. The result of sewing can be obtained using method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___sewing.html#ac778fbb2e0f0694fda5e9ab287914b10">BRepBuilderAPI_Sewing::SewedShape()</a></em>.</p>
<p>See the example:</p>
<div class="fragment"><div class="line">//initial sewn shapes</div><div class="line">TopoDS_Shape aS1, aS2;  // these shapes are expected to be well sewn shells</div><div class="line">TopoDS_Shape aComp;</div><div class="line">BRep_Builder aB;</div><div class="line">aB.MakeCompound(aComp);</div><div class="line">aB.Add(aComp, aS1);</div><div class="line">aB.Add(aComp, aS2);</div><div class="line">................................</div><div class="line">aSewing.Load(aComp);</div><div class="line"></div><div class="line">//sub shapes which should be locally sewed</div><div class="line">aSewing.Add(aF1);</div><div class="line">aSewing.Add(aF2);</div><div class="line">//performing sewing</div><div class="line">aSewing.Perform();</div><div class="line">//result shape</div><div class="line">TopoDS_Shape aRes = aSewing.SewedShape();</div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_9"></a>
Features</h1>
<p>This library contained in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em> package is necessary for creation and manipulation of form and mechanical features that go beyond the classical boundary representation of shapes. In that sense, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em> is an extension of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> package.</p>
<h2><a class="anchor" id="occt_modalg_9_1"></a>
Form Features</h2>
<p>The form features are depressions or protrusions including the following types:</p>
<ul>
<li>Cylinder;</li>
<li><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draft.html">Draft</a> Prism;</li>
<li>Prism;</li>
<li>Revolved feature;</li>
<li>Pipe.</li>
</ul>
<p>Depending on whether you wish to make a depression or a protrusion, you can choose either to remove matter (Boolean cut: Fuse equal to 0) or to add it (Boolean fusion: Fuse equal to 1).</p>
<p>The semantics of form feature creation is based on the construction of shapes:</p>
<ul>
<li>for a certain length in a certain direction;</li>
<li>up to the limiting face;</li>
<li>from the limiting face at a height;</li>
<li>above and/or below a plane.</li>
</ul>
<p>The shape defining the construction of a feature can be either a supporting edge or a concerned area of a face.</p>
<p>In case of supporting edge, this contour can be attached to a face of the basis shape by binding. When the contour is bound to this face, the information that the contour will slide on the face becomes available to the relevant class methods. In case of the concerned area of a face, you can, for example, cut it out and move it at a different height, which defines the limiting face of a protrusion or depression.</p>
<p>Topological definition with local operations of this sort makes calculations simpler and faster than a global operation. The latter would entail a second phase of removing unwanted matter to get the same result.</p>
<p>The <em>Form</em> from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em> package is a deferred class used as a root for form features. It inherits <em>MakeShape</em> from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> and provides implementation of methods keep track of all sub-shapes.</p>
<h3><a class="anchor" id="occt_modalg_9_1_1"></a>
Prism</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_prism.html">BRepFeat_MakePrism</a></em> is used to build a prism interacting with a shape. It is created or initialized from</p><ul>
<li>a shape (the basic shape),</li>
<li>the base of the prism,</li>
<li>a face (the face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>a direction,</li>
<li>a Boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another Boolean indicating if the self-intersections have to be found (not used in every case).</li>
</ul>
<p>There are six Perform methods: </p><table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>Perform(Height)</em> </td><td align="left">The resulting prism is of the given length. </td></tr>
<tr>
<td align="left"><em>Perform(Until)</em> </td><td align="left">The prism is defined between the position of the base and the given face. </td></tr>
<tr>
<td align="left"><em>Perform(From, Until)</em> </td><td align="left">The prism is defined between the two faces From and Until. </td></tr>
<tr>
<td align="left"><em>PerformUntilEnd()</em> </td><td align="left">The prism is semi-infinite, limited by the actual position of the base. </td></tr>
<tr>
<td align="left"><em>PerformFromEnd(Until)</em> </td><td align="left">The prism is semi-infinite, limited by the face Until. </td></tr>
<tr>
<td align="left"><em>PerformThruAll()</em> </td><td align="left">The prism is infinite. In the case of a depression, the result is similar to a cut with an infinite prism. In the case of a protrusion, infinite parts are not kept in the result. </td></tr>
</table>
<p><b>Note</b> that <em>Add</em> method can be used before <em>Perform</em> methods to indicate that a face generated by an edge slides onto a face of the base shape.</p>
<p>In the following sequence, a protrusion is performed, i.e. a face of the shape is changed into a prism.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...;  // an initial shape </div><div class="line">TopoDS_Face Fbase = ....; // a base of prism </div><div class="line"></div><div class="line">gp_Dir Extrusion (.,.,.); </div><div class="line"></div><div class="line">// An empty face is given as the sketch face </div><div class="line"></div><div class="line">BRepFeat_MakePrism thePrism(Sbase, Fbase, TopoDS_Face(),  Extrusion, Standard_True, Standard_True); </div><div class="line"></div><div class="line">thePrism, Perform(100.); </div><div class="line">if (thePrism.IsDone()) { </div><div class="line">    TopoDS_Shape  theResult = thePrism; </div><div class="line">    ... </div><div class="line">} </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image047.png" alt="modeling_algos_image047.png"/>
<div class="caption">
Fusion with MakePrism</div></div>
 <div class="image">
<img src="modeling_algos_image048.png" alt="modeling_algos_image048.png"/>
<div class="caption">
Creating a prism between two faces with Perform()</div></div>
 <h3><a class="anchor" id="occt_modalg_9_1_2"></a>
Draft Prism</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_d_prism.html">BRepFeat_MakeDPrism</a></em> is used to build draft prism topologies interacting with a basis shape. These can be depressions or protrusions. A class object is created or initialized from:</p><ul>
<li>a shape (basic shape),</li>
<li>the base of the prism,</li>
<li>a face (face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>an angle,</li>
<li>a Boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another Boolean indicating if self-intersections have to be found (not used in every case).</li>
</ul>
<p>Evidently the input data for MakeDPrism are the same as for MakePrism except for a new parameter Angle and a missing parameter Direction: the direction of the prism generation is determined automatically as the normal to the base of the prism. The semantics of draft prism feature creation is based on the construction of shapes:</p><ul>
<li>along a length</li>
<li>up to a limiting face</li>
<li>from a limiting face to a height.</li>
</ul>
<p>The shape defining construction of the draft prism feature can be either the supporting edge or the concerned area of a face.</p>
<p>In case of the supporting edge, this contour can be attached to a face of the basis shape by binding. When the contour is bound to this face, the information that the contour will slide on the face becomes available to the relevant class methods. In case of the concerned area of a face, it is possible to cut it out and move it to a different height, which will define the limiting face of a protrusion or depression direction .</p>
<p>The <em>Perform</em> methods are the same as for <em>MakePrism</em>.</p>
<div class="fragment"><div class="line">TopoDS_Shape S = BRepPrimAPI_MakeBox(400.,250.,300.); </div><div class="line">TopExp_Explorer Ex; </div><div class="line">Ex.Init(S,TopAbs_FACE); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">TopoDS_Face F = TopoDS::Face(Ex.Current()); </div><div class="line">Handle(Geom_Surface) surf = BRep_Tool::Surface(F); </div><div class="line">gp_Circ2d </div><div class="line">c(gp_Ax2d(gp_Pnt2d(200.,130.),gp_Dir2d(1.,0.)),50.); </div><div class="line">BRepBuilderAPI_MakeWire MW; </div><div class="line">Handle(Geom2d_Curve) aline = new Geom2d_Circle(c); </div><div class="line">MW.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,PI)); </div><div class="line">MW.Add(BRepBuilderAPI_MakeEdge(aline,surf,PI,2.*PI)); </div><div class="line">BRepBuilderAPI_MakeFace MKF; </div><div class="line">MKF.Init(surf,Standard_False); </div><div class="line">MKF.Add(MW.Wire()); </div><div class="line">TopoDS_Face FP = MKF.Face(); </div><div class="line">BRepLib::BuildCurves3d(FP); </div><div class="line">BRepFeat_MakeDPrism MKDP (S,FP,F,10*PI180,Standard_True, </div><div class="line">                            Standard_True); </div><div class="line">MKDP.Perform(200); </div><div class="line">TopoDS_Shape res1 = MKDP.Shape(); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image049.png" alt="modeling_algos_image049.png"/>
<div class="caption">
A tapered prism</div></div>
 <h3><a class="anchor" id="occt_modalg_9_1_3"></a>
Revolution</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_revol.html">BRepFeat_MakeRevol</a></em> is used to build a revolution interacting with a shape. It is created or initialized from:</p><ul>
<li>a shape (the basic shape,)</li>
<li>the base of the revolution,</li>
<li>a face (the face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>an axis of revolution,</li>
<li>a boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another boolean indicating whether the self-intersections have to be found (not used in every case).</li>
</ul>
<p>There are four Perform methods: </p><table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>Perform(Angle)</em> </td><td align="left">The resulting revolution is of the given magnitude. </td></tr>
<tr>
<td align="left"><em>Perform(Until)</em> </td><td align="left">The revolution is defined between the actual position of the base and the given face. </td></tr>
<tr>
<td align="left"><em>Perform(From, Until)</em> </td><td align="left">The revolution is defined between the two faces, From and Until. </td></tr>
<tr>
<td align="left"><em>PerformThruAll()</em> </td><td align="left">The result is similar to Perform(2*PI). </td></tr>
</table>
<p><b>Note</b> that <em>Add</em> method can be used before <em>Perform</em> methods to indicate that a face generated by an edge slides onto a face of the base shape.</p>
<p>In the following sequence, a face is revolved and the revolution is limited by a face of the base shape.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...;  // an initial shape </div><div class="line">TopoDS_Face Frevol = ....; // a base of prism </div><div class="line">TopoDS_Face FUntil = ....; // face limiting the revol </div><div class="line"></div><div class="line">gp_Dir RevolDir (.,.,.); </div><div class="line">gp_Ax1 RevolAx(gp_Pnt(.,.,.), RevolDir); </div><div class="line"></div><div class="line">// An empty face is given as the sketch face </div><div class="line"></div><div class="line">BRepFeat_MakeRevol theRevol(Sbase, Frevol, TopoDS_Face(), RevolAx,  Standard_True, Standard_True); </div><div class="line"></div><div class="line">theRevol.Perform(FUntil); </div><div class="line">if (theRevol.IsDone()) { </div><div class="line">    TopoDS_Shape  theResult = theRevol; </div><div class="line">    ... </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_9_1_4"></a>
Pipe</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_pipe.html">BRepFeat_MakePipe</a></em> constructs compound shapes with pipe features: depressions or protrusions. A class object is created or initialized from:</p><ul>
<li>a shape (basic shape),</li>
<li>a base face (profile of the pipe)</li>
<li>a face (face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>a spine wire</li>
<li>a Boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another Boolean indicating if self-intersections have to be found (not used in every case).</li>
</ul>
<p>There are three Perform methods: </p><table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>Perform()</em> </td><td align="left">The pipe is defined along the entire path (spine wire) </td></tr>
<tr>
<td align="left"><em>Perform(Until)</em> </td><td align="left">The pipe is defined along the path until a given face </td></tr>
<tr>
<td align="left"><em>Perform(From, Until)</em> </td><td align="left">The pipe is defined between the two faces From and Until </td></tr>
</table>
<p>Let us have a look at the example:</p>
<div class="fragment"><div class="line">TopoDS_Shape S = BRepPrimAPI_MakeBox(400.,250.,300.); </div><div class="line">TopExp_Explorer Ex; </div><div class="line">Ex.Init(S,TopAbs_FACE); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">TopoDS_Face F1 = TopoDS::Face(Ex.Current()); </div><div class="line">Handle(Geom_Surface) surf = BRep_Tool::Surface(F1); </div><div class="line">BRepBuilderAPI_MakeWire MW1; </div><div class="line">gp_Pnt2d p1,p2; </div><div class="line">p1 = gp_Pnt2d(100.,100.); </div><div class="line">p2 = gp_Pnt2d(200.,100.); </div><div class="line">Handle(Geom2d_Line) aline = GCE2d_MakeLine(p1,p2).Value(); </div><div class="line"></div><div class="line">MW1.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,p1.Distance(p2))); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt2d(150.,200.); </div><div class="line">aline = GCE2d_MakeLine(p1,p2).Value(); </div><div class="line"></div><div class="line">MW1.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,p1.Distance(p2))); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt2d(100.,100.); </div><div class="line">aline = GCE2d_MakeLine(p1,p2).Value(); </div><div class="line"></div><div class="line">MW1.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,p1.Distance(p2))); </div><div class="line">BRepBuilderAPI_MakeFace MKF1; </div><div class="line">MKF1.Init(surf,Standard_False); </div><div class="line">MKF1.Add(MW1.Wire()); </div><div class="line">TopoDS_Face FP = MKF1.Face(); </div><div class="line">BRepLib::BuildCurves3d(FP); </div><div class="line">TColgp_Array1OfPnt CurvePoles(1,3); </div><div class="line">gp_Pnt pt = gp_Pnt(150.,0.,150.); </div><div class="line">CurvePoles(1) = pt; </div><div class="line">pt = gp_Pnt(200.,100.,150.); </div><div class="line">CurvePoles(2) = pt; </div><div class="line">pt = gp_Pnt(150.,200.,150.); </div><div class="line">CurvePoles(3) = pt; </div><div class="line">Handle(Geom_BezierCurve) curve = new Geom_BezierCurve </div><div class="line">(CurvePoles); </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(curve); </div><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakeWire(E); </div><div class="line">BRepFeat_MakePipe MKPipe (S,FP,F1,W,Standard_False, </div><div class="line">Standard_True); </div><div class="line">MKPipe.Perform(); </div><div class="line">TopoDS_Shape res1 = MKPipe.Shape(); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image050.png" alt="modeling_algos_image050.png"/>
<div class="caption">
Pipe depression</div></div>
 <h2><a class="anchor" id="occt_modalg_9_2"></a>
Mechanical Features</h2>
<p>Mechanical features include ribs, protrusions and grooves (or slots), depressions along planar (linear) surfaces or revolution surfaces.</p>
<p>The semantics of mechanical features is built around giving thickness to a contour. This thickness can either be symmetrical &ndash; on one side of the contour &ndash; or dissymmetrical &ndash; on both sides. As in the semantics of form features, the thickness is defined by construction of shapes in specific contexts.</p>
<p>The development contexts differ, however, in the case of mechanical features. Here they include extrusion:</p><ul>
<li>to a limiting face of the basis shape;</li>
<li>to or from a limiting plane;</li>
<li>to a height.</li>
</ul>
<p>A class object is created or initialized from</p><ul>
<li>a shape (basic shape);</li>
<li>a wire (base of rib or groove);</li>
<li>a plane (plane of the wire);</li>
<li>direction1 (a vector along which thickness will be built up);</li>
<li>direction2 (vector opposite to the previous one along which thickness will be built up, may be null);</li>
<li>a Boolean indicating the type of operation (fusion=rib or cut=groove) on the basic shape;</li>
<li>another Boolean indicating if self-intersections have to be found (not used in every case).</li>
</ul>
<h3><a class="anchor" id="occt_modalg_9_2_1"></a>
Linear Form</h3>
<p>Linear form is implemented in <em>MakeLinearForm</em> class, which creates a rib or a groove along a planar surface. There is one <em>Perform()</em> method, which performs a prism from the wire along the <em>direction1</em> and <em>direction2</em> interacting with base shape <em>Sbase</em>. The height of the prism is <em>Magnitude(Direction1)+Magnitude(direction2)</em>.</p>
<div class="fragment"><div class="line">BRepBuilderAPI_MakeWire mkw; </div><div class="line">gp_Pnt p1 = gp_Pnt(0.,0.,0.); </div><div class="line">gp_Pnt p2 = gp_Pnt(200.,0.,0.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(200.,0.,50.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(50.,0.,50.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(50.,0.,200.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(0.,0.,200.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p2,gp_Pnt(0.,0.,0.))); </div><div class="line">TopoDS_Shape S = BRepBuilderAPI_MakePrism(BRepBuilderAPI_MakeFace </div><div class="line">    (mkw.Wire()),gp_Vec(gp_Pnt(0.,0.,0.),gp_P </div><div class="line">     nt(0.,100.,0.))); </div><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakeWire(BRepBuilderAPI_MakeEdge(gp_Pnt </div><div class="line">    (50.,45.,100.), </div><div class="line">gp_Pnt(100.,45.,50.))); </div><div class="line">Handle(Geom_Plane) aplane = </div><div class="line">    new Geom_Plane(gp_Pnt(0.,45.,0.),  gp_Vec(0.,1.,0.)); </div><div class="line">BRepFeat_MakeLinearForm aform(S, W, aplane, gp_Dir </div><div class="line">    (0.,5.,0.), gp_Dir(0.,-3.,0.),  1, Standard_True); </div><div class="line">aform.Perform(); </div><div class="line">TopoDS_Shape res = aform.Shape(); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image051.png" alt="modeling_algos_image051.png"/>
<div class="caption">
Creating a rib</div></div>
 <h3><a class="anchor" id="occt_modalg_9_2_3"></a>
Gluer</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___gluer.html">BRepFeat_Gluer</a></em> allows gluing two solids along faces. The contact faces of the glued shape must not have parts outside the contact faces of the basic shape. Upon completion the algorithm gives the glued shape with cut out parts of faces inside the shape.</p>
<p>The class is created or initialized from two shapes: the “glued” shape and the basic shape (on which the other shape is glued). Two <em>Bind</em> methods are used to bind a face of the glued shape to a face of the basic shape and an edge of the glued shape to an edge of the basic shape.</p>
<p><b>Note</b> that every face and edge has to be bounded, if two edges of two glued faces are coincident they must be explicitly bounded.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...; // the basic shape </div><div class="line">TopoDS_Shape Sglued = ...; // the glued shape </div><div class="line"></div><div class="line">TopTools_ListOfShape Lfbase; </div><div class="line">TopTools_ListOfShape Lfglued; </div><div class="line">// Determination of the glued faces </div><div class="line">... </div><div class="line"></div><div class="line">BRepFeat_Gluer theGlue(Sglue, Sbase); </div><div class="line">TopTools_ListIteratorOfListOfShape itlb(Lfbase); </div><div class="line">TopTools_ListIteratorOfListOfShape itlg(Lfglued); </div><div class="line">for (; itlb.More(); itlb.Next(), itlg(Next()) { </div><div class="line">const TopoDS_Face&amp; f1 = TopoDS::Face(itlg.Value()); </div><div class="line">const TopoDS_Face&amp; f2 = TopoDS::Face(itlb.Value()); </div><div class="line">theGlue.Bind(f1,f2); </div><div class="line">// for example, use the class FindEdges from LocOpe to </div><div class="line">// determine coincident edges </div><div class="line">LocOpe_FindEdge fined(f1,f2); </div><div class="line">for (fined.InitIterator(); fined.More(); fined.Next()) { </div><div class="line">theGlue.Bind(fined.EdgeFrom(),fined.EdgeTo()); </div><div class="line">} </div><div class="line">} </div><div class="line">theGlue.Build(); </div><div class="line">if (theGlue.IsDone() { </div><div class="line">TopoDS_Shape  theResult = theGlue; </div><div class="line">... </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_9_2_4"></a>
Split Shape</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___split_shape.html">BRepFeat_SplitShape</a></em> is used to split faces of a shape into wires or edges. The shape containing the new entities is rebuilt, sharing the unmodified ones.</p>
<p>The class is created or initialized from a shape (the basic shape). Three Add methods are available:</p><ul>
<li><em>Add(Wire, Face)</em> &ndash; adds a new wire on a face of the basic shape.</li>
<li><em>Add(Edge, Face)</em> &ndash; adds a new edge on a face of the basic shape.</li>
<li><em>Add(EdgeNew, EdgeOld)</em> &ndash; adds a new edge on an existing one (the old edge must contain the new edge).</li>
</ul>
<p><b>Note</b> The added wires and edges must define closed wires on faces or wires located between two existing edges. Existing edges must not be intersected.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...; // basic shape </div><div class="line">TopoDS_Face Fsplit = ...; // face of Sbase </div><div class="line">TopoDS_Wire Wsplit = ...; // new wire contained in Fsplit </div><div class="line">BRepFeat_SplitShape Spls(Sbase); </div><div class="line">Spls.Add(Wsplit, Fsplit); </div><div class="line">TopoDS_Shape theResult = Spls; </div><div class="line">...</div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_10"></a>
Hidden Line  Removal</h1>
<p>To provide the precision required in industrial design, drawings need to offer the possibility of removing lines, which are hidden in a given projection.</p>
<p>For this the Hidden Line Removal component provides two algorithms: <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em>.</p>
<p>These algorithms are based on the principle of comparing each edge of the shape to be visualized with each of its faces, and calculating the visible and the hidden parts of each edge. Note that these are not the algorithms used in generating shading, which calculate the visible and hidden parts of each face in a shape to be visualized by comparing each face in the shape with every other face in the same shape. These algorithms operate on a shape and remove or indicate edges hidden by faces. For a given projection, they calculate a set of lines characteristic of the object being represented. They are also used in conjunction with extraction utilities, which reconstruct a new, simplified shape from a selection of the results of the calculation. This new shape is made up of edges, which represent the shape visualized in the projection.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> allows working with the shape itself, whereas <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> works with a polyhedral simplification of the shape. When you use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em>, you obtain an exact result, whereas, when you use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em>, you reduce the computation time, but obtain polygonal segments.</p>
<p>No smoothing algorithm is provided. Consequently, a polyhedron will be treated as such and the algorithms will give the results in form of line segments conforming to the mathematical definition of the polyhedron. This is always the case with <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em>.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> can deal with any kind of object, for example, assemblies of volumes, surfaces, and lines, as long as there are no unfinished objects or points within it.</p>
<p>However, there some restrictions in HLR use:</p><ul>
<li>Points are not processed;</li>
<li>Infinite faces or lines are not processed.</li>
</ul>
<div class="image">
<img src="modeling_algos_image052.png" alt="modeling_algos_image052.png"/>
<div class="caption">
,"Sharp, smooth and sewn edges  in a simple screw shape",320</div></div>
<div class="image">
<img src="modeling_algos_image053.png" alt="modeling_algos_image053.png"/>
<div class="caption">
Outline edges and isoparameters in the same shape</div></div>
 <div class="image">
<img src="modeling_algos_image054.png" alt="modeling_algos_image054.png"/>
<div class="caption">
A simple screw shape seen with shading</div></div>
 <div class="image">
<img src="modeling_algos_image055.png" alt="modeling_algos_image055.png"/>
<div class="caption">
An extraction showing hidden sharp edges</div></div>
<p>The following services are related to Hidden Lines Removal :</p>
<h3>Loading Shapes</h3>
<p>To pass a <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> to an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> object, use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html#a0eadaefc85e28011fce6a08077d2a2b0">HLRBRep_Algo::Add</a></em>. With an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> object, use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html#a56179512a3ad0dae960185e54227c33b">HLRBRep_PolyAlgo::Load</a></em>. If you wish to add several shapes, use Add or Load as often as necessary.</p>
<h3>Setting view parameters</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___internal_algo.html#a8e2bbecb941db0a6b20d7a9d56cc0275">HLRBRep_Algo::Projector</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html#ac523c08aa18008c7f1b2a8aa8d7771fb">HLRBRep_PolyAlgo::Projector</a></em> set a projector object which defines the parameters of the view. This object is an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_algo___projector.html">HLRAlgo_Projector</a></em>.</p>
<h3>Computing the projections</h3>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html#a4ca601b6c97f27d62e2bea14c36f0820">HLRBRep_PolyAlgo::Update</a></em> launches the calculation of outlines of the shape visualized by the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> framework.</p>
<p>In the case of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em>, use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___internal_algo.html#abff0f03c57628a1748cb5066865aacbb">HLRBRep_Algo::Update</a></em>. With this algorithm, you must also call the method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___internal_algo.html#aef401192a7b5f910dc8682a1b8426f05">HLRBRep_Algo::Hide</a></em> to calculate visible and hidden lines of the shape to be visualized. With an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> object, visible and hidden lines are computed by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html">HLRBRep_PolyHLRToShape</a></em>.</p>
<h3>Extracting edges</h3>
<p>The classes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___h_l_r_to_shape.html">HLRBRep_HLRToShape</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html">HLRBRep_PolyHLRToShape</a></em> present a range of extraction filters for an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a> object</em> and an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> object, respectively. They highlight the type of edge from the results calculated by the algorithm on a shape. With both extraction classes, you can highlight the following types of output:</p><ul>
<li>visible/hidden sharp edges;</li>
<li>visible/hidden smooth edges;</li>
<li>visible/hidden sewn edges;</li>
<li>visible/hidden outline edges.</li>
</ul>
<p>To perform extraction on an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html">HLRBRep_PolyHLRToShape</a></em> object, use <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html#a8114cd998c5f8a42f2f4b9745f9585a4">HLRBRep_PolyHLRToShape::Update</a></em> function.</p>
<p>For an <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___h_l_r_to_shape.html">HLRBRep_HLRToShape</a></em> object built from an <em>HLRBRepAlgo</em> object you can also highlight:</p><ul>
<li>visible isoparameters and</li>
<li>hidden isoparameters.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_10_1"></a>
Examples</h2>
<h3><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></h3>
<div class="fragment"><div class="line">// Build The algorithm object </div><div class="line">myAlgo = new HLRBRep_Algo(); </div><div class="line"></div><div class="line">// Add Shapes into the algorithm </div><div class="line">TopTools_ListIteratorOfListOfShape anIterator(myListOfShape); </div><div class="line">for (;anIterator.More();anIterator.Next()) </div><div class="line">myAlgo-Add(anIterator.Value(),myNbIsos); </div><div class="line"></div><div class="line">// Set The Projector (myProjector is a </div><div class="line">HLRAlgo_Projector) </div><div class="line">myAlgo-Projector(myProjector); </div><div class="line"></div><div class="line">// Build HLR </div><div class="line">myAlgo-&gt;Update(); </div><div class="line"></div><div class="line">// Set The Edge Status </div><div class="line">myAlgo-&gt;Hide(); </div><div class="line"></div><div class="line">// Build the extraction object : </div><div class="line">HLRBRep_HLRToShape aHLRToShape(myAlgo); </div><div class="line"></div><div class="line">// extract the results : </div><div class="line">TopoDS_Shape VCompound           = aHLRToShape.VCompound(); </div><div class="line">TopoDS_Shape Rg1LineVCompound                            = </div><div class="line">aHLRToShape.Rg1LineVCompound(); </div><div class="line">TopoDS_Shape RgNLineVCompound                            = </div><div class="line">aHLRToShape.RgNLineVCompound(); </div><div class="line">TopoDS_Shape OutLineVCompound                            = </div><div class="line">aHLRToShape.OutLineVCompound(); </div><div class="line">TopoDS_Shape IsoLineVCompound                            = </div><div class="line">aHLRToShape.IsoLineVCompound(); </div><div class="line">TopoDS_Shape HCompound           = aHLRToShape.HCompound(); </div><div class="line">TopoDS_Shape Rg1LineHCompound                            = </div><div class="line">aHLRToShape.Rg1LineHCompound(); </div><div class="line">TopoDS_Shape RgNLineHCompound                            = </div><div class="line">aHLRToShape.RgNLineHCompound(); </div><div class="line">TopoDS_Shape OutLineHCompound                            = </div><div class="line">aHLRToShape.OutLineHCompound(); </div><div class="line">TopoDS_Shape IsoLineHCompound                            = </div><div class="line">aHLRToShape.IsoLineHCompound(); </div></div><!-- fragment --><h3><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></h3>
<div class="fragment"><div class="line">// Build The algorithm object </div><div class="line">myPolyAlgo = new HLRBRep_PolyAlgo(); </div><div class="line"></div><div class="line">// Add Shapes into the algorithm </div><div class="line">TopTools_ListIteratorOfListOfShape </div><div class="line">anIterator(myListOfShape); </div><div class="line">for (;anIterator.More();anIterator.Next()) </div><div class="line">myPolyAlgo-Load(anIterator.Value()); </div><div class="line"></div><div class="line">// Set The Projector (myProjector is a </div><div class="line">HLRAlgo_Projector) </div><div class="line">myPolyAlgo-&gt;Projector(myProjector); </div><div class="line"></div><div class="line">// Build HLR </div><div class="line">myPolyAlgo-&gt;Update(); </div><div class="line"></div><div class="line">// Build the extraction object : </div><div class="line">HLRBRep_PolyHLRToShape aPolyHLRToShape; </div><div class="line">aPolyHLRToShape.Update(myPolyAlgo); </div><div class="line"></div><div class="line">// extract the results : </div><div class="line">TopoDS_Shape VCompound = </div><div class="line">aPolyHLRToShape.VCompound(); </div><div class="line">TopoDS_Shape Rg1LineVCompound = </div><div class="line">aPolyHLRToShape.Rg1LineVCompound(); </div><div class="line">TopoDS_Shape RgNLineVCompound = </div><div class="line">aPolyHLRToShape.RgNLineVCompound(); </div><div class="line">TopoDS_Shape OutLineVCompound = </div><div class="line">aPolyHLRToShape.OutLineVCompound(); </div><div class="line">TopoDS_Shape HCompound = </div><div class="line">aPolyHLRToShape.HCompound(); </div><div class="line">TopoDS_Shape Rg1LineHCompound = </div><div class="line">aPolyHLRToShape.Rg1LineHCompound(); </div><div class="line">TopoDS_Shape RgNLineHCompound = </div><div class="line">aPolyHLRToShape.RgNLineHCompound(); </div><div class="line">TopoDS_Shape OutLineHCompound = </div><div class="line">aPolyHLRToShape.OutLineHCompound(); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_11"></a>
Meshing</h1>
<h2><a class="anchor" id="occt_modalg_11_1"></a>
Mesh presentations</h2>
<p>In addition to support of exact geometrical representation of 3D objects Open CASCADE Technology provides functionality to work with tessellated representations of objects in form of meshes.</p>
<p>Open CASCADE Technology mesh functionality provides:</p><ul>
<li>data structures to store surface mesh data associated to shapes, and some basic algorithms to handle these data</li>
<li>data structures and algorithms to build surface triangular mesh from <em>BRep</em> objects (shapes).</li>
<li>tools to extend 3D visualization capabilities of Open CASCADE Technology with displaying meshes along with associated pre- and post-processor data.</li>
</ul>
<p>Open CASCADE Technology includes two mesh converters:</p><ul>
<li>VRML converter translates Open CASCADE shapes to VRML 1.0 files (Virtual Reality Modeling Language). Open CASCADE shapes may be translated in two representations: shaded or wireframe. A shaded representation present shapes as sets of triangles computed by a mesh algorithm while a wireframe representation present shapes as sets of curves.</li>
<li>STL converter translates Open CASCADE shapes to STL files. STL (STtereoLithography) format is widely used for rapid prototyping.</li>
</ul>
<p>Open CASCADE SAS also offers Advanced Mesh Products:</p><ul>
<li><a href="https://www.opencascade.com/content/mesh-framework">Open CASCADE Mesh Framework (OMF)</a></li>
<li><a href="https://www.opencascade.com/content/express-mesh">Express Mesh</a></li>
</ul>
<p>Besides, we can efficiently help you in the fields of surface and volume meshing algorithms, mesh optimization algorithms etc. If you require a qualified advice about meshing algorithms, do not hesitate to benefit from the expertise of our team in that domain.</p>
<p>The projects dealing with numerical simulation can benefit from using SALOME - an Open Source Framework for CAE with CAD data interfaces, generic Pre- and Post- F.E. processors and API for integrating F.E. solvers.</p>
<p>Learn more about SALOME platform on <a href="https://www.salome-platform.org">https://www.salome-platform.org</a></p>
<h2><a class="anchor" id="occt_modalg_11_2"></a>
Meshing algorithm</h2>
<p>The algorithm of shape triangulation is provided by the functionality of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___incremental_mesh.html">BRepMesh_IncrementalMesh</a></em> class, which adds a triangulation of the shape to its topological data structure. This triangulation is used to visualize the shape in shaded mode.</p>
<div class="fragment"><div class="line">#include &lt;IMeshData_Status.hxx&gt;</div><div class="line">#include &lt;IMeshTools_Parameters.hxx&gt;</div><div class="line">#include &lt;BRepMesh_IncrementalMesh.hxx&gt;</div><div class="line"></div><div class="line">Standard_Boolean meshing_explicit_parameters()</div><div class="line">{</div><div class="line">  const Standard_Real aRadius = 10.0; </div><div class="line">  const Standard_Real aHeight = 25.0; </div><div class="line">  BRepPrimAPI_MakeCylinder aCylinder(aRadius, aHeight); </div><div class="line">  TopoDS_Shape aShape = aCylinder.Shape();</div><div class="line"></div><div class="line">  const Standard_Real aLinearDeflection   = 0.01;</div><div class="line">  const Standard_Real anAngularDeflection = 0.5;</div><div class="line">  BRepMesh_IncrementalMesh aMesher (aShape, aLinearDeflection, Standard_False, anAngularDeflection, Standard_True);</div><div class="line">  const Standard_Integer aStatus = aMesher.GetStatusFlags();</div><div class="line">  return !aStatus;</div><div class="line">}</div><div class="line"></div><div class="line">Standard_Boolean meshing_imeshtools_parameters()</div><div class="line">{</div><div class="line">  const Standard_Real aRadius = 10.0; </div><div class="line">  const Standard_Real aHeight = 25.0; </div><div class="line">  BRepPrimAPI_MakeCylinder aCylinder(aRadius, aHeight); </div><div class="line">  TopoDS_Shape aShape = aCylinder.Shape();</div><div class="line"></div><div class="line">  IMeshTools_Parameters aMeshParams;</div><div class="line">  aMeshParams.Deflection               = 0.01;</div><div class="line">  aMeshParams.Angle                    = 0.5;</div><div class="line">  aMeshParams.Relative                 = Standard_False;</div><div class="line">  aMeshParams.InParallel               = Standard_True;</div><div class="line">  aMeshParams.MinSize                  = Precision::Confusion();</div><div class="line">  aMeshParams.InternalVerticesMode     = Standard_True;</div><div class="line">  aMeshParams.ControlSurfaceDeflection = Standard_True;</div><div class="line"></div><div class="line">  BRepMesh_IncrementalMesh aMesher (aShape, aMeshParams);</div><div class="line">  const Standard_Integer aStatus = aMesher.GetStatusFlags();</div><div class="line">  return !aStatus;</div><div class="line">}</div></div><!-- fragment --><p>The default meshing algorithm <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___incremental_mesh.html">BRepMesh_IncrementalMesh</a></em> has two major options to define triangulation &ndash; linear and angular deflections.</p>
<p>At the first step all edges from a face are discretized according to the specified parameters.</p>
<p>At the second step, the faces are tessellated. Linear deflection limits the distance between a curve and its tessellation, whereas angular deflection limits the angle between subsequent segments in a polyline.</p>
<div class="image">
<img src="modeling_algos_image056.png" alt="modeling_algos_image056.png"/>
<div class="caption">
Deflection parameters of BRepMesh_IncrementalMesh algorithm</div></div>
<p> There are additional options to control behavior of the meshing of face interior: <em>DeflectionInterior</em> and <em>AngleInterior</em>. <em>DeflectionInterior</em> limits the distance between triangles and the face interior. <em>AngleInterior</em> (used for tessellation of B-spline faces only) limits the angle between normals (N1, N2 and N3 in the picture) in the nodes of every link of the triangle. There is an exception for the links along the face boundary edges, "Angular Deflection" is used for them during edges discretization.</p>
<div class="image">
<img src="modeling_algos_image057.png" alt="modeling_algos_image057.png"/>
<div class="caption">
Linear and angular interior deflections</div></div>
<p> Note that if a given value of linear deflection is less than shape tolerance then the algorithm will skip this value and will take into account the shape tolerance.</p>
<p>The application should provide deflection parameters to compute a satisfactory mesh. Angular deflection is relatively simple and allows using a default value (12-20 degrees). Linear deflection has an absolute meaning and the application should provide the correct value for its models. Giving small values may result in a too huge mesh (consuming a lot of memory, which results in a long computation time and slow rendering) while big values result in an ugly mesh.</p>
<p>For an application working in dimensions known in advance it can be reasonable to use the absolute linear deflection for all models. This provides meshes according to metrics and precision used in the application (for example, it it is known that the model will be stored in meters, 0.004 m is enough for most tasks).</p>
<p>However, an application that imports models created in other applications may not use the same deflection for all models. Note that actually this is an abnormal situation and this application is probably just a viewer for CAD models with dimensions varying by an order of magnitude. This problem can be solved by introducing the concept of a relative linear deflection with some LOD (level of detail). The level of detail is a scale factor for absolute deflection, which is applied to model dimensions.</p>
<p>Meshing covers a shape with a triangular mesh. Other than hidden line removal, you can use meshing to transfer the shape to another tool: a manufacturing tool, a shading algorithm, a finite element algorithm, or a collision algorithm.</p>
<p>You can obtain information on the shape by first exploring it. To access triangulation of a face in the shape later, use <em>BRepTool::Triangulation</em>. To access a polygon, which is the approximation of an edge of the face, use <em>BRepTool::PolygonOnTriangulation</em>.</p>
<h2><a class="anchor" id="occt_modalg_11_3"></a>
BRepMesh Architecture</h2>
<h3><a class="anchor" id="occt_modalg_11_3_1"></a>
Goals</h3>
<p>The main goals of the chosen architecture are:</p><ul>
<li>Remove tight connections between data structures, auxiliary tools and algorithms to create an extensible solution, easy for maintenance and improvements;</li>
<li>Separate the code among several functional units responsible for specific operation for the sake of simplification of debugging and readability;</li>
<li>Introduce new data structures enabling the possibility to manipulate a discrete model of a particular entity (edge, wire, face) in order to perform computations locally instead of processing the entire model;</li>
<li>Implement a new triangulation algorithm replacing the existing functionality that contains overcomplicated solutions that need to be moved to the upper level. In addition, provide the possibility to change the algorithm depending on surface type (initially to speed up meshing of planes).</li>
</ul>
<h3><a class="anchor" id="occt_modalg_11_3_2"></a>
General workflow</h3>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_001.svg">modeling_algos_mesh_001.svg</object>
<div class="caption">
General workflow of BRepMesh component</div></div>
<p> Generally, the workflow of the component can be divided into six parts:</p><ul>
<li><b>Creation of model data structure</b>: source <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> passed to algorithm is analyzed and exploded into faces and edges. The reflection corresponding to each topological entity is created in the data model. Note that underlying algorithms use the data model as input and access it via a common interface which allows creating a custom data model with necessary dependencies between particular entities (see the paragraph "Data model interface");</li>
<li><b>Discretize edges 3D &amp; 2D curves</b>: 3D curve as well as an associated set of 2D curves of each model edge is discretized in order to create a coherent skeleton used as a base in face meshing process. If an edge of the source shape already contains polygonal data which suits the specified parameters, it is extracted from the shape and stored in the model as is. Each edge is processed separately, the adjacency is not taken into account;</li>
<li><b>Heal discrete model</b>: the source <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> can contain problems, such as open wires or self-intersections, introduced during design, exchange or modification of model. In addition, some problems like self-intersections can be introduced by roughly discretized edges. This stage is responsible for analysis of a discrete model in order to detect and repair problems or to refuse further processing of a model part in case if a problem cannot be solved;</li>
<li><b>Preprocess discrete model</b>: defines actions specific to the implemented approach to be performed before meshing of faces. By default, this operation iterates over model faces, checks the consistency of existing triangulations and cleans topological faces and adjacent edges from polygonal data in case of inconsistency or marks a face of the discrete model as not required for the computation;</li>
<li><b>Discretize faces</b>: represents the core part performing mesh generation for a particular face based on 2D discrete data. This operation caches polygonal data associated with face edges in the data model for further processing and stores the generated mesh to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___face.html">TopoDS_Face</a></em>;</li>
<li><b>Postprocess discrete model</b>: defines actions specific for the implemented approach to be performed after meshing of faces. By default, this operation stores polygonal data obtained at the previous stage to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> objects of the source model.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_11_3_3"></a>
Common interfaces</h3>
<p>The component structure contains two units: <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespace_i_mesh_data.html">IMeshData</a></em> (see Data model interface) and <em>IMeshTools</em>, defining common interfaces for the data model and algorithmic tools correspondingly. Class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___context.html">IMeshTools_Context</a></em> represents a connector between these units. The context class caches the data model as well as the tools corresponding to each of six stages of the workflow mentioned above and provides methods to call the corresponding tool safely (designed similarly to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___context.html">IntTools_Context</a></em> in order to keep consistency with OCCT core tools). All stages, except for the first one, use the data model as input and perform a specific action on the entire structure. Thus, API class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___model_algo.html">IMeshTools_ModelAlgo</a></em> is defined in order to unify the interface of tools manipulating the data model. Each tool supposed to process the data model should inherit this interface enabling the possibility to cache it in context. In contrast to others, the model builder interface is defined by another class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___model_builder.html">IMeshTools_ModelBuilder</a></em> due to a different meaning of the stage. The entry point starting the entire workflow is represented by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___mesh_builder.html">IMeshTools_MeshBuilder</a></em>.</p>
<p>The default implementation of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___context.html">IMeshTools_Context</a></em> is given in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___context.html">BRepMesh_Context</a></em> class initializing the context by instances of default algorithmic tools.</p>
<p>The factory interface <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___mesh_algo_factory.html">IMeshTools_MeshAlgoFactory</a></em> gives the possibility to change the triangulation algorithm for a specific surface. The factory returns an instance of the triangulation algorithm via <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___mesh_algo.html">IMeshTools_MeshAlgo</a></em> interface depending on the type of surface passed as parameter. It is supposed to be used at the face discretization stage.</p>
<p>The default implementation of AlgoFactory is given in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___mesh_algo_factory.html">BRepMesh_MeshAlgoFactory</a></em> returning algorithms of different complexity chosen according to the passed surface type. In its turn, it is used as the initializer of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___face_discret.html">BRepMesh_FaceDiscret</a></em> algorithm representing the starter of face discretization stage.</p>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_002.svg">modeling_algos_mesh_002.svg</object>
<div class="caption">
Interface describing entry point to meshing workflow</div></div>
<p> Remaining interfaces describe auxiliary tools:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___curve_tessellator.html">IMeshTools_CurveTessellator</a></em>: provides a common interface to the algorithms responsible for creation of discrete polygons on 3D and 2D curves as well as tools for extraction of existing polygons from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> allowing to obtain discrete points and the corresponding parameters on curve regardless of the implementation details (see examples of usage of derived classes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___curve_tessellator.html">BRepMesh_CurveTessellator</a></em>, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___edge_tessellation_extractor.html">BRepMesh_EdgeTessellationExtractor</a></em> in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___edge_discret.html">BRepMesh_EdgeDiscret</a></em>);</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___shape_explorer.html">IMeshTools_ShapeExplorer</a></em>: the last two interfaces represent visitor design pattern and are intended to separate iteration over elements of topological shape (edges and faces) from the operations performed on a particular element;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___shape_visitor.html">IMeshTools_ShapeVisitor</a></em>: provides a common interface for operations on edges and faces of the target topological shape. It can be used in couple with <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___shape_explorer.html">IMeshTools_ShapeExplorer</a></em>. The default implementation available in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___shape_visitor.html">BRepMesh_ShapeVisitor</a></em> performs initialization of the data model. The advantage of such approach is that the implementation of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___shape_visitor.html">IMeshTools_ShapeVisitor</a></em> can be changed according to the specific data model whereas the shape explorer implementation remains the same.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_11_3_4"></a>
Create model data structure</h3>
<p>The data structures intended to keep discrete and temporary data required by underlying algorithms are created at the first stage of the meshing procedure. Generally, the model represents dependencies between entities of the source topological shape suitable for the target task.</p>
<h4>Data model interface</h4>
<p>Unit <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespace_i_mesh_data.html">IMeshData</a></em> provides common interfaces specifying the data model API used on different stages of the entire workflow. Dependencies and references of the designed interfaces are given in the figure below. A specific interface implementation depends on the target application which allows the developer to implement different models and use custom low-level data structures, e.g. different collections, either <em>NCollection</em> or STL. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_data___shape.html">IMeshData_Shape</a></em> is used as the base class for all data structures and tools keeping the topological shape in order to avoid possible copy-paste.</p>
<p>The default implementation of interfaces is given in <em>BRepMeshData</em> unit. The main aim of the default data model is to provide features performing discretization of edges in a parallel mode. Thus, curve, pcurve and other classes are based on STL containers and smart-pointers as far as <em>NCollection</em> does not provide thread-safety for some cases (e.g. <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sequence.html">NCollection_Sequence</a></em>). In addition, it closely reflects topology of the source shape, i.e. the number of edges in the data model is equal to the number of edges in the source model; each edge contains a set of pcurves associated with its adjacent faces which allows creation of discrete polygons for all pcurves or the 3D curve of a particular edge in a separate thread.</p>
<p><b>Advantages</b>: In case of necessity, the data model (probably with algorithms for its processing) can be easily substituted by another implementation supporting another kind of dependencies between elements.</p>
<p>An additional example of a different data model is the case when it is not required to create a mesh with discrete polygons synchronized between adjacent faces, i.e. in case of necessity to speed up creation of a rough per-face tessellation used for visualization or quick computation only (the approach used in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_x_d_e_d_r_a_w___props.html">XDEDRAW_Props</a></em>).</p>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_003.svg">modeling_algos_mesh_003.svg</object>
<div class="caption">
Common API of data model</div></div>
 <h4>Collecting data model</h4>
<p>At this stage the data model is filled by entities according to the topological structure of the source shape. A default implementation of the data model is given in <em>BRepMeshData</em> unit and represents the model as two sets: a set of edges and a set of faces. Each face consists of one or several wires, the first of which always represents the outer wire, while others are internal. In its turn, each wire depicts the ordered sequence of oriented edges. Each edge is characterized by a single 3D curve and zero (in case of free edge) or more 2D curves associated with faces adjacent to this edge. Both 3D and 2D curves represent a set of pairs point-parameter defined in 3D and 2D space of the reference face correspondingly. An additional difference between a curve and a pcurve is that the latter has a reference to the face it is defined for.</p>
<p>Model filler algorithm is represented by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___shape_visitor.html">BRepMesh_ShapeVisitor</a></em> class creating the model as a reflection to topological shape with help of <em>BRepMesh_ShapeExplorer</em> performing iteration over edges and faces of the target shape. Note that the algorithm operates on a common interface of the data model and creates a structure without any knowledge about the implementation details and underlying data structures. The entry point to collecting functionality is <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___model_builder.html">BRepMesh_ModelBuilder</a></em> class.</p>
<h3><a class="anchor" id="occt_modalg_11_3_5"></a>
Discretize edges 3D &amp; 2D curves</h3>
<p>At this stage only the edges of the data model are considered. Each edge is processed separately (with the possibility to run processing in multiple threads). The edge is checked for existing polygonal data. In case if at least one representation exists and suits the meshing parameters, it is recuperated and used as reference data for tessellation of the whole set of pcurves as well as 3D curve assigned to the edge (see <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___edge_tessellation_extractor.html">BRepMesh_EdgeTessellationExtractor</a></em>). Otherwise, a new tessellation algorithm is created and used to generate the initial polygon (see <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___curve_tessellator.html">BRepMesh_CurveTessellator</a></em>) and the edge is marked as outdated. In addition, the model edge is updated by deflection as well as recomputed same range, same parameter and degeneracy parameters. See <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___edge_discret.html">BRepMesh_EdgeDiscret</a></em> for implementation details.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespace_i_mesh_data.html">IMeshData</a></em> unit defines interface <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_data___parameters_list_array_adaptor.html">IMeshData_ParametersListArrayAdaptor</a></em>, which is intended to adapt arbitrary data structures to the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></em> container API. This solution is made to use both <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_data___curve.html">IMeshData_Curve</a></em> as the source for <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___edge_parameter_provider.html">BRepMesh_EdgeParameterProvider</a></em> tool intended to generate a consistent parametrization taking into account the same parameter property.</p>
<h3><a class="anchor" id="occt_modalg_11_3_6"></a>
Heal discrete model</h3>
<p>In general, this stage represents a set of operations performed on the entire discrete model in order to resolve inconsistencies due to the problems caused by design, translation or rough discretization. A different sequence of operations can be performed depending on the target triangulation algorithm, e.g. there are different approaches to process self-intersections – either to amplify edges discretization by decreasing the target precision or to split links at the intersection points. At this stage the whole set of edges is considered in aggregate and their adjacency is taken into account. A default implementation of the model healer is given in <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___model_healer.html">BRepMesh_ModelHealer</a></em> which performs the following actions:</p><ul>
<li>Iterates over model faces and checks their wires for consistency, i.e. whether the wires are closed and do not contain self-intersections. The data structures are designed free of collisions, thus it is possible to run processing in a parallel mode;</li>
<li>Forcibly connects the ends of adjacent edges in the parametric space, closing gaps between possible disconnected parts. The aim of this operation is to create a correct discrete model defined relatively to the parametric space of the target face taking into account connectivity and tolerances of 3D space only. This means that no specific computations are made to determine U and V tolerance;</li>
<li>Registers intersections on edges forming the face shape. Two solutions are possible in order to resolve self-intersection:<ul>
<li>Decrease deflection of a particular edge and update its discrete model. After that the workflow "intersection check – amplification" is repeated up to 5 times. As the result, target edges contain a finer tessellation and meshing continues or the face is marked by <em>IMeshData_SelfIntersectingWire</em> status and refused from further processing;</li>
<li>Split target edges by intersection point and synchronize the updated polygon with curve and remaining pcurves associated to each edge. This operation presents a more robust solution comparing to the amplification procedure with a guaranteed result, but it is more difficult for implementation from the point of view of synchronization functionality.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="occt_modalg_11_3_7"></a>
Preprocess discrete model</h3>
<p>This stage implements actions to be performed before meshing of faces. Depending on target goals it can be changed or omitted. By default, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___model_pre_processor.html">BRepMesh_ModelPreProcessor</a></em> implements the functionality checking topological faces for consistency of existing triangulation, i.e.: consistency with the target deflection parameter; indices of nodes referenced by triangles do not exceed the number of nodes stored in a triangulation. If the face fails some checks, it is cleaned from triangulation and its adjacent edges are cleaned from existing polygons. This does not affect a discrete model and does not require any recomputation as the model keeps tessellations for the whole set of edges despite consistency of their polygons.</p>
<h3><a class="anchor" id="occt_modalg_11_3_8"></a>
Discretize faces</h3>
<p>Discretization of faces is the general part of meshing algorithm. At this stage edges tessellation data obtained and processed on previous steps is used to form contours of target faces and passed as input to the triangulation algorithm. Default implementation is provided by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___face_discret.html">BRepMesh_FaceDiscret</a></em> class which represents a starter for triangulation algorithm. It iterates over faces available in the data model, creates an instance of the triangulation algorithm according to the type of surface associated with each face via <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___mesh_algo_factory.html">IMeshTools_MeshAlgoFactory</a></em> and executes it. Each face is processed separately, thus it is possible to process faces in a parallel mode. The class diagram of face discretization is given in the figure below.</p>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_004.svg">modeling_algos_mesh_004.svg</object>
<div class="caption">
Class diagram of face discrete stage</div></div>
<p> In general, face meshing algorithms have the following structure:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___base_mesh_algo.html">BRepMesh_BaseMeshAlgo</a></em> implements <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___mesh_algo.html">IMeshTools_MeshAlgo</a></em> interface and the base functionality for inherited algorithms. The main goal of this class is to initialize an instance of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___data_structure_of_delaun.html">BRepMesh_DataStructureOfDelaun</a></em> as well as auxiliary data structures suitable for nested algorithms using face model data passed as input parameter. Despite implementation of triangulation algorithm this structure is currently supposed as common for OCCT. However, the user is free to implement a custom algorithm and supporting data structure accessible via <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_i_mesh_tools___mesh_algo.html">IMeshTools_MeshAlgo</a></em> interface, e.g. to connect a 3-rd party meshing tool that does not support <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> out of box. For this, such structure provides the possibility to distribute connectors to various algorithms in the form of plugins;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___delaunay_base_mesh_algo.html">BRepMesh_DelaunayBaseMeshAlgo</a></em> and <em>BRepMesh_SweepLineMeshAlgo</em> classes implement core meshing functionality operating directly on an instance of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___data_structure_of_delaun.html">BRepMesh_DataStructureOfDelaun</a></em>. The algorithms represent mesh generation tools adding new points from the data structure to the final mesh;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___node_insertion_mesh_algo.html">BRepMesh_NodeInsertionMeshAlgo</a></em> class represents a wrapper intended to extend the algorithm inherited from <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___base_mesh_algo.html">BRepMesh_BaseMeshAlgo</a></em> to enable the functionality generating surface nodes and inserting them into the structure. On this level, an instance of the classification tool is created and can be used to accept-reject internal nodes. In addition, computations necessary for scaling UV coordinates of points relatively to the range specified for the corresponding direction are performed. As far as both triangulation algorithms work on static data provided by the structure, new nodes are added at the initialization stage. Surface nodes are generated by an auxiliary tool called range splitter and passed as template parameter (see Range splitter);</li>
<li>Classes <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___delaunay_node_insertion_mesh_algo.html">BRepMesh_DelaunayNodeInsertionMeshAlgo</a></em> and <em>BRepMesh_SweepLineNodeInsertionMeshAlgo</em> implement algorithm-specific functionality related to addition of internal nodes supplementing functionality provided by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___node_insertion_mesh_algo.html">BRepMesh_NodeInsertionMeshAlgo</a></em>;</li>
<li><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___delaunay_deflection_control_mesh_algo.html">BRepMesh_DelaunayDeflectionControlMeshAlgo</a></em> extends functionality of <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___delaunay_node_insertion_mesh_algo.html">BRepMesh_DelaunayNodeInsertionMeshAlgo</a></em> by additional procedure controlling deflection of generated triangles.</li>
</ul>
<h4>Range splitter</h4>
<p>Range splitter tools provide functionality to generate internal surface nodes defined within the range computed using discrete model data. The base functionality is provided by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___default_range_splitter.html">BRepMesh_DefaultRangeSplitter</a></em> which can be used without modifications in case of planar surface. The default splitter does not generate any internal node.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___cone_range_splitter.html">BRepMesh_ConeRangeSplitter</a></em>, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___cylinder_range_splitter.html">BRepMesh_CylinderRangeSplitter</a></em> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___sphere_range_splitter.html">BRepMesh_SphereRangeSplitter</a></em> are specializations of the default splitter intended for quick generation of internal nodes for the corresponding type of analytical surface.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___u_v_param_range_splitter.html">BRepMesh_UVParamRangeSplitter</a></em> implements base functionality taking discretization points of face border into account for node generation. Its successors <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___torus_range_splitter.html">BRepMesh_TorusRangeSplitter</a> and <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___n_u_r_b_s_range_splitter.html">BRepMesh_NURBSRangeSplitter</a></em> extend the base functionality for toroidal and NURBS surfaces correspondingly.</p>
<h3><a class="anchor" id="occt_modalg_11_3_9"></a>
Postprocess discrete model</h3>
<p>This stage implements actions to be performed after meshing of faces. Depending on target goals it can be changed or omitted. By default, <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___model_post_processor.html">BRepMesh_ModelPostProcessor</a></em> commits polygonal data stored in the data model to <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em>.</p>
<h1><a class="anchor" id="occt_modalg_defeaturing"></a>
3D Model Defeaturing</h1>
<p>The Open CASCADE Technology Defeaturing algorithm is intended for removal of the unwanted parts or features from the model. These parts can be holes, protrusions, gaps, chamfers, fillets, etc.</p>
<p>Feature detection is not performed, and all features to be removed should be defined by the user. The input shape is not modified during Defeaturing, the new shape is built in the result.</p>
<p>On the API level the Defeaturing algorithm is implemented in the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___defeaturing.html">BRepAlgoAPI_Defeaturing</a></em> class. At input the algorithm accepts the shape to remove the features from and the features (one or many) to be removed from the shape. Currently, the input shape should be either SOLID, or COMPSOLID, or COMPOUND of SOLIDs. The features to be removed are defined by the sets of faces forming them. It does not matter how the feature faces are given: as separate faces or their collections. The faces should belong to the initial shape, else they are ignored.</p>
<p>The actual features removal is performed by the low-level <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___remove_features.html">BOPAlgo_RemoveFeatures</a></em> algorithm. On the API level, all inputs are passed into the tool and the method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___remove_features.html#ae867cbd47cfb1c232f7133a98a42e2a9">BOPAlgo_RemoveFeatures::Perform()</a></em> is called.</p>
<p>Before removing features, all faces to be removed from the shape are sorted into connected blocks - each block represents a single feature to be removed. The features are removed from the shape one by one, which allows removing all possible features even if there are some problems with their removal (e.g. due to incorrect input data).</p>
<p>The removed feature is filled by the extension of the faces adjacent to it. In general, the algorithm removing a single feature from the shape goes as follows:</p><ul>
<li>Find the faces adjacent to the feature;</li>
<li>Extend the adjacent faces to cover the feature;</li>
<li>Trim the extended faces by the bounds of the original face (except for the bounds common with the feature), so that they cover the feature only;</li>
<li>Rebuild the solids with reconstructed adjacent faces avoiding the feature faces.</li>
</ul>
<p>If the single feature removal was successful, the result shape is overwritten with the new shape, otherwise the results are not kept, and the warning is given. Either way the process continues with the next feature.</p>
<p>The Defeaturing algorithm has the following options:</p><ul>
<li>History support;</li>
</ul>
<p>and the options available from base class (<em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___options.html">BOPAlgo_Options</a></em>):</p><ul>
<li>Error/Warning reporting system;</li>
<li>Parallel processing mode.</li>
</ul>
<p>Note that the other options of the base class are not supported here and will have no effect.</p>
<p><b>History support</b> allows tracking modification of the input shape in terms of Modified, IsDeleted and Generated. By default, the history is collected, but it is possible to disable it using the method <em>SetToFillHistory(false)</em>. On the low-level the history information is collected by the history tool <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em>, which can be accessed through the method <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_shape.html#aefe7a5ef107403d0de23606c481de365">BOPAlgo_RemoveFeatures::History()</a></em>.</p>
<p><b>Error/Warning reporting system</b> allows obtaining the extended overview of the Errors/Warnings occurred during the operation. As soon as any error appears, the algorithm stops working. The warnings allow continuing the job and informing the user that something went wrong. The algorithm returns the following errors/warnings:</p><ul>
<li><em>BOPAlgo_AlertUnsupportedType</em> - the alert will be given as an error if the input shape does not contain any solids, and as a warning if the input shape contains not only solids, but also other shapes;</li>
<li><em>BOPAlgo_AlertNoFacesToRemove</em> - the error alert is given in case there are no faces to remove from the shape (nothing to do);</li>
<li><em>BOPAlgo_AlertUnableToRemoveTheFeature</em> - the warning alert is given to inform the user the removal of the feature is not possible. The algorithm will still try to remove the other features;</li>
<li><em>BOPAlgo_AlertRemoveFeaturesFailed</em> - the error alert is given in case if the operation was aborted by the unknown reason.</li>
</ul>
<p>For more information on the error/warning reporting system, see the chapter <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_ers">Errors and warnings reporting system</a> of Boolean operations user guide.</p>
<p><b>Parallel processing mode</b> - allows running the algorithm in parallel mode obtaining the result faster.</p>
<p>The algorithm has certain limitations:</p><ul>
<li>Intersection of the surfaces of the connected faces adjacent to the feature should not be empty. It means, that such faces should not be tangent to each other. If the intersection of the adjacent faces will be empty, the algorithm will be unable to trim the faces correctly and, most likely, the feature will not be removed.</li>
<li>The algorithm does not process the INTERNAL parts of the solids, they are simply removed during reconstruction.</li>
</ul>
<p>Note, that for successful removal of the feature, the extended faces adjacent to the feature should cover the feature completely, otherwise the solids will not be rebuild. Take a look at the simple shape on the image below: </p><div class="image">
<img src="modeling_algos_rf_im001.png" alt="modeling_algos_rf_im001.png"/>
</div>
<p> Removal of all three faces of the gap is not going to work, because there will be no face to fill the transverse part of the step. Although, removal of only two faces, keeping one of the transverse faces, will fill the gap with the kept face: </p><table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im002.png" alt="modeling_algos_rf_im002.png"/>
<div class="caption">
Keeping the right transverse face</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im003.png" alt="modeling_algos_rf_im003.png"/>
<div class="caption">
Keeping the left transverse face</div></div>
  </td></tr>
</table>
<h2><a class="anchor" id="occt_modalg_defeaturing_usage"></a>
Usage</h2>
<p>Here is the example of usage of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___defeaturing.html">BRepAlgoAPI_Defeaturing</a></em> algorithm on the C++ level: </p><div class="fragment"><div class="line">TopoDS_Shape aSolid = ...;               // Input shape to remove the features from</div><div class="line">TopTools_ListOfShape aFeatures = ...;    // Features to remove from the shape</div><div class="line">Standard_Boolean bRunParallel = ...;     // Parallel processing mode</div><div class="line">Standard_Boolean isHistoryNeeded = ...;  // History support</div><div class="line"></div><div class="line">BRepAlgoAPI_Defeaturing aDF;             // Defeaturing algorithm</div><div class="line">aDF.SetShape(aSolid);                    // Set the shape</div><div class="line">aDF.AddFacesToRemove(aFaces);            // Add faces to remove</div><div class="line">aDF.SetRunParallel(bRunParallel);        // Define the processing mode (parallel or single)</div><div class="line">aDF.SetToFillHistory(isHistoryNeeded);   // Define whether to track the shapes modifications</div><div class="line">aDF.Build();                             // Perform the operation</div><div class="line">if (!aDF.IsDone())                       // Check for the errors</div><div class="line">{</div><div class="line">  // error treatment</div><div class="line">  Standard_SStream aSStream;</div><div class="line">  aDF.DumpErrors(aSStream);</div><div class="line">  return;</div><div class="line">}</div><div class="line">if (aDF.HasWarnings())                   // Check for the warnings</div><div class="line">{</div><div class="line">  // warnings treatment</div><div class="line">  Standard_SStream aSStream;</div><div class="line">  aDF.DumpWarnings(aSStream);</div><div class="line">}</div><div class="line">const TopoDS_Shape&amp; aResult = aDF.Shape(); // Result shape</div></div><!-- fragment --><p>Use the API history methods to track the history of a shape: </p><div class="fragment"><div class="line">// Obtain modification of the shape</div><div class="line">const TopTools_ListOfShape&amp; BRepAlgoAPI_Defeaturing::Modified(const TopoDS_Shape&amp; theS);</div><div class="line"></div><div class="line">// Obtain shapes generated from the shape</div><div class="line">const TopTools_ListOfShape&amp; BRepAlgoAPI_Defeaturing::Generated(const TopoDS_Shape&amp; theS);</div><div class="line"></div><div class="line">// Check if the shape is removed or not</div><div class="line">Standard_Boolean BRepAlgoAPI_Defeaturing::IsDeleted(const TopoDS_Shape&amp; theS);</div></div><!-- fragment --><p>The command <b>removefeatures</b> allows using the Defeaturing algorithm on the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> level.</p>
<p>The <a class="el" href="occt_user_guides__test_harness.html#occt_draw_hist">standard history commands</a> can be used to track the history of shape modification during Defeaturing.</p>
<p>For more details on commands above, refer to the <a class="el" href="occt_user_guides__test_harness.html#occt_draw_defeaturing">Defeaturing commands</a> of the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> test harness user guide.</p>
<h2><a class="anchor" id="occt_modalg_defeaturing_examples"></a>
Examples</h2>
<p>Here are the examples of defeaturing of the ANC101 model:</p>
<div class="image">
<img src="modeling_algos_rf_im004.png" alt="modeling_algos_rf_im004.png"/>
<div class="caption">
ANC101 model</div></div>
<table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im005.png" alt="modeling_algos_rf_im005.png"/>
<div class="caption">
Removing the cylindrical protrusion</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im006.png" alt="modeling_algos_rf_im006.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im007.png" alt="modeling_algos_rf_im007.png"/>
<div class="caption">
Removing the cylindrical holes</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im008.png" alt="modeling_algos_rf_im008.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im009.png" alt="modeling_algos_rf_im009.png"/>
<div class="caption">
Removing the cylindrical holes</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im010.png" alt="modeling_algos_rf_im010.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im011.png" alt="modeling_algos_rf_im011.png"/>
<div class="caption">
Removing the small gaps in the front</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im012.png" alt="modeling_algos_rf_im012.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im013.png" alt="modeling_algos_rf_im013.png"/>
<div class="caption">
Removing the gaps in the front completely</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im014.png" alt="modeling_algos_rf_im014.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im015.png" alt="modeling_algos_rf_im015.png"/>
<div class="caption">
Removing the cylindrical protrusion</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im016.png" alt="modeling_algos_rf_im016.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
</table>
<p>Here are the few examples of defeaturing of the model containing boxes with blends:</p>
<div class="image">
<img src="modeling_algos_rf_im017.png" alt="modeling_algos_rf_im017.png"/>
<div class="caption">
Box blend model</div></div>
<table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im018.png" alt="modeling_algos_rf_im018.png"/>
<div class="caption">
Removing the blend</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im019.png" alt="modeling_algos_rf_im019.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im020.png" alt="modeling_algos_rf_im020.png"/>
<div class="caption">
Removing the blend</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im021.png" alt="modeling_algos_rf_im021.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im022.png" alt="modeling_algos_rf_im022.png"/>
<div class="caption">
Removing the blend</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im023.png" alt="modeling_algos_rf_im023.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im024.png" alt="modeling_algos_rf_im024.png"/>
<div class="caption">
Removing the blend</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im025.png" alt="modeling_algos_rf_im025.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im026.png" alt="modeling_algos_rf_im026.png"/>
<div class="caption">
Removing the blend</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im027.png" alt="modeling_algos_rf_im027.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="modeling_algos_rf_im028.png" alt="modeling_algos_rf_im028.png"/>
<div class="caption">
Removing the blend</div></div>
 </td><td><div class="image">
<img src="modeling_algos_rf_im029.png" alt="modeling_algos_rf_im029.png"/>
<div class="caption">
Result</div></div>
  </td></tr>
</table>
<h1><a class="anchor" id="occt_modalg_makeperiodic"></a>
3D Model Periodicity</h1>
<p>Open CASCADE Technology provides tools for making an arbitrary 3D model (or just shape) periodic in 3D space in the specified directions.</p>
<p>Periodicity of the shape means that the shape can be repeated in any periodic direction any number of times without creation of the new geometry or splits. The idea of this algorithm is to make the shape look similarly on the opposite sides or on the period bounds of periodic directions. It does not mean that the opposite sides of the shape will be mirrored. It just means that the opposite sides of the shape should be split by each other and obtain the same geometry on opposite sides. Such approach will allow repeating the shape, i.e. translating the copy of a shape on the period, without creation of new geometry because there will be no coinciding parts of different dimension.</p>
<p>For better understanding of what periodicity means lets create a simple prism and make it periodic. The following draw script creates the L-shape prism with extensions 10x5x10: </p><div class="fragment"><div class="line">polyline p 0 0 0 0 0 10 5 0 10 5 0 5 10 0 5 10 0 0 0 0 0</div><div class="line">mkplane f p</div><div class="line">prism s f 0 5 0</div></div><!-- fragment --> <div class="image">
<img src="modeling_algos_mkperiodic_im001.png" alt="modeling_algos_mkperiodic_im001.png"/>
<div class="caption">
Shape to make periodic</div></div>
<p> Making this shape periodic in X, Y and Z directions with the periods matching the shape's extensions should make the splits of negative X and Z sides of the shape. The shape is already similar on opposite sides of Y directions, thus no new splits is expected. Here is the shape after making it periodic: </p><div class="image">
<img src="modeling_algos_mkperiodic_im002.png" alt="modeling_algos_mkperiodic_im002.png"/>
<div class="caption">
Periodic shape</div></div>
<p>And here is the repetition of the shape once in X and Z directions: </p><div class="image">
<img src="modeling_algos_mkperiodic_im003.png" alt="modeling_algos_mkperiodic_im003.png"/>
<div class="caption">
Repeated shape</div></div>
<p> The OCCT Shape Periodicity tools also allows making the shape periodic with the period not matching the shape's extensions. Let's make the shape periodic with 11, 6 and 11 for X, Y, Z periods accordingly. Such values of periods mean that there will be a gap between repeated shapes, and since during repetition the opposite sides do not touch the shape will not be split at all. Here is the repetition of the shape once in X and Z directions: </p><div class="image">
<img src="modeling_algos_mkperiodic_im004.png" alt="modeling_algos_mkperiodic_im004.png"/>
<div class="caption">
Repeated shape</div></div>
<p>As expected, the shape is not split and the repeated elements do not touch.</p>
<p>If necessary the algorithm will trim the shape to fit into the requested period by splitting it with the planes limiting the shape's requested periods. E.g. let's make the L-shape periodic only in X direction with the period 2 starting at X parameter 4: </p><div class="image">
<img src="modeling_algos_mkperiodic_im005.png" alt="modeling_algos_mkperiodic_im005.png"/>
<div class="caption">
Periodic trimmed shape</div></div>
 <h2><a class="anchor" id="occt_modalg_makeperiodic_how_it_works"></a>
How the shape is made periodic</h2>
<p>For making the shape periodic in certain direction the algorithm performs the following steps:</p><ul>
<li>Creates the copy of the shape and moves it on the period into negative side of the requested direction;</li>
<li>Splits the negative side of the shape by the moved copy, ensuring copying of the geometry from positive side to negative;</li>
<li>Creates the copy of the shape (with already split negative side) and moves it on the period into the positive side of the requested direction;</li>
<li>Splits the positive side of the shape by the moved copy, ensuring copying of the geometry from negative side to positive.</li>
</ul>
<p>Repeated copying of the geometry ensures that the corner edges of the periodic shape will have the same geometry on opposite sides of all periodic directions.</p>
<p>Thus, in the periodic shape the geometry from positive side of the shape is always copied on the negative side of periodic directions.</p>
<h2><a class="anchor" id="occt_modalg_makeperiodic_association"></a>
Opposite shapes association</h2>
<p>The algorithm also associates the identical (or twin) shapes located on the opposite sides of the periodic shape. By the construction, the twin shapes should always have the same geometry and distanced from each other on the period. It is possible that the shape does not have any twins. It means that when repeating this shape will not touch the opposite side of the shape. In the example when the periods of the shape are grater than its extensions, non of the sub-shapes has a twin.</p>
<h2><a class="anchor" id="occt_modalg_makeperiodic_repetition"></a>
Periodic shape repetition</h2>
<p>The algorithm also provides the methods to repeat the periodic shape in periodic directions. To repeat shape the algorithm makes the requested number of copies of the shape and translates them one by one on the time * period value. After all copies are made and translated they are glued to have valid shape. The subsequent repetitions are performed on the repeated shape, thus e.g. repeating the shape two times in any periodic direction will create result containing three shapes (original plus two copies). Single subsequent repetition in any direction will result already in 6 shapes.</p>
<p>The repetitions can be cleared and started over.</p>
<h2><a class="anchor" id="occt_modalg_makeperiodic_history"></a>
History support</h2>
<p>The algorithm supports the history of shapes modifications, thus it is possible to track how the shapes have been changed to make it periodic and what new shapes have been created during repetitions. Both split history and history of periodic shape repetition are available here. Note, that all repeated shapes are stored as generated into the history.</p>
<p><em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> is used for history support.</p>
<h2><a class="anchor" id="occt_modalg_makeperiodic_errors"></a>
Errors/Warnings</h2>
<p>The algorithm supports the Error/Warning reporting system which allows obtaining the extended overview of the errors and warning occurred during the operation. As soon as any error appears the algorithm stops working. The warnings allow continuing the job, informing the user that something went wrong. The algorithm returns the following alerts:</p><ul>
<li><em>BOPAlgo_AlertNoPeriodicityRequired</em> - Error alert is given if no periodicity has been requested in any direction;</li>
<li><em>BOPAlgo_AlertUnableToTrim</em> - Error alert is given if the trimming of the shape for fitting it into requested period has failed;</li>
<li><em>BOPAlgo_AlertUnableToMakeIdentical</em> - Error alert is given if splitting of the shape by its moved copies has failed;</li>
<li><em>BOPAlgo_AlertUnableToRepeat</em> - Warning alert is given if the gluing of the repeated shapes has failed.</li>
</ul>
<p>For more information on the error/warning reporting system please see the chapter <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_ers">Errors and warnings reporting system</a> of Boolean operations user guide.</p>
<h2><a class="anchor" id="occt_modalg_makeperiodic_usage"></a>
Usage</h2>
<p>The algorithm is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___make_periodic.html">BOPAlgo_MakePeriodic</a></em>. Here is the example of its usage on the API level: </p><div class="fragment"><div class="line">TopoDS_Shape aShape = ...;                 // The shape to make periodic</div><div class="line">Standard_Boolean bMakeXPeriodic = ...;     // Flag for making or not the shape periodic in X direction</div><div class="line">Standard_Real aXPeriod = ...;              // X period for the shape</div><div class="line">Standard_Boolean isXTrimmed = ...;         // Flag defining whether it is necessary to trimming</div><div class="line">                                           // the shape to fit to X period</div><div class="line">Standard_Real aXFirst = ...;               // Start of the X period</div><div class="line">                                           // (really necessary only if the trimming is requested)</div><div class="line">Standard_Boolean bRunParallel = ...;       // Parallel processing mode or single</div><div class="line"></div><div class="line">BOPAlgo_MakePeriodic aPeriodicityMaker;                   // Periodicity maker</div><div class="line">aPeriodicityMaker.SetShape(aShape);                       // Set the shape</div><div class="line">aPeriodicityMaker.MakeXPeriodic(bMakePeriodic, aXPeriod); // Making the shape periodic in X direction</div><div class="line">aPeriodicityMaker.SetTrimmed(isXTrimmed, aXFirst);        // Trim the shape to fit X period</div><div class="line">aPeriodicityMaker.SetRunParallel(bRunParallel);           // Set the parallel processing mode</div><div class="line">aPeriodicityMaker.Perform();                              // Performing the operation</div><div class="line"></div><div class="line">if (aPeriodicityMaker.HasErrors())                        // Check for the errors</div><div class="line">{</div><div class="line">  // errors treatment</div><div class="line">  Standard_SStream aSStream;</div><div class="line">  aPeriodicityMaker.DumpErrors(aSStream);</div><div class="line">  return;</div><div class="line">}</div><div class="line">if (aPeriodicityMaker.HasWarnings())                      // Check for the warnings</div><div class="line">{</div><div class="line">  // warnings treatment</div><div class="line">  Standard_SStream aSStream;</div><div class="line">  aPeriodicityMaker.DumpWarnings(aSStream);</div><div class="line">}</div><div class="line">const TopoDS_Shape&amp; aPeriodicShape = aPeriodicityMaker.Shape(); // Result periodic shape</div><div class="line"></div><div class="line">aPeriodicityMaker.XRepeat(2);                                    // Making repetitions</div><div class="line">const TopoDS_Shape&amp; aRepeat = aPeriodicityMaker.RepeatedShape(); // Getting the repeated shape</div><div class="line">aPeriodicityMaker.ClearRepetitions();                            // Clearing the repetitions</div></div><!-- fragment --><p>Please note, that the class is based on the options class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___options.html">BOPAlgo_Options</a></em>, which provides the following options for the algorithm:</p><ul>
<li>Error/Warning reporting system;</li>
<li>Parallel processing mode. The other options of the base class are not supported here and will have no effect.</li>
</ul>
<p>All the history information obtained during the operation is stored into <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> object and available through <em>History()</em> method: </p><div class="fragment"><div class="line">// Get the history object</div><div class="line">const Handle(BRepTools_History)&amp; BOPAlgo_MakePeriodic::History();</div></div><!-- fragment --><p>For the usage of the MakePeriodic algorithm on the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> level the following commands have been implemented:</p><ul>
<li><b>makeperiodic</b></li>
<li><b>repeatshape</b></li>
<li><b>periodictwins</b></li>
<li><b>clearrepetitions</b></li>
</ul>
<p>For more details on the periodicity commands please refer the <a class="el" href="occt_user_guides__test_harness.html#occt_draw_makeperiodic">Periodicity commands</a> of the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> test harness user guide.</p>
<p>To track the history of a shape modification during MakePeriodic operation the <a class="el" href="occt_user_guides__test_harness.html#occt_draw_hist">standard history commands</a> can be used.</p>
<p>To have possibility to access the error/warning shapes of the operation use the <em>bdrawwarnshapes</em> command before running the algorithm (see command usage in the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_ers">Errors and warnings reporting system</a> of Boolean operations user guide).</p>
<h2><a class="anchor" id="occt_modalg_makeperiodic_examples"></a>
Examples</h2>
<p>Imagine that you need to make the drills in the plate on the same distance from each other. To model this process it is necessary to make a lot of cylinders (simulating the drills) and cut these cylinders from the plate. With the periodicity tool, the process looks very simple: </p><div class="fragment"><div class="line"># create plate 100 x 100</div><div class="line">box plate -50 -50 0 100 100 1</div><div class="line"># create a single drill with radius 1</div><div class="line">pcylinder drill 1 1</div><div class="line"># locate the drill in the left corner</div><div class="line">ttranslate drill -48 -48 0</div><div class="line"># make the drill periodic with 4 as X and Y periods, so the distance between drills will be 2</div><div class="line">makeperiodic drill drill -x 4 -trim -50 -y 4 -trim -50</div><div class="line"># repeat the drill to fill the plate, in result we get net of 25 x 25 drills</div><div class="line">repeatshape drills -x 24 -y 24</div><div class="line"># cut the drills from the plate</div><div class="line">bcut result plate drills</div></div><!-- fragment --> <div class="image">
<img src="modeling_algos_mkperiodic_im006.png" alt="modeling_algos_mkperiodic_im006.png"/>
<div class="caption">
Plate with drills</div></div>
<h1><a class="anchor" id="occt_modalg_makeconnected"></a>
Making touching shapes connected</h1>
<p>Open CASCADE Technology provides tools for making the same-dimensional touching shapes connected (or glued), i.e. for making the coinciding geometries topologically shared among shapes. To make the shapes connected they are glued by the means of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7">General Fuse algorithm</a>. The option BOPAlgo_GlueShift is used, thus if the input shapes have been interfering the algorithm will be unable to recognize this.</p>
<p>Making the group of shapes connected can be useful e.g. before meshing the group. It will allow making the resulting mesh conformal.</p>
<p>The algorithm for making the shapes connected is implemented in the class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___make_connected.html">BOPAlgo_MakeConnected</a></em>.</p>
<h2><a class="anchor" id="occt_modalg_makeconnected_materials"></a>
Material association</h2>
<p>In frames of this tool the input shapes are called materials, and each input shape has a unique material.</p>
<p>After making the shapes connected, the border elements of the input shapes are associated with the shapes to which they belong. At that, the orientation of the border elements in the shape is taken into account. The associations are made for the following types:</p><ul>
<li>For input SOLIDS the resulting FACES are associated with the input solids;</li>
<li>For input FACES the resulting EDGES are associated with the input faces;</li>
<li>For input EDGES the resulting VERTICES are associated with the input edges. The association process is called the material association. It allows finding the coinciding elements for the opposite input shapes. These elements will be associated to at least two materials (one on the positive side of the shape, the other - on negative).</li>
</ul>
<p>For obtaining the material information the following methods should be used</p><ul>
<li><em>MaterialsOnPositiveSide()</em> - returns the original shapes (materials) located on the positive side of the given shape (i.e. with FORWARD orientation);</li>
<li><em>MaterialsOnNegativeSide()</em> - returns the original shapes (materials) located on the negative side of the given shape (i.e. with REVERSED orientation);</li>
</ul>
<div class="fragment"><div class="line">// Returns the original shapes which images contain the given shape with FORWARD orientation.</div><div class="line">const TopTools_ListOfShape&amp; BOPAlgo_MakeConnected::MaterialsOnPositiveSide(const TopoDS_Shape&amp; theS)</div><div class="line"></div><div class="line">// Returns the original shapes which images contain the given shape with REVERSED orientation.</div><div class="line">const TopTools_ListOfShape&amp; BOPAlgo_MakeConnected::MaterialsOnNegativeSide(const TopoDS_Shape&amp; theS)</div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_makeconnected_makeperiodic"></a>
Making connected shape periodic</h2>
<p>The tool provides possibility to make the connected shape <a class="el" href="occt_user_guides__modeling_algos.html#occt_modalg_makeperiodic">periodic</a>. Since by making the shape periodic it ensures that the geometry of coinciding shapes on the opposite sides will be the same it allows reusing the mesh of the shape for its periodic twins.</p>
<p>After making the shape periodic the material associations are updated to correspond to the actual state of the result shape. Repetition of the periodic shape is also possible from here. Material associations are not going to be lost.</p>
<h2><a class="anchor" id="occt_modalg_makeconnected_history"></a>
History support</h2>
<p>The algorithm supports history of shapes modifications during the operation. Additionally to standard history method provided by <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> and used here as a history tool, the algorithm also provides the method to track the back connection - from resulting shapes to the input ones. The method is called <em>GetOrigins()</em>: </p><div class="fragment"><div class="line">// Returns the list of original shapes from which the current shape has been created.</div><div class="line">const TopTools_ListOfShape&amp; BOPAlgo_MakeConnected::GetOrigins(const TopoDS_Shape&amp; theS);</div></div><!-- fragment --><p>Both Gluing history and history of making the shape periodic and periodic shape repetition are available here. Note, that all repeated shapes are stored as generated into the history.</p>
<h2><a class="anchor" id="occt_modalg_makeconnected_errors"></a>
Errors/Warnings</h2>
<p>The algorithm supports the Error/Warning reporting system which allows obtaining the extended overview of the errors and warning occurred during the operation. As soon as any error appears the algorithm stops working. The warnings allow continuing the job, informing the user that something went wrong. The algorithm returns the following alerts:</p><ul>
<li><em>BOPAlgo_AlertTooFewArguments</em> - error alert is given on the attempt to run the algorithm without the arguments;</li>
<li><em>BOPAlgo_AlertMultiDimensionalArguments</em> - error alert is given on the attempt to run the algorithm on multi-dimensional arguments;</li>
<li><em>BOPAlgo_AlertUnableToGlue</em> - error alert is given if the gluer algorithm is unable to glue the given arguments;</li>
<li><em>BOPAlgo_AlertUnableToMakePeriodic</em> - warning alert is given if the periodicity maker is unable to make the connected shape periodic with given options;</li>
<li><em>BOPAlgo_AlertShapeIsNotPeriodic</em> - warning alert is given on the attempt to repeat the shape before making it periodic.</li>
</ul>
<p>For more information on the error/warning reporting system please see the chapter <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_ers">Errors and warnings reporting system</a> of Boolean operations user guide.</p>
<h2><a class="anchor" id="occt_modalg_makeconnected_usage"></a>
Usage</h2>
<p>Here is the example of usage of the <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___make_periodic.html">BOPAlgo_MakePeriodic</a></em> algorithm on the API level: </p><div class="fragment"><div class="line">TopTools_ListOfShape anArguments = ...;  // Shapes to make connected</div><div class="line">Standard_Boolean bRunParallel = ...;     // Parallel processing mode</div><div class="line"></div><div class="line">BOPAlgo_MakeConnected aMC;               // Tool for making the shapes connected</div><div class="line">aMC.SetArguments(anArguments);           // Set the shapes</div><div class="line">aMC.SetRunParallel(bRunParallel);        // Set parallel processing mode</div><div class="line">aMC.Perform();                           // Perform the operation</div><div class="line"></div><div class="line">if (aMC.HasErrors())                     // Check for the errors</div><div class="line">{</div><div class="line">  // errors treatment</div><div class="line">  Standard_SStream aSStream;</div><div class="line">  aMC.DumpErrors(aSStream);</div><div class="line">  return;</div><div class="line">}</div><div class="line">if (aMC.HasWarnings())                   // Check for the warnings</div><div class="line">{</div><div class="line">  // warnings treatment</div><div class="line">  Standard_SStream aSStream;</div><div class="line">  aMC.DumpWarnings(aSStream);</div><div class="line">}</div><div class="line"></div><div class="line">const TopoDS_Shape&amp; aGluedShape = aMC.Shape(); // Connected shape</div><div class="line"></div><div class="line">// Checking material associations</div><div class="line">TopAbs_ShapeEnum anElemType = ...;       // Type of border element</div><div class="line">TopExp_Explorer anExp(anArguments.First(), anElemType);</div><div class="line">for (; anExp.More(); anExp.Next())</div><div class="line">{</div><div class="line">  const TopoDS_Shape&amp; anElement = anExp.Current();</div><div class="line">  const TopTools_ListOfShape&amp; aNegativeM = aMC.MaterialsOnNegativeSide(anElement);</div><div class="line">  const TopTools_ListOfShape&amp; aPositiveM = aMC.MaterialsOnPositiveSide(anElement);</div><div class="line">}</div><div class="line"></div><div class="line">// Making the connected shape periodic</div><div class="line">BOPAlgo_MakePeriodic::PeriodicityParams aParams = ...; // Options for periodicity of the connected shape</div><div class="line">aMC.MakePeriodic(aParams);</div><div class="line"></div><div class="line">// Shape repetition after making it periodic</div><div class="line">// Check if the shape has been made periodic successfully</div><div class="line">if (aMC.PeriodicityTool().HasErrors())</div><div class="line">{</div><div class="line">  // Periodicity maker error treatment</div><div class="line">}</div><div class="line"></div><div class="line">// Shape repetition in periodic directions</div><div class="line">aMC.RepeatShape(0, 2);</div><div class="line"></div><div class="line">const TopoDS_Shape&amp; aShape = aMC.PeriodicShape(); // Periodic and repeated shape</div></div><!-- fragment --><p>Please note, that the class is based on the options class <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___options.html">BOPAlgo_Options</a></em>, which provides the following options for the algorithm:</p><ul>
<li>Error/Warning reporting system;</li>
<li>Parallel processing mode. The other options of the base class are not supported here and will have no effect.</li>
</ul>
<p>All the history information obtained during the operation is stored into <em><a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___history.html">BRepTools_History</a></em> object and available through <em>History()</em> method: </p><div class="fragment"><div class="line">// Get the history object</div><div class="line">const Handle(BRepTools_History)&amp; BOPAlgo_MakeConnected::History();</div></div><!-- fragment --><p>For the usage of the MakeConnected algorithm on the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> level the following commands have been implemented:</p><ul>
<li><b>makeconnected</b></li>
<li><b>cmaterialson</b></li>
<li><b>cmakeperiodic</b></li>
<li><b>crepeatshape</b></li>
<li><b>cperiodictwins</b></li>
<li><b>cclearrepetitions</b></li>
</ul>
<p>For more details on the connexity commands please refer the <a class="el" href="occt_user_guides__test_harness.html#occt_draw_makeconnected">MakeConnected commands</a> of the <a class="elRef" doxygen="C:/builds/OCCT-740_OCCT-740/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draw.html">Draw</a> test harness user guide.</p>
<p>To track the history of a shape modification during MakeConnected operation the <a class="el" href="occt_user_guides__test_harness.html#occt_draw_hist">standard history commands</a> can be used.</p>
<p>To have possibility to access the error/warning shapes of the operation use the <em>bdrawwarnshapes</em> command before running the algorithm (see command usage in the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_ers">Errors and warnings reporting system</a> of Boolean operations user guide). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 26 2019 18:39:15 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
